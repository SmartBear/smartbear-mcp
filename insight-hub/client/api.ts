/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Insight Hub - Data Access API
 * Allows you to access information about your Insight Hub errors, projects, organization and more to build custom integrations using your data.
 *
 * OpenAPI spec version: 2
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import { Configuration } from "./configuration.js";

const BASE_PATH = "https://virtserver.swaggerhub.com/smartbear/insight-hub-data-access-api/2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration!: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = globalThis.fetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface CollaboratorsBulkInviteBody
 */
export interface CollaboratorsBulkInviteBody {
    /**
     * A list of emails to invite
     * @type {Array<string>}
     * @memberof CollaboratorsBulkInviteBody
     */
    emails: Array<string>;
    /**
     * The ids of projects in the current organization that the invited user should have access to. Leave blank if the admin field is set to true. Admins have access to all projects. Only one of project_roles and project_ids may be supplied.
     * @type {Array<string>}
     * @memberof CollaboratorsBulkInviteBody
     */
    projectIds?: Array<string>;
    /**
     * The IDs of the projects to which the user should have access, and the roles they should have, either 'project_owner' or 'project_member'. Leave blank if the admin field is set to true. Admins have access to all projects. Only one of project_roles and project_ids may be supplied. This field may only be supplied if the enterprise-roles feature is enabled for the account.
     * @type {{ [key: string]: string; }}
     * @memberof CollaboratorsBulkInviteBody
     */
    projectRoles?: { [key: string]: string; };
    /**
     * Whether to give admin permissions to the invited user(s).
     * @type {boolean}
     * @memberof CollaboratorsBulkInviteBody
     */
    admin?: boolean;
}
/**
 *
 * @export
 * @interface CollaboratorsIdBody
 */
export interface CollaboratorsIdBody {
    /**
     * The ids of projects in the current organization that the invited user should have access to.
     * @type {Array<string>}
     * @memberof CollaboratorsIdBody
     */
    projectIds?: Array<string>;
    /**
     * The IDs of the projects to which the user should have access, and the roles they should have, either 'project_owner' or 'project_member'.
     * @type {{ [key: string]: string; }}
     * @memberof CollaboratorsIdBody
     */
    projectRoles?: { [key: string]: string; };
    /**
     * Whether to give admin permissions to the user.
     * @type {boolean}
     * @memberof CollaboratorsIdBody
     */
    admin?: boolean;
}
/**
 *
 * @export
 * @interface ConfiguredIntegrationsIdBody
 */
export interface ConfiguredIntegrationsIdBody {
    /**
     *
     * @type {ConfiguredIntegrationsidConfiguration}
     * @memberof ConfiguredIntegrationsIdBody
     */
    configuration: ConfiguredIntegrationsidConfiguration;
    /**
     * The release stages that this notification should not be triggered for. Example: { \"disable_release_stages\": [\"development\", \"staging\"] }
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsIdBody
     */
    disableReleaseStages?: Array<string>;
    /**
     * The severities that this notification should not be triggered for.
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsIdBody
     */
    disableSeverities?: Array<ConfiguredIntegrationsIdBody.DisableSeveritiesEnum>;
    /**
     * The kinds of exceptions that this notification should not be triggered for.
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsIdBody
     */
    disableUnhandledStates?: Array<ConfiguredIntegrationsIdBody.DisableUnhandledStatesEnum>;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomation}
     * @memberof ConfiguredIntegrationsIdBody
     */
    issueAutomation?: ConfiguredIntegrationsidIssueAutomation;
    /**
     * A label for use in identifying the issue tracker.
     * @type {string}
     * @memberof ConfiguredIntegrationsIdBody
     */
    label?: string;
    /**
     * The id of the integration connection to base this configured integration off of.
     * @type {string}
     * @memberof ConfiguredIntegrationsIdBody
     */
    integrationConnectionId?: string;
}

/**
 * @export
 * @namespace ConfiguredIntegrationsIdBody
 */
export namespace ConfiguredIntegrationsIdBody {
    /**
     * @export
     * @enum {string}
     */
    export enum DisableSeveritiesEnum {
        Error = <any>'error',
        Warning = <any>'warning',
        Info = <any>'info'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DisableUnhandledStatesEnum {
        Unhandled = <any>'unhandled',
        Handled = <any>'handled'
    }
}
/**
 * A map of the configuration parameters required for the integration. The fields vary depending on the integration being configured.
 * @export
 * @interface ConfiguredIntegrationsidConfiguration
 */
export interface ConfiguredIntegrationsidConfiguration {
    /**
     *
     * @type {string}
     * @memberof ConfiguredIntegrationsidConfiguration
     */
    userName?: string;
    /**
     *
     * @type {string}
     * @memberof ConfiguredIntegrationsidConfiguration
     */
    projectId?: string;
    /**
     *
     * @type {string}
     * @memberof ConfiguredIntegrationsidConfiguration
     */
    password?: string;
}
/**
 * Automation settings (applicable for `issue-tracker` integrations only).
 * @export
 * @interface ConfiguredIntegrationsidIssueAutomation
 */
export interface ConfiguredIntegrationsidIssueAutomation {
    /**
     * The identifier for the style type of the automation settings. For most integrations there is only one called 'default'.
     * @type {string}
     * @memberof ConfiguredIntegrationsidIssueAutomation
     */
    automationStyleType?: string;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomationErrorFixed}
     * @memberof ConfiguredIntegrationsidIssueAutomation
     */
    errorFixed?: ConfiguredIntegrationsidIssueAutomationErrorFixed;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomationErrorReopened}
     * @memberof ConfiguredIntegrationsidIssueAutomation
     */
    errorReopened?: ConfiguredIntegrationsidIssueAutomationErrorReopened;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomationIssueResolved}
     * @memberof ConfiguredIntegrationsidIssueAutomation
     */
    issueResolved?: ConfiguredIntegrationsidIssueAutomationIssueResolved;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomationIssueUnresolved}
     * @memberof ConfiguredIntegrationsidIssueAutomation
     */
    issueUnresolved?: ConfiguredIntegrationsidIssueAutomationIssueUnresolved;
}
/**
 * Automation settings for when an error is marked as fixed in Bugsnag.
 * @export
 * @interface ConfiguredIntegrationsidIssueAutomationErrorFixed
 */
export interface ConfiguredIntegrationsidIssueAutomationErrorFixed {
    /**
     * True if this automation is active (enabled).
     * @type {boolean}
     * @memberof ConfiguredIntegrationsidIssueAutomationErrorFixed
     */
    active?: boolean;
    /**
     * The state that the issue should be transitioned to when the automation is triggered (required for `error_fixed` and `error_reopened`).
     * @type {string}
     * @memberof ConfiguredIntegrationsidIssueAutomationErrorFixed
     */
    state?: string;
    /**
     * The states that when an issue is transitioned to should cause the Bugsnag issue to change status correspondingly (required for `issue_resolved` and `issue_unresolved`).
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidIssueAutomationErrorFixed
     */
    states?: Array<string>;
}
/**
 * Automation settings for when an error is reopened in Bugsnag.
 * @export
 * @interface ConfiguredIntegrationsidIssueAutomationErrorReopened
 */
export interface ConfiguredIntegrationsidIssueAutomationErrorReopened {
    /**
     * True if this automation is active (enabled).
     * @type {boolean}
     * @memberof ConfiguredIntegrationsidIssueAutomationErrorReopened
     */
    active?: boolean;
    /**
     * The state that the issue should be transitioned to when the automation is triggered (required for `error_fixed` and `error_reopened`).
     * @type {string}
     * @memberof ConfiguredIntegrationsidIssueAutomationErrorReopened
     */
    state?: string;
    /**
     * The states that when an issue is transitioned to should cause the Bugsnag issue to change status correspondingly (required for `issue_resolved` and `issue_unresolved`).
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidIssueAutomationErrorReopened
     */
    states?: Array<string>;
}
/**
 * Automation settings for when an issue is transitioned to resolved in the issue tracker.
 * @export
 * @interface ConfiguredIntegrationsidIssueAutomationIssueResolved
 */
export interface ConfiguredIntegrationsidIssueAutomationIssueResolved {
    /**
     * True if this automation is active (enabled).
     * @type {boolean}
     * @memberof ConfiguredIntegrationsidIssueAutomationIssueResolved
     */
    active?: boolean;
    /**
     * The state that the issue should be transitioned to when the automation is triggered (required for `error_fixed` and `error_reopened`).
     * @type {string}
     * @memberof ConfiguredIntegrationsidIssueAutomationIssueResolved
     */
    state?: string;
    /**
     * The states that when an issue is transitioned to should cause the Bugsnag issue to change status correspondingly (required for `issue_resolved` and `issue_unresolved`).
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidIssueAutomationIssueResolved
     */
    states?: Array<string>;
}
/**
 * Automation settings for when an issue is transitioned to unresolved in the issue tracker.
 * @export
 * @interface ConfiguredIntegrationsidIssueAutomationIssueUnresolved
 */
export interface ConfiguredIntegrationsidIssueAutomationIssueUnresolved {
    /**
     * True if this automation is active (enabled).
     * @type {boolean}
     * @memberof ConfiguredIntegrationsidIssueAutomationIssueUnresolved
     */
    active?: boolean;
    /**
     * The state that the issue should be transitioned to when the automation is triggered (required for `error_fixed` and `error_reopened`).
     * @type {string}
     * @memberof ConfiguredIntegrationsidIssueAutomationIssueUnresolved
     */
    state?: string;
    /**
     * The states that when an issue is transitioned to should cause the Bugsnag issue to change status correspondingly (required for `issue_resolved` and `issue_unresolved`).
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidIssueAutomationIssueUnresolved
     */
    states?: Array<string>;
}
/**
 *
 * @export
 * @interface ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter
 */
export interface ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter {
    /**
     * the error statuses to include
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter
     */
    errorStatuses?: Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter.ErrorStatusesEnum>;
    /**
     * the release stages to include
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter
     */
    releaseStages?: Array<string>;
    /**
     * the severities to include
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter
     */
    severities?: Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter.SeveritiesEnum>;
    /**
     * unhandled states to include
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter
     */
    unhandledStates?: Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter.UnhandledStatesEnum>;
}

/**
 * @export
 * @namespace ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter
 */
export namespace ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter {
    /**
     * @export
     * @enum {string}
     */
    export enum ErrorStatusesEnum {
        Open = <any>'open',
        Fixed = <any>'fixed',
        Snoozed = <any>'snoozed',
        Ignored = <any>'ignored'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SeveritiesEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum UnhandledStatesEnum {
        Unhandled = <any>'unhandled',
        Handled = <any>'handled'
    }
}
/**
 *
 * @export
 * @interface ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
 */
export interface ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings {
    /**
     * must be from the same project as the notification, and have a `type` of `error`
     * @type {string}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    savedSearchId?: string;
    /**
     *
     * @type {ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    basicFilter?: ConfiguredIntegrationsidtriggerConfigstriggerConfigKeyBasicFilter;
    /**
     * for `exception_config` and `project_spiking_config` are all states included, or just open
     * @type {boolean}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    includeAllStates?: boolean;
    /**
     * the release stages to include (only for `new_release_config` trigger config)
     * @type {Array<string>}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    releaseStages?: Array<string>;
    /**
     * for `error_event_frequency_config`, the threshold to alert above
     * @type {number}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    threshold?: number;
    /**
     * for `weekly_performance_summary_email_config` and `daily_performance_summary_email_config`.
     * @type {string}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    condition?: ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings.ConditionEnum;
    /**
     * for 'error_event_frequency_config`, the period for which the threshold applies The supported string format is a whole number followed by either: - \"m\" which represents minutes - \"h\" which represents hours - \"d\" which represents days E.g. \"2h\" is a period of 2 hours. The minimum supported periods are: - \"1m\" - \"1h\" - \"1d\" The maximum supported period is 7 days, or: - \"10080m\" - \"168h\" - \"7d\"
     * @type {string}
     * @memberof ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
     */
    period?: string;
}

/**
 * @export
 * @namespace ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings
 */
export namespace ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings {
    /**
     * @export
     * @enum {string}
     */
    export enum ConditionEnum {
        Always = <any>'always',
        WhenDegraded = <any>'when_degraded'
    }
}
/**
 *
 * @export
 * @interface ErrorsErrorIdBody
 */
export interface ErrorsErrorIdBody {
    /**
     * The Error's new severity. This will be reflected in the Error's `overridden_severity` property. This is only applicable if the `override_severity` option is provided.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    severity?: ErrorsErrorIdBody.SeverityEnum;
    /**
     * The type of update operation to perform. The can be used to change the Error's workflow state (e.g. marking the Error as `fixed`). It must be one of the following: * `override_severity`   Set the Error's severity to the newly supplied `severity` parameter. * `assign`   Assign the Error to the Collaborator specified by the `assigned_collaborator_id` parameter. The error will be unassigned if `assigned_collaborator_id` is blank, the identified Collaborator has not accepted their invitation, or they do not have access to the Error's Project. * `create_issue`   Create an issue for the Error. If the `issue_title` parameter is set, the new issue will be created with this title. * `link_issue`   Link the Error to an existing issue. The url should be provided in the `issue_url` parameter. `verify_issue_url` can be set to control whether Bugsnag should attempt to verify the issue URL with any configured issue tracker integration. This is the default behaviour if `verify_issue_url` is not supplied. * `unlink_issue`   Remove the link between the Error and its current linked issue. * open   Set the Error's status to open. * `snooze`   Snooze the error per the `reopen_rules` parameter. * `fix`   Set the Error's status to fixed. * `ignore`   Ignore the Error. Errors that are ignored and can only be reopened manually. Events are collected, but no notifications are sent. * `delete`   Delete the Error. The Error and all related Events will be removed from Bugsnag. If the error occurs again, it will appear as a new Error with status `Open`. * `discard`   Discard future Events for this Error. The Error and all existing Events will remain in Bugsnag, but future occurrences of the Error will not be stored by Bugsnag or count toward Event usage limits. * `undiscard`   Undiscard the Error. Future Events will be stored for this Error. This undoes the `discard` option.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    operation: ErrorsErrorIdBody.OperationEnum;
    /**
     * The Collaborator to assign to the Error. Errors may be assigned only to users who have accepted their Bugsnag invitation and have access to the project.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    assignedCollaboratorId?: string;
    /**
     * The Team to assign to the Error. Mutually exclusive with `assigned_collaborator_id`.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    assignedTeamId?: string;
    /**
     * Specifies the HTTP link to an external issue when adding or updating a link.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    issueUrl?: string;
    /**
     * Setting `false` will prevent Bugsnag from attempting to verify the `issue_url` with the configured issue tracker when linking an issue. Defaults to `true` if the parameter is not supplied. If no configured issue tracker the parameter is ignored.
     * @type {boolean}
     * @memberof ErrorsErrorIdBody
     */
    verifyIssueUrl?: boolean;
    /**
     * If the Error has a `created_issue`, the `issue_title` request field can be set to update the issue's title.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    issueTitle?: string;
    /**
     * ID of the issue tracker to use for `create_issue` and `link_issue` operations. The most recent issue tracker is used if the parameter is omitted, and no issue tracker is used even if `notification_id` is set for `link_issue` operations if `verify_issue_url` is `false`.
     * @type {string}
     * @memberof ErrorsErrorIdBody
     */
    notificationId?: string;
    /**
     *
     * @type {ProjectsprojectIderrorsReopenRules}
     * @memberof ErrorsErrorIdBody
     */
    reopenRules?: ProjectsprojectIderrorsReopenRules;
}

/**
 * @export
 * @namespace ErrorsErrorIdBody
 */
export namespace ErrorsErrorIdBody {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        OverrideSeverity = <any>'override_severity',
        Assign = <any>'assign',
        CreateIssue = <any>'create_issue',
        LinkIssue = <any>'link_issue',
        UnlinkIssue = <any>'unlink_issue',
        Open = <any>'open',
        Snooze = <any>'snooze',
        Fix = <any>'fix',
        Ignore = <any>'ignore',
        Delete = <any>'delete',
        Discard = <any>'discard',
        Undiscard = <any>'undiscard'
    }
}
/**
 *
 * @export
 * @interface EventFieldsDisplayIdBody
 */
export interface EventFieldsDisplayIdBody {
    /**
     * [Path](https://docs.bugsnag.com/product/custom-filters/advanced-custom-filters/#custom-filter-path) to locate the relevant data inside an Event data structure
     * @type {string}
     * @memberof EventFieldsDisplayIdBody
     */
    path: string;
    /**
     * Whether to reindex historical events for this field
     * @type {boolean}
     * @memberof EventFieldsDisplayIdBody
     */
    reindex?: boolean;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsFilterOptions1}
     * @memberof EventFieldsDisplayIdBody
     */
    filterOptions: ProjectsprojectIdeventFieldsFilterOptions1;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsPivotOptions1}
     * @memberof EventFieldsDisplayIdBody
     */
    pivotOptions?: ProjectsprojectIdeventFieldsPivotOptions1;
}
/**
 *
 * @export
 * @interface Filters
 */
export interface Filters {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters1
 */
export interface Filters1 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters1
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters1
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters1
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters1
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters1
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters1
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters1
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters1
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters1
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters1
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters1
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters1
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters1
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters1
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters1
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters1
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters1
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters1
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters1
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters1
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters1
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters1
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters1
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters1
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters1
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters1
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters1
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters1
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters1
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters1
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters1
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters1
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters1
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters1
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 */
export type Filters10 = Array<Filters10>
/**
 *
 * @export
 */
export type Filters11 = Array<Filters11>
/**
 *
 * @export
 */
export type Filters12 = Array<Filters12>
/**
 *
 * @export
 */
export type Filters13 = Array<Filters13>
/**
 *
 * @export
 */
export type Filters14 = Array<Filters14>
/**
 *
 * @export
 */
export type Filters15 = Array<Filters15>
/**
 *
 * @export
 */
export type Filters16 = Array<Filters16>
/**
 *
 * @export
 * @interface Filters2
 */
export interface Filters2 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters2
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters2
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters2
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters2
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters2
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters2
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters2
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters2
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters2
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters2
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters2
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters2
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters2
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters2
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters2
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters2
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters2
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters2
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters2
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters2
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters2
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters2
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters2
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters2
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters2
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters2
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters2
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters2
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters2
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters2
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters2
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters2
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters2
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters2
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters3
 */
export interface Filters3 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters3
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters3
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters3
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters3
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters3
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters3
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters3
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters3
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters3
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters3
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters3
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters3
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters3
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters3
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters3
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters3
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters3
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters3
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters3
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters3
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters3
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters3
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters3
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters3
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters3
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters3
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters3
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters3
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters3
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters3
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters3
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters3
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters3
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters3
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters4
 */
export interface Filters4 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters4
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters4
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters4
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters4
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters4
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters4
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters4
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters4
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters4
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters4
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters4
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters4
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters4
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters4
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters4
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters4
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters4
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters4
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters4
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters4
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters4
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters4
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters4
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters4
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters4
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters4
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters4
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters4
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters4
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters4
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters4
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters4
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters4
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters4
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters5
 */
export interface Filters5 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters5
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters5
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters5
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters5
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters5
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters5
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters5
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters5
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters5
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters5
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters5
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters5
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters5
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters5
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters5
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters5
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters5
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters5
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters5
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters5
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters5
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters5
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters5
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters5
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters5
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters5
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters5
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters5
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters5
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters5
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters5
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters5
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters5
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters5
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters6
 */
export interface Filters6 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters6
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters6
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters6
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters6
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters6
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters6
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters6
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters6
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters6
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters6
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters6
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters6
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters6
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters6
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters6
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters6
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters6
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters6
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters6
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters6
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters6
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters6
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters6
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters6
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters6
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters6
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters6
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters6
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters6
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters6
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters6
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters6
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters6
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters6
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters7
 */
export interface Filters7 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters7
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters7
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters7
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters7
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters7
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters7
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters7
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters7
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters7
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters7
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters7
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters7
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters7
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters7
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters7
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters7
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters7
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters7
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters7
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters7
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters7
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters7
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters7
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters7
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters7
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters7
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters7
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters7
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters7
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters7
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters7
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters7
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters7
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters7
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface Filters8
 */
export interface Filters8 {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof Filters8
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof Filters8
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof Filters8
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof Filters8
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof Filters8
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof Filters8
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof Filters8
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof Filters8
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof Filters8
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof Filters8
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof Filters8
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof Filters8
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters8
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof Filters8
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters8
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof Filters8
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof Filters8
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof Filters8
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof Filters8
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof Filters8
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof Filters8
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters8
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof Filters8
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof Filters8
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof Filters8
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof Filters8
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof Filters8
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof Filters8
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof Filters8
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof Filters8
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof Filters8
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof Filters8
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof Filters8
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof Filters8
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 */
export type Filters9 = Array<Filters9>
/**
 *
 * @export
 * @interface GroupsIdBody
 */
export interface GroupsIdBody {
    /**
     *
     * @type {string}
     * @memberof GroupsIdBody
     */
    op: GroupsIdBody.OpEnum;
    /**
     * the target to update. Optional for `add` or `replace` operations and required for `remove` operations.
     * @type {string}
     * @memberof GroupsIdBody
     */
    path?: string;
    /**
     * if updating the group's name, provide an object with a `displayName` attribute instead
     * @type {Array<OrganizationsorganizationIdscimv2GroupsidValue>}
     * @memberof GroupsIdBody
     */
    value: Array<OrganizationsorganizationIdscimv2GroupsidValue>;
}

/**
 * @export
 * @namespace GroupsIdBody
 */
export namespace GroupsIdBody {
    /**
     * @export
     * @enum {string}
     */
    export enum OpEnum {
        Add = <any>'add',
        Replace = <any>'replace',
        Remove = <any>'remove'
    }
}
/**
 *
 * @export
 * @interface IdProjectAccessesBody
 */
export interface IdProjectAccessesBody {
    /**
     * Whether to add all remaining projects to the team. If `true`, `project_role` must also be supplied. User making the request must be an organization administrator if using `true`.
     * @type {boolean}
     * @memberof IdProjectAccessesBody
     */
    addAllProjects?: boolean;
    /**
     * The role to give team members on the remaining projects being added.
     * @type {string}
     * @memberof IdProjectAccessesBody
     */
    projectRole?: IdProjectAccessesBody.ProjectRoleEnum;
    /**
     *
     * @type {OrganizationsorganizationIdteamsidprojectAccessesProjectRoles}
     * @memberof IdProjectAccessesBody
     */
    projectRoles?: OrganizationsorganizationIdteamsidprojectAccessesProjectRoles;
}

/**
 * @export
 * @namespace IdProjectAccessesBody
 */
export namespace IdProjectAccessesBody {
    /**
     * @export
     * @enum {string}
     */
    export enum ProjectRoleEnum {
        Owner = <any>'project_owner',
        Member = <any>'project_member'
    }
}
/**
 *
 * @export
 * @interface IdTeamMembershipsBody
 */
export interface IdTeamMembershipsBody {
    /**
     * IDs of the teams to assign the collaborator to. This variable is optional, but required if add_all_teams is false
     * @type {Array<string>}
     * @memberof IdTeamMembershipsBody
     */
    teamIds?: Array<string>;
    /**
     * Whether to assign the collaborator to all teams in the organization
     * @type {boolean}
     * @memberof IdTeamMembershipsBody
     */
    addAllTeams?: boolean;
}
/**
 *
 * @export
 * @interface IdTeamMembershipsBody1
 */
export interface IdTeamMembershipsBody1 {
    /**
     * Collaborators to add to the team.
     * @type {Array<string>}
     * @memberof IdTeamMembershipsBody1
     */
    collaboratorIds?: Array<string>;
    /**
     * Add all organization collaborators to the team. This should not be set if `collaborator_ids` is specified.
     * @type {boolean}
     * @memberof IdTeamMembershipsBody1
     */
    addAllCollaborators?: boolean;
}
/**
 *
 * @export
 * @interface IdTestBody
 */
export interface IdTestBody {
    /**
     * Comma separated list of components to create the issue in
     * @type {string}
     * @memberof IdTestBody
     */
    component?: string;
    /**
     * Additional JSON-encoded Jira fields
     * @type {string}
     * @memberof IdTestBody
     */
    customFields?: string;
    /**
     * URL of your Jira instance
     * @type {string}
     * @memberof IdTestBody
     */
    host?: string;
    /**
     * Whether to ignore TLS validation when making API calls
     * @type {boolean}
     * @memberof IdTestBody
     */
    ignoreTlsValidation?: boolean;
    /**
     * The type of issue to be created
     * @type {string}
     * @memberof IdTestBody
     */
    issueType?: string;
    /**
     * API token generated for your Jira account (use your password for Jira Server)
     * @type {string}
     * @memberof IdTestBody
     */
    password?: string;
    /**
     * The project key for the Jira project
     * @type {string}
     * @memberof IdTestBody
     */
    projectKey?: string;
    /**
     * Your Jira email
     * @type {string}
     * @memberof IdTestBody
     */
    userName?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse200
     */
    id: string;
    /**
     * ID of user who created the saved search
     * @type {string}
     * @memberof InlineResponse200
     */
    userId: string;
    /**
     * ID of project this saved search is for
     * @type {string}
     * @memberof InlineResponse200
     */
    projectId: string;
    /**
     * name of the saved search
     * @type {string}
     * @memberof InlineResponse200
     */
    name: string;
    /**
     *
     * @type {ProjectsprojectIdsavedSearchesFilters}
     * @memberof InlineResponse200
     */
    filters: ProjectsprojectIdsavedSearchesFilters;
    /**
     * the `error` property to sort results by
     * @type {string}
     * @memberof InlineResponse200
     */
    sort: InlineResponse200.SortEnum;
    /**
     * whether this saved search is shared among collaborators
     * @type {boolean}
     * @memberof InlineResponse200
     */
    shared: boolean;
    /**
     * whether this saved search is the project default for the current user
     * @type {boolean}
     * @memberof InlineResponse200
     */
    projectDefault: boolean;
    /**
     * ID of user who last updated this saved search
     * @type {string}
     * @memberof InlineResponse200
     */
    updatedById: string;
    /**
     * time this saved search was created
     * @type {string}
     * @memberof InlineResponse200
     */
    createdAt: string;
    /**
     * time this saved search was last updated
     * @type {string}
     * @memberof InlineResponse200
     */
    updatedAt: string;
    /**
     * indicates if the saved search has a filter with `assigned_to` set to `me`
     * @type {boolean}
     * @memberof InlineResponse200
     */
    hasAssignedToMe: boolean;
    /**
     * indicates if the saved search has a filter with `assigned_to` set to anything other than `me`
     * @type {boolean}
     * @memberof InlineResponse200
     */
    hasAssignedTo: boolean;
    /**
     * indicates if the saved search has a filter with any criteria related to created issues
     * @type {boolean}
     * @memberof InlineResponse200
     */
    hasCreatedIssueFilter: boolean;
    /**
     * indicates if the saved search contains an explicit error status filter
     * @type {boolean}
     * @memberof InlineResponse200
     */
    hasStatusFilter: boolean;
    /**
     * indicates if the saved search may include errors less than 24hrs old
     * @type {string}
     * @memberof InlineResponse200
     */
    newErrorInclusion: InlineResponse200.NewErrorInclusionEnum;
    /**
     * indicates if the saved search may include open errors
     * @type {string}
     * @memberof InlineResponse200
     */
    openErrorInclusion: InlineResponse200.OpenErrorInclusionEnum;
    /**
     * indicates if the saved search may include open errors that are unassigned and have no linked issue
     * @type {string}
     * @memberof InlineResponse200
     */
    forReviewErrorInclusion: InlineResponse200.ForReviewErrorInclusionEnum;
    /**
     * indicates if the saved search may include errors that are snoozed
     * @type {string}
     * @memberof InlineResponse200
     */
    snoozedErrorInclusion: InlineResponse200.SnoozedErrorInclusionEnum;
    /**
     * indicates if the saved search may include errors that are fixed
     * @type {string}
     * @memberof InlineResponse200
     */
    fixedErrorInclusion: InlineResponse200.FixedErrorInclusionEnum;
    /**
     * indicates if the saved search may include errors that are ignored
     * @type {string}
     * @memberof InlineResponse200
     */
    ignoredErrorInclusion: InlineResponse200.IgnoredErrorInclusionEnum;
}

/**
 * @export
 * @namespace InlineResponse200
 */
export namespace InlineResponse200 {
    /**
     * @export
     * @enum {string}
     */
    export enum SortEnum {
        FirstSeen = <any>'first_seen',
        Users = <any>'users',
        Events = <any>'events',
        LastSeen = <any>'last_seen'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NewErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OpenErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ForReviewErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SnoozedErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FixedErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum IgnoredErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * the number of project notifications using this saved search
     * @type {number}
     * @memberof InlineResponse2001
     */
    projectNotificationsCount: number;
    /**
     * whether the current user is using this saved search for email notifications
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    currentUserUsingForEmailNotification: boolean;
    /**
     * the number of other users using this saved search for email notifications
     * @type {number}
     * @memberof InlineResponse2001
     */
    collaboratorEmailNotificationsCount: number;
    /**
     * the number of performance monitors using this saved search
     * @type {number}
     * @memberof InlineResponse2001
     */
    performanceMonitorCount: number;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * ID of the configured integration
     * @type {string}
     * @memberof InlineResponse20010
     */
    id?: string;
    /**
     * Key to identify the integration service.
     * @type {string}
     * @memberof InlineResponse20010
     */
    integrationKey?: string;
    /**
     * ID of the project
     * @type {string}
     * @memberof InlineResponse20010
     */
    projectId?: string;
    /**
     *
     * @type {ConfiguredIntegrationsidConfiguration}
     * @memberof InlineResponse20010
     */
    configuration: ConfiguredIntegrationsidConfiguration;
    /**
     * Description of the configured integration
     * @type {string}
     * @memberof InlineResponse20010
     */
    description?: string;
    /**
     * The release stages that this notification should not be triggered for. Example: { \"disable_release_stages\": [\"development\", \"staging\"] }
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    disableReleaseStages?: Array<string>;
    /**
     * The severities that this notification should not be triggered for.
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    disableSeverities?: Array<InlineResponse20010.DisableSeveritiesEnum>;
    /**
     * The kinds of exceptions that this notification should not be triggered for.
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    disableUnhandledStates?: Array<InlineResponse20010.DisableUnhandledStatesEnum>;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomation}
     * @memberof InlineResponse20010
     */
    issueAutomation?: ConfiguredIntegrationsidIssueAutomation;
    /**
     * The error message from the most recent failure of the integration.
     * @type {string}
     * @memberof InlineResponse20010
     */
    lastFailureMessage?: string;
    /**
     * The total number of times the integration has failed due to a rate limit from the integration.
     * @type {number}
     * @memberof InlineResponse20010
     */
    totalRateLimits?: number;
    /**
     * The ISO8601 timestamp of the last time the integration was successfully used.
     * @type {string}
     * @memberof InlineResponse20010
     */
    lastSuccessfulUsageAt?: string;
    /**
     * The status of the configured integration. * enabled - The integration is enabled. * disabled - The integration is disabled. No notifications will be sent. * failing - The integration is failing. If it continues to fail over a period of time it will become failed. * failed - The integration is failed. No notifications will be sent. An integration can be enabled again by performing a successful [/configured_integrations/test](/insight-hub/docs/data-access-api-v-2#/Integrations/post_configured_integrations__id__test).
     * @type {string}
     * @memberof InlineResponse20010
     */
    status?: InlineResponse20010.StatusEnum;
    /**
     * This will be set if an integration could not be fully configured automatically and requires additional setup by the user. * webhook - A two-way integration requires a webhook in the target system to be created manually. Currently only set for Jira.
     * @type {string}
     * @memberof InlineResponse20010
     */
    additionalSetupRequired?: InlineResponse20010.AdditionalSetupRequiredEnum;
    /**
     * A label for use in identifying the issue tracker.
     * @type {string}
     * @memberof InlineResponse20010
     */
    label?: string;
    /**
     * ID of an associated integration connection.
     * @type {string}
     * @memberof InlineResponse20010
     */
    integrationConnectionId?: string;
}

/**
 * @export
 * @namespace InlineResponse20010
 */
export namespace InlineResponse20010 {
    /**
     * @export
     * @enum {string}
     */
    export enum DisableSeveritiesEnum {
        Error = <any>'error',
        Warning = <any>'warning',
        Info = <any>'info'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DisableUnhandledStatesEnum {
        Unhandled = <any>'unhandled',
        Handled = <any>'handled'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Enabled = <any>'enabled',
        Disabled = <any>'disabled',
        Failing = <any>'failing',
        Failed = <any>'failed'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalSetupRequiredEnum {
        Webhook = <any>'webhook'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse20011
     */
    active: boolean;
    /**
     * settings for the trigger
     * @type {Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings>}
     * @memberof InlineResponse20011
     */
    settings?: Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings>;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * ID of the base configured integration
     * @type {string}
     * @memberof InlineResponse20012
     */
    notificationId?: string;
    /**
     * Description of the configured integration
     * @type {string}
     * @memberof InlineResponse20012
     */
    description?: string;
    /**
     * If the notification is an issue tracker, this is a human-readable project identifier associated with the issue tracker. If there is no human-readable project identifier (e.g. the service uses an API key only) then this will be null.
     * @type {string}
     * @memberof InlineResponse20012
     */
    projectIdentifier?: string;
    /**
     * Key to identify the integration service
     * @type {string}
     * @memberof InlineResponse20012
     */
    integrationKey?: string;
    /**
     * Category of configured integration
     * @type {string}
     * @memberof InlineResponse20012
     */
    category?: string;
    /**
     * Number of triggers enabled
     * @type {number}
     * @memberof InlineResponse20012
     */
    enabledTriggerCount?: number;
    /**
     * The status of the configured integration. * enabled - The integration is enabled. * disabled - The integration is disabled. No notifications will be sent. * failing - The integration is failing. If it continues to fail over a period of time it will become failed. * failed - The integration is failed. No notifications will be sent. An integration can be enabled again by performing a successful [/configured_integrations/test](/#reference/integrations/configured-integrations).
     * @type {string}
     * @memberof InlineResponse20012
     */
    status?: InlineResponse20012.StatusEnum;
    /**
     * A label for use in identifying the issue tracker.
     * @type {string}
     * @memberof InlineResponse20012
     */
    label?: string;
}

/**
 * @export
 * @namespace InlineResponse20012
 */
export namespace InlineResponse20012 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Enabled = <any>'enabled',
        Disabled = <any>'disabled',
        Failing = <any>'failing',
        Failed = <any>'failed'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * The ID of the integration connection
     * @type {string}
     * @memberof InlineResponse20013
     */
    id?: string;
    /**
     * The ID of the organization that the integration connection belongs to
     * @type {string}
     * @memberof InlineResponse20013
     */
    organizationId?: string;
    /**
     * An identifier to communicate with external service
     * @type {string}
     * @memberof InlineResponse20013
     */
    externalIdentifier?: string;
    /**
     * The external software to communicate with. Currently this can only be 'jira'
     * @type {string}
     * @memberof InlineResponse20013
     */
    type?: string;
    /**
     * The type of configuration. Can be manual or app, but only manual can be updated through the Bugsnag API
     * @type {string}
     * @memberof InlineResponse20013
     */
    configurationType?: string;
    /**
     *
     * @type {OrganizationsorganizationIdintegrationConnectionsConfiguration}
     * @memberof InlineResponse20013
     */
    configuration?: OrganizationsorganizationIdintegrationConnectionsConfiguration;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014
     */
    name: string;
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse20014
     */
    billingEmails?: Array<string>;
    /**
     * whether we should upgrade your plan in response to the organization reaching its plan limit of events. If this value is `false` your events will be throttled when you reach your plan limit.
     * @type {boolean}
     * @memberof InlineResponse20014
     */
    autoUpgrade: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014
     */
    slug: string;
    /**
     * The notifier API used to send traces to this organization.
     * @type {string}
     * @memberof InlineResponse20014
     */
    apiKey?: string;
    /**
     *
     * @type {InlineResponse20014Creator}
     * @memberof InlineResponse20014
     */
    creator?: InlineResponse20014Creator;
    /**
     * API URL for the Organization's Collaborators.
     * @type {string}
     * @memberof InlineResponse20014
     */
    collaboratorsUrl?: string;
    /**
     * API URL for the Organization's Projects.
     * @type {string}
     * @memberof InlineResponse20014
     */
    projectsUrl?: string;
    /**
     *
     * @type {Date}
     * @memberof InlineResponse20014
     */
    createdAt: Date;
    /**
     *
     * @type {Date}
     * @memberof InlineResponse20014
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014
     */
    upgradeUrl?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20014Creator
 */
export interface InlineResponse20014Creator {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014Creator
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014Creator
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20014Creator
     */
    name?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20015
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20015
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20015
     */
    email: string;
    /**
     * Not applicable if the user is managed by SmartBear ID.
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    twoFactorEnabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20015
     */
    twoFactorEnabledOn?: string;
    /**
     * The number of two factor recovery codes the User has left.
     * @type {number}
     * @memberof InlineResponse20015
     */
    recoveryCodesRemaining?: number;
    /**
     * The time the User's password was last changed.
     * @type {string}
     * @memberof InlineResponse20015
     */
    passwordUpdatedOn?: string;
    /**
     * Whether the user has opted to have times displayed in UTC instead of local time.
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    showTimeInUtc: boolean;
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    heroku: boolean;
    /**
     * when the user was created
     * @type {string}
     * @memberof InlineResponse20015
     */
    createdAt: string;
    /**
     * Whether the collaborator has admin permissions for the current organization
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    isAdmin: boolean;
    /**
     * True if the user has not yet accepted their Bugsnag invitation.
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    pendingInvitation: boolean;
    /**
     * The last time the user interacted with the Bugsnag dashboard or related APIs. Null if the user has not interacted with the dashboard before.
     * @type {string}
     * @memberof InlineResponse20015
     */
    lastRequestAt?: string;
    /**
     * Deprecated field that returns the ids of all projects the user has access to within the current organization. Consider using `project_roles` instead.
     * @type {Array<string>}
     * @memberof InlineResponse20015
     */
    projectIds: Array<string>;
    /**
     * Whether the user has Bugsnag dashboard access under the organization's current plan. If this is false for a collaborator, they will see a \"locked out\" message when they attempt to log in to the Bugsnag dashboard. An admin for your organization can resolve this by upgrading the organization's Bugsnag plan.
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    paidFor: boolean;
    /**
     *
     * @type {OrganizationsorganizationIdcollaboratorsProjectRoles}
     * @memberof InlineResponse20015
     */
    projectRoles: OrganizationsorganizationIdcollaboratorsProjectRoles;
    /**
     * Whether the user is managed by SmartBear ID.
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    managedBySmartbearId: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20016
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20016
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20016
     */
    email: string;
    /**
     * Not applicable if the user is managed by SmartBear ID.
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    twoFactorEnabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20016
     */
    twoFactorEnabledOn?: string;
    /**
     * The number of two factor recovery codes the User has left.
     * @type {number}
     * @memberof InlineResponse20016
     */
    recoveryCodesRemaining?: number;
    /**
     * The time the User's password was last changed.
     * @type {string}
     * @memberof InlineResponse20016
     */
    passwordUpdatedOn?: string;
    /**
     * Whether the user has opted to have times displayed in UTC instead of local time.
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    showTimeInUtc: boolean;
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    heroku: boolean;
    /**
     * when the user was created
     * @type {string}
     * @memberof InlineResponse20016
     */
    createdAt: string;
    /**
     * Whether the collaborator has admin permissions for the current organization
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    isAdmin: boolean;
    /**
     * True if the user has not yet accepted their Bugsnag invitation.
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    pendingInvitation: boolean;
    /**
     * The last time the user interacted with the Bugsnag dashboard or related APIs. Null if the user has not interacted with the dashboard before.
     * @type {string}
     * @memberof InlineResponse20016
     */
    lastRequestAt?: string;
    /**
     * Deprecated field that returns the ids of all projects the user has access to within the current organization. Consider using `project_roles` instead.
     * @type {Array<string>}
     * @memberof InlineResponse20016
     */
    projectIds: Array<string>;
    /**
     * Whether the user has Bugsnag dashboard access under the organization's current plan. If this is false for a collaborator, they will see a \"locked out\" message when they attempt to log in to the Bugsnag dashboard. An admin for your organization can resolve this by upgrading the organization's Bugsnag plan.
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    paidFor: boolean;
    /**
     *
     * @type {OrganizationsorganizationIdcollaboratorsProjectRoles}
     * @memberof InlineResponse20016
     */
    projectRoles: OrganizationsorganizationIdcollaboratorsProjectRoles;
    /**
     * Whether the user is managed by SmartBear ID.
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    managedBySmartbearId: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20017
     */
    collaboratorId: string;
    /**
     * The number of projects the user has access to.
     * @type {number}
     * @memberof InlineResponse20017
     */
    projectCount: number;
    /**
     * Whether the collaborator is an admin on the account.
     * @type {boolean}
     * @memberof InlineResponse20017
     */
    isAdmin: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * Details of the teams with access to this project.
     * @type {Array<OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam>}
     * @memberof InlineResponse20018
     */
    team?: Array<OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam>;
    /**
     * Details of the collaborators with access to this project.
     * @type {Array<OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators>}
     * @memberof InlineResponse20018
     */
    collaborators?: Array<OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators>;
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     *
     * @type {InlineResponse20019ProjectSummary}
     * @memberof InlineResponse20019
     */
    projectSummary?: InlineResponse20019ProjectSummary;
    /**
     * The number of teams the collaborator belongs to that have access to the project.
     * @type {number}
     * @memberof InlineResponse20019
     */
    teamCount?: number;
    /**
     * Indicates if the collaborator is an administrator for the organization.
     * @type {boolean}
     * @memberof InlineResponse20019
     */
    isAdmin: boolean;
    /**
     * The overall role that the Collaborator has on the Project (based on the individual and Team roles). This will be the most permissive of the individual and Team roles. One of \"project_owner\", \"project_member\".
     * @type {string}
     * @memberof InlineResponse20019
     */
    projectRole?: string;
    /**
     * The role that the Collaborator has on the Project as an individual (ignoring any Team access). One of \"project_owner\", \"project_member\".
     * @type {string}
     * @memberof InlineResponse20019
     */
    individualProjectRole?: string;
    /**
     * The role that the Collaborator has on the Project from the Teams that they belong to. If the Collaborator belongs to multiple Teams this will be the most permissive role. One of \"project_owner\", \"project_member\"
     * @type {string}
     * @memberof InlineResponse20019
     */
    teamProjectRole?: string;
}
/**
 * Details of the project.
 * @export
 * @interface InlineResponse20019ProjectSummary
 */
export interface InlineResponse20019ProjectSummary {
    /**
     * The ID of the project.
     * @type {string}
     * @memberof InlineResponse20019ProjectSummary
     */
    id: string;
    /**
     * The name of the project.
     * @type {string}
     * @memberof InlineResponse20019ProjectSummary
     */
    name: string;
    /**
     * The type of the project.
     * @type {string}
     * @memberof InlineResponse20019ProjectSummary
     */
    type: string;
    /**
     * The project's slug.
     * @type {string}
     * @memberof InlineResponse20019ProjectSummary
     */
    slug: string;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2002
     */
    name?: string;
    /**
     * A list of error classes. Events with these classes will be grouped by their class, regardless of the location that they occur in the Project's source code. Altering a Project's `global_grouping` will not cause existing errors to be regrouped.  Note: In the UI this is referred to as grouping by error class.  Example:  ``` [\"foo\", \"bar\"] ```
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    globalGrouping?: Array<string>;
    /**
     * A list of error classes. Events with these classes will be grouped by their `context`. Altering a Project's `location_grouping` will not cause existing errors to be regrouped.  Note: In the UI this is referred to as grouping by error context.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    locationGrouping?: Array<string>;
    /**
     * A list of app versions whose events will be [discarded](https://docs.bugsnag.com/product/event-usage/#discard-by-app-version) if received for the Project. Supports [regular expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions) and [semver ranges](https://github.com/npm/node-semver#ranges). Errors matching these versions won't be processed by Bugsnag, and you won't receive notifications about them.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    discardedAppVersions?: Array<string>;
    /**
     * A list of Error classes whose events will be [discarded](https://docs.bugsnag.com/product/event-usage/#discard-by-error-class) if received for the Project. Errors with these classes won't be processed by Bugsnag, and you won't receive notifications about them.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    discardedErrors?: Array<string>;
    /**
     * When configured, the script source of each error's innermost stack trace's top frame is checked. If the script was not served from a matching domain the error will not be processed by BugSnag and will be discarded.  Provide a list of newline separated domain names. To match example.com and its subdomains specify *.example.com.  Relevant to JavaScript Projects only.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    urlWhitelist?: Array<string>;
    /**
     * Whether the Events in the Project will be ignored if they originate from old web browsers.  Relevant to JavaScript Projects only.
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    ignoreOldBrowsers?: boolean;
    /**
     * Relevant to JavaScript Projects only.  A mapping a of browser name to browser version. If set, Events in the Project will be ignored if they originate from a browser specified here whose version is earlier than the given version.  Keys must be one of the following strings: chrome, ie, firefox, safari, android, uc, opera, opera_mini, samsung, blackberry, sogou, other.  Values must be a number indicating which which version to ignore up to (but not including), or one of the strings: `ignore_all`, `ignore_none`  Example:  ``` { \"chrome\": \"ignore_none\", \"safari\": 6, \"other\": \"ignore_all\" } ```
     * @type {any}
     * @memberof InlineResponse2002
     */
    ignoredBrowserVersions?: any;
    /**
     * If true, every error in the Project will be marked as 'fixed' after using the Deploy Tracking API to notify Bugsnag of a new production deploy.  Applies to non-JavaScript Projects only.
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    resolveOnDeploy?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2002
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2002
     */
    organizationId?: string;
    /**
     * used for Projects that use a framework other than those listed above
     * @type {string}
     * @memberof InlineResponse2002
     */
    type?: InlineResponse2002.TypeEnum;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2002
     */
    performanceDisplayType?: InlineResponse2002.PerformanceDisplayTypeEnum;
    /**
     * unique, human-readable identifier that can be used in place of `id` in URLs
     * @type {string}
     * @memberof InlineResponse2002
     */
    slug?: string;
    /**
     * the notifier API key used to configure the [notifier library](https://docs.bugsnag.com/platforms/) being used to report errors in the project
     * @type {string}
     * @memberof InlineResponse2002
     */
    apiKey?: string;
    /**
     * Always true for this endpoint. Used to differentiate between terse and complete project representations.
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    isFullView?: boolean;
    /**
     * The release stages for which this project has received events. This will be an array of strings whose values will depend on your Project.
     * @type {Array<string>}
     * @memberof InlineResponse2002
     */
    releaseStages?: Array<string>;
    /**
     * The Project's programming language as derived from the framework represented in the `type` field
     * @type {string}
     * @memberof InlineResponse2002
     */
    language?: string;
    /**
     * The time of the Project's creation.
     * @type {string}
     * @memberof InlineResponse2002
     */
    createdAt?: string;
    /**
     * The time the Project was last modified.
     * @type {string}
     * @memberof InlineResponse2002
     */
    updatedAt?: string;
    /**
     * The API URL for the Project.
     * @type {string}
     * @memberof InlineResponse2002
     */
    url?: string;
    /**
     * The dashboard URL for the project.
     * @type {string}
     * @memberof InlineResponse2002
     */
    htmlUrl?: string;
    /**
     * The API URL for the Project's Errors.
     * @type {string}
     * @memberof InlineResponse2002
     */
    errorsUrl?: string;
    /**
     * The API URL for the Project's Events.
     * @type {string}
     * @memberof InlineResponse2002
     */
    eventsUrl?: string;
    /**
     * The number of open errors the Project has. Considers all events currently stored for the Project.
     * @type {number}
     * @memberof InlineResponse2002
     */
    openErrorCount?: number;
    /**
     * The number of errors for review the Project has. Considers all events currently stored for the Project.
     * @type {number}
     * @memberof InlineResponse2002
     */
    forReviewErrorCount?: number;
    /**
     * The number of collaborators with access to the Project.
     * @type {number}
     * @memberof InlineResponse2002
     */
    collaboratorsCount?: number;
    /**
     * The number of teams with access to the Project.
     * @type {number}
     * @memberof InlineResponse2002
     */
    teamsCount?: number;
    /**
     * The count of how many [Custom Filters](https://docs.bugsnag.com/product/custom-filters/) have been created for the Project.
     * @type {number}
     * @memberof InlineResponse2002
     */
    customEventFieldsUsed?: number;
    /**
     * The details of the ECMAScript version used to parse JavaScript events. Only present for Browser JavaScript Projects.
     * @type {any}
     * @memberof InlineResponse2002
     */
    ecmascriptParseVersion?: any;
}

/**
 * @export
 * @namespace InlineResponse2002
 */
export namespace InlineResponse2002 {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Android = <any>'android',
        Angular = <any>'angular',
        Asgi = <any>'asgi',
        Aspnet = <any>'aspnet',
        AspnetCore = <any>'aspnet_core',
        Backbone = <any>'backbone',
        Bottle = <any>'bottle',
        Cocos2dx = <any>'cocos2dx',
        Connect = <any>'connect',
        Django = <any>'django',
        Dotnet = <any>'dotnet',
        DotnetDesktop = <any>'dotnet_desktop',
        DotnetMvc = <any>'dotnet_mvc',
        Electron = <any>'electron',
        Ember = <any>'ember',
        Eventmachine = <any>'eventmachine',
        Expo = <any>'expo',
        Express = <any>'express',
        Flask = <any>'flask',
        Flutter = <any>'flutter',
        Gin = <any>'gin',
        Go = <any>'go',
        GoNetHttp = <any>'go_net_http',
        Heroku = <any>'heroku',
        Ios = <any>'ios',
        Java = <any>'java',
        JavaDesktop = <any>'java_desktop',
        Js = <any>'js',
        Koa = <any>'koa',
        Laravel = <any>'laravel',
        Lumen = <any>'lumen',
        Magento = <any>'magento',
        Martini = <any>'martini',
        Minidump = <any>'minidump',
        Ndk = <any>'ndk',
        Negroni = <any>'negroni',
        NintendoSwitch = <any>'nintendo_switch',
        Node = <any>'node',
        Osx = <any>'osx',
        OtherDesktop = <any>'other_desktop',
        OtherMobile = <any>'other_mobile',
        OtherTv = <any>'other_tv',
        Php = <any>'php',
        Python = <any>'python',
        Rack = <any>'rack',
        Rails = <any>'rails',
        React = <any>'react',
        Reactnative = <any>'reactnative',
        Restify = <any>'restify',
        Revel = <any>'revel',
        Ruby = <any>'ruby',
        Silex = <any>'silex',
        Sinatra = <any>'sinatra',
        Spring = <any>'spring',
        Symfony = <any>'symfony',
        Tornado = <any>'tornado',
        Tvos = <any>'tvos',
        Unity = <any>'unity',
        Unrealengine = <any>'unrealengine',
        Vue = <any>'vue',
        Watchos = <any>'watchos',
        Webapi = <any>'webapi',
        Wordpress = <any>'wordpress',
        Wpf = <any>'wpf',
        Wsgi = <any>'wsgi',
        Other = <any>'other'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PerformanceDisplayTypeEnum {
        Js = <any>'js',
        Mobile = <any>'mobile',
        Server = <any>'server',
        WebserverBackend = <any>'webserver_backend',
        WebserverFrontend = <any>'webserver_frontend',
        WebserverMixed = <any>'webserver_mixed',
        Unsupported = <any>'unsupported'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20020
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20020
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof InlineResponse20020
     */
    collaboratorCount: number;
    /**
     *
     * @type {number}
     * @memberof InlineResponse20020
     */
    projectCount: number;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * The ID of the collaborator
     * @type {string}
     * @memberof InlineResponse20021
     */
    id: string;
    /**
     * The name of the collaborator
     * @type {string}
     * @memberof InlineResponse20021
     */
    name: string;
    /**
     * The email of the collaborator
     * @type {string}
     * @memberof InlineResponse20021
     */
    email: string;
    /**
     * Whether the user has access to the team already
     * @type {boolean}
     * @memberof InlineResponse20021
     */
    hasAccess: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20022
     */
    projectId: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20022
     */
    projectName: string;
    /**
     * Is the collaborator already a member?
     * @type {boolean}
     * @memberof InlineResponse20022
     */
    isMember: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     *
     * @type {OrganizationsorganizationIdteamsidprojectAccessesProjectSummary}
     * @memberof InlineResponse20023
     */
    projectSummary: OrganizationsorganizationIdteamsidprojectAccessesProjectSummary;
    /**
     * The role the user has on the project
     * @type {string}
     * @memberof InlineResponse20023
     */
    projectRole: InlineResponse20023.ProjectRoleEnum;
}

/**
 * @export
 * @namespace InlineResponse20023
 */
export namespace InlineResponse20023 {
    /**
     * @export
     * @enum {string}
     */
    export enum ProjectRoleEnum {
        Owner = <any>'project_owner',
        Member = <any>'project_member'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20024
     */
    projectId: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20024
     */
    projectName: string;
    /**
     * The project type
     * @type {string}
     * @memberof InlineResponse20024
     */
    type: string;
    /**
     * Does the team already have access?
     * @type {boolean}
     * @memberof InlineResponse20024
     */
    hasAccess: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * the pagination offset, 1-indexed, defaults to 1
     * @type {number}
     * @memberof InlineResponse20025
     */
    startIndex: number;
    /**
     * the number of results returned in this response
     * @type {number}
     * @memberof InlineResponse20025
     */
    itemsPerPage: number;
    /**
     * the total number of users matching the query
     * @type {number}
     * @memberof InlineResponse20025
     */
    totalResults: number;
    /**
     * the users of the organisation
     * @type {Array<UsersIdBody>}
     * @memberof InlineResponse20025
     */
    resources: Array<UsersIdBody>;
}
/**
 *
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20026
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20026
     */
    userName: string;
    /**
     *
     * @type {OrganizationsorganizationIdscimv2UsersidName}
     * @memberof InlineResponse20026
     */
    name: OrganizationsorganizationIdscimv2UsersidName;
    /**
     *
     * @type {Array<OrganizationsorganizationIdscimv2UsersidEmails>}
     * @memberof InlineResponse20026
     */
    emails: Array<OrganizationsorganizationIdscimv2UsersidEmails>;
    /**
     * Whether the user is part of the organization.
     * @type {boolean}
     * @memberof InlineResponse20026
     */
    active?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * the total number of groups matching the query
     * @type {number}
     * @memberof InlineResponse20027
     */
    totalResults: number;
    /**
     * the SCIM groups of the organization
     * @type {Array<InlineResponse20027Resources>}
     * @memberof InlineResponse20027
     */
    resources: Array<InlineResponse20027Resources>;
}
/**
 *
 * @export
 * @interface InlineResponse20027Resources
 */
export interface InlineResponse20027Resources {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20027Resources
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20027Resources
     */
    displayName: string;
    /**
     * the collaborators in a group
     * @type {Array<InlineResponse20028Members>}
     * @memberof InlineResponse20027Resources
     */
    members: Array<InlineResponse20028Members>;
}
/**
 *
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20028
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20028
     */
    displayName: string;
    /**
     * the collaborators in a group
     * @type {Array<InlineResponse20028Members>}
     * @memberof InlineResponse20028
     */
    members: Array<InlineResponse20028Members>;
}
/**
 *
 * @export
 * @interface InlineResponse20028Members
 */
export interface InlineResponse20028Members {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20028Members
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse20028Members
     */
    display: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * The ID of the span
     * @type {string}
     * @memberof InlineResponse20029
     */
    id: string;
    /**
     * The ID of the parent span if applicable
     * @type {string}
     * @memberof InlineResponse20029
     */
    parentSpanId?: string;
    /**
     * The ID of the trace
     * @type {string}
     * @memberof InlineResponse20029
     */
    traceId: string;
    /**
     * The category of the span
     * @type {string}
     * @memberof InlineResponse20029
     */
    category: string;
    /**
     * The name of the span
     * @type {string}
     * @memberof InlineResponse20029
     */
    name: string;
    /**
     * The name of the span for display purposes
     * @type {string}
     * @memberof InlineResponse20029
     */
    displayName: string;
    /**
     * The duration of the span in milliseconds
     * @type {number}
     * @memberof InlineResponse20029
     */
    duration: number;
    /**
     * The timestamp we've attributed to the Span
     * @type {string}
     * @memberof InlineResponse20029
     */
    timestamp: string;
    /**
     * How the time was adjusted
     * @type {string}
     * @memberof InlineResponse20029
     */
    timeAdjustmentType: InlineResponse20029.TimeAdjustmentTypeEnum;
    /**
     * The time the span started
     * @type {string}
     * @memberof InlineResponse20029
     */
    startTime: string;
    /**
     * Whether the span is first class or just a sub-span
     * @type {boolean}
     * @memberof InlineResponse20029
     */
    isFirstClass: boolean;
    /**
     * The ID of the build that this span is associated with
     * @type {string}
     * @memberof InlineResponse20029
     */
    buildId?: string;
    /**
     * The ID of the project that this span is associated with
     * @type {string}
     * @memberof InlineResponse20029
     */
    projectId?: string;
    /**
     * The id of the span group if applicable
     * @type {string}
     * @memberof InlineResponse20029
     */
    spanGroupId?: string;
    /**
     * The raw id of the page load span group if applicable
     * @type {string}
     * @memberof InlineResponse20029
     */
    virtualSpanGroupId?: string;
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatistics}
     * @memberof InlineResponse20029
     */
    statistics?: OrganizationsorganizationIdtracestraceIdspansStatistics;
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansMetadata}
     * @memberof InlineResponse20029
     */
    metadata?: OrganizationsorganizationIdtracestraceIdspansMetadata;
}

/**
 * @export
 * @namespace InlineResponse20029
 */
export namespace InlineResponse20029 {
    /**
     * @export
     * @enum {string}
     */
    export enum TimeAdjustmentTypeEnum {
        Adjusted = <any>'adjusted',
        Device = <any>'device',
        Received = <any>'received',
        Unadjusted = <any>'unadjusted'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2003
     */
    operation?: InlineResponse2003.OperationEnum;
    /**
     *
     * @type {InlineResponse2003515fb9337c1074f6fd000001}
     * @memberof InlineResponse2003
     */
    _515fb9337c1074f6fd000001?: InlineResponse2003515fb9337c1074f6fd000001;
}

/**
 * @export
 * @namespace InlineResponse2003
 */
export namespace InlineResponse2003 {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        OverridenSeverity = <any>'overriden_severity',
        Assign = <any>'assign',
        CreateIssue = <any>'create_issue',
        LinkIssue = <any>'link_issue',
        UnlinkIssue = <any>'unlink_issue',
        Open = <any>'open',
        Snooze = <any>'snooze',
        Fix = <any>'fix',
        Ignore = <any>'ignore',
        Delete = <any>'delete',
        Discard = <any>'discard'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * Whether the field is a custom event field created by your organization
     * @type {boolean}
     * @memberof InlineResponse20030
     */
    custom?: boolean;
    /**
     * Identifier which is the key to use for filtering by this field
     * @type {string}
     * @memberof InlineResponse20030
     */
    displayId?: string;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsFilterOptions}
     * @memberof InlineResponse20030
     */
    filterOptions: ProjectsprojectIdeventFieldsFilterOptions;
    /**
     * Possible values for this filter, only if this filter has a finite set of values
     * @type {Array<ProjectsprojectIdeventFieldsValues>}
     * @memberof InlineResponse20030
     */
    values?: Array<ProjectsprojectIdeventFieldsValues>;
    /**
     * The valid match types when filtering by this field   - eq - Results must equal the value   - ne - Results must not equal the value
     * @type {Array<string>}
     * @memberof InlineResponse20030
     */
    matchTypes?: Array<InlineResponse20030.MatchTypesEnum>;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsPivotOptions}
     * @memberof InlineResponse20030
     */
    pivotOptions: ProjectsprojectIdeventFieldsPivotOptions;
    /**
     * Whether a reindex of this field is currently in progress (applicable to custom fields only)
     * @type {boolean}
     * @memberof InlineResponse20030
     */
    reindexInProgress?: boolean;
    /**
     * The percentage complete of the reindexing of this field (applicable to custom fields only)
     * @type {number}
     * @memberof InlineResponse20030
     */
    reindexPercentage?: number;
}

/**
 * @export
 * @namespace InlineResponse20030
 */
export namespace InlineResponse20030 {
    /**
     * @export
     * @enum {string}
     */
    export enum MatchTypesEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * ID of release group
     * @type {string}
     * @memberof InlineResponse20031
     */
    id: string;
    /**
     * ID of project that this release group belongs to
     * @type {string}
     * @memberof InlineResponse20031
     */
    projectId: string;
    /**
     * name of the release stage for this release group
     * @type {string}
     * @memberof InlineResponse20031
     */
    releaseStageName: string;
    /**
     * version string for this release group
     * @type {string}
     * @memberof InlineResponse20031
     */
    appVersion: string;
    /**
     * when the first release of this release group was released
     * @type {string}
     * @memberof InlineResponse20031
     */
    firstReleasedAt: string;
    /**
     * ID of first release of this release group
     * @type {string}
     * @memberof InlineResponse20031
     */
    firstReleaseId: string;
    /**
     * Number of releases that belong to this release group. This will be 1 for releases that don't use secondary versions.
     * @type {number}
     * @memberof InlineResponse20031
     */
    releasesCount: number;
    /**
     * Whether the releases in this release group use secondary versions (version code or bundle version). This is usually true for mobile projects and false for non-mobile projects.
     * @type {boolean}
     * @memberof InlineResponse20031
     */
    hasSecondaryVersions: boolean;
    /**
     * tool used to report the first release of this release group
     * @type {string}
     * @memberof InlineResponse20031
     */
    buildTool?: string;
    /**
     * name of person or system that triggered the first release/build of this release group
     * @type {string}
     * @memberof InlineResponse20031
     */
    builderName?: string;
    /**
     *
     * @type {ProjectsprojectIdreleaseGroupsSourceControl}
     * @memberof InlineResponse20031
     */
    sourceControl?: ProjectsprojectIdreleaseGroupsSourceControl;
    /**
     * total number of sessions seen for this release group. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20031
     */
    totalSessionsCount: number;
    /**
     * number of sessions in this release group that had at least one unhandled event. Session Stability can be computed with (1 - (unhandled_sessions_count / total_sessions_count)) * 100. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20031
     */
    unhandledSessionsCount?: number;
    /**
     * number of sessions seen in the last 24 hours for this release group. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20031
     */
    sessionsCountInLast24h?: number;
    /**
     * number of user with at least one session in this release group. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20031
     */
    accumulativeDailyUsersSeen?: number;
    /**
     * number of user sessions with at least one unhandled event. User Stability can be computed with (1 - (accumulative_daily_users_with_unhandled / accumulative_daily_users_seen)) * 100. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20031
     */
    accumulativeDailyUsersWithUnhandled?: number;
    /**
     * whether this release group is a top release
     * @type {boolean}
     * @memberof InlineResponse20031
     */
    topReleaseGroup: boolean;
    /**
     * whether this release group is visible
     * @type {boolean}
     * @memberof InlineResponse20031
     */
    visible: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * ID of release group
     * @type {string}
     * @memberof InlineResponse20032
     */
    id: string;
    /**
     * ID of project that this release group belongs to
     * @type {string}
     * @memberof InlineResponse20032
     */
    projectId: string;
    /**
     * name of the release stage for this release group
     * @type {string}
     * @memberof InlineResponse20032
     */
    releaseStageName: string;
    /**
     * version string for this release group
     * @type {string}
     * @memberof InlineResponse20032
     */
    appVersion: string;
    /**
     * when the first release of this release group was released
     * @type {string}
     * @memberof InlineResponse20032
     */
    firstReleasedAt: string;
    /**
     * ID of first release of this release group
     * @type {string}
     * @memberof InlineResponse20032
     */
    firstReleaseId: string;
    /**
     * Number of releases that belong to this release group. This will be 1 for releases that don't use secondary versions.
     * @type {number}
     * @memberof InlineResponse20032
     */
    releasesCount: number;
    /**
     * Whether the releases in this release group use secondary versions (version code or bundle version). This is usually true for mobile projects and false for non-mobile projects.
     * @type {boolean}
     * @memberof InlineResponse20032
     */
    hasSecondaryVersions: boolean;
    /**
     * tool used to report the first release of this release group
     * @type {string}
     * @memberof InlineResponse20032
     */
    buildTool?: string;
    /**
     * name of person or system that triggered the first release/build of this release group
     * @type {string}
     * @memberof InlineResponse20032
     */
    builderName?: string;
    /**
     *
     * @type {ProjectsprojectIdreleaseGroupsSourceControl}
     * @memberof InlineResponse20032
     */
    sourceControl?: ProjectsprojectIdreleaseGroupsSourceControl;
    /**
     * total number of sessions seen for this release group. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20032
     */
    totalSessionsCount: number;
    /**
     * number of sessions in this release group that had at least one unhandled event. Session Stability can be computed with (1 - (unhandled_sessions_count / total_sessions_count)) * 100. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20032
     */
    unhandledSessionsCount?: number;
    /**
     * number of sessions seen in the last 24 hours for this release group. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20032
     */
    sessionsCountInLast24h?: number;
    /**
     * number of user with at least one session in this release group. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20032
     */
    accumulativeDailyUsersSeen?: number;
    /**
     * number of user sessions with at least one unhandled event. User Stability can be computed with (1 - (accumulative_daily_users_with_unhandled / accumulative_daily_users_seen)) * 100. This field will be returned if the current Plan supports stability monitoring.
     * @type {number}
     * @memberof InlineResponse20032
     */
    accumulativeDailyUsersWithUnhandled?: number;
    /**
     * whether this release group is a top release
     * @type {boolean}
     * @memberof InlineResponse20032
     */
    topReleaseGroup: boolean;
    /**
     * whether this release group is visible
     * @type {boolean}
     * @memberof InlineResponse20032
     */
    visible: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * ID of the release
     * @type {string}
     * @memberof InlineResponse20033
     */
    id?: string;
    /**
     * ID of project this release belongs to
     * @type {string}
     * @memberof InlineResponse20033
     */
    projectId?: string;
    /**
     * when the release happened (in ISO 8601 format)
     * @type {string}
     * @memberof InlineResponse20033
     */
    releaseTime?: string;
    /**
     * what was responsible for creating the release
     * @type {string}
     * @memberof InlineResponse20033
     */
    releaseSource?: InlineResponse20033.ReleaseSourceEnum;
    /**
     * version name/number
     * @type {string}
     * @memberof InlineResponse20033
     */
    appVersion?: string;
    /**
     * version code of release (applicable to Android)
     * @type {string}
     * @memberof InlineResponse20033
     */
    appVersionCode?: string;
    /**
     * bundle version/build number of release (applicable to iOS/macOS/tvOS)
     * @type {string}
     * @memberof InlineResponse20033
     */
    appBundleVersion?: string;
    /**
     * auto-generated descriptive label describing the build
     * @type {string}
     * @memberof InlineResponse20033
     */
    buildLabel?: string;
    /**
     * name of person or system that triggered the release/build
     * @type {string}
     * @memberof InlineResponse20033
     */
    builderName?: string;
    /**
     * tool used to report this release
     * @type {string}
     * @memberof InlineResponse20033
     */
    buildTool?: string;
    /**
     * number of errors introduced in this release
     * @type {number}
     * @memberof InlineResponse20033
     */
    errorsIntroducedCount?: number;
    /**
     * number of errors that happened in this release
     * @type {number}
     * @memberof InlineResponse20033
     */
    errorsSeenCount?: number;
    /**
     * number of sessions started for this release in the last 24 hours
     * @type {number}
     * @memberof InlineResponse20033
     */
    sessionsCountInLast24h?: number;
    /**
     * number of sessions that started in this release
     * @type {number}
     * @memberof InlineResponse20033
     */
    totalSessionsCount?: number;
    /**
     * number of sessions in this release that have seen at least one unhandled event. Session Stability can be computed with (1 - (unhandled_sessions_count / total_sessions_count)) * 100
     * @type {number}
     * @memberof InlineResponse20033
     */
    unhandledSessionsCount?: number;
    /**
     * number of user with at least one session in this release group
     * @type {number}
     * @memberof InlineResponse20033
     */
    accumulativeDailyUsersSeen?: number;
    /**
     * number of user sessions with at least one unhandled event. User Stability can be computed with (1 - (accumulative_daily_users_with_unhandled / accumulative_daily_users_seen)) * 100
     * @type {number}
     * @memberof InlineResponse20033
     */
    accumulativeDailyUsersWithUnhandled?: number;
    /**
     * metadata about the release
     * @type {any}
     * @memberof InlineResponse20033
     */
    metadata?: any;
    /**
     *
     * @type {ProjectsprojectIdreleasesReleaseStage}
     * @memberof InlineResponse20033
     */
    releaseStage?: ProjectsprojectIdreleasesReleaseStage;
    /**
     *
     * @type {ProjectsprojectIdreleasesSourceControl}
     * @memberof InlineResponse20033
     */
    sourceControl?: ProjectsprojectIdreleasesSourceControl;
    /**
     * ID of release group that this release belongs to
     * @type {string}
     * @memberof InlineResponse20033
     */
    releaseGroupId?: string;
}

/**
 * @export
 * @namespace InlineResponse20033
 */
export namespace InlineResponse20033 {
    /**
     * @export
     * @enum {string}
     */
    export enum ReleaseSourceEnum {
        UnknownSource = <any>'unknown_source',
        Event = <any>'event',
        Session = <any>'session',
        Api = <any>'api',
        Deploy = <any>'deploy',
        Error = <any>'error',
        ErrorIncompleteBuild = <any>'error_incomplete_build'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * ID of the release
     * @type {string}
     * @memberof InlineResponse20034
     */
    id?: string;
    /**
     * ID of project this release belongs to
     * @type {string}
     * @memberof InlineResponse20034
     */
    projectId?: string;
    /**
     * when the release happened (in ISO 8601 format)
     * @type {string}
     * @memberof InlineResponse20034
     */
    releaseTime?: string;
    /**
     * what was responsible for creating the release
     * @type {string}
     * @memberof InlineResponse20034
     */
    releaseSource?: InlineResponse20034.ReleaseSourceEnum;
    /**
     * version name/number
     * @type {string}
     * @memberof InlineResponse20034
     */
    appVersion?: string;
    /**
     * version code of release (applicable to Android)
     * @type {string}
     * @memberof InlineResponse20034
     */
    appVersionCode?: string;
    /**
     * bundle version/build number of release (applicable to iOS/macOS/tvOS)
     * @type {string}
     * @memberof InlineResponse20034
     */
    appBundleVersion?: string;
    /**
     * auto-generated descriptive label describing the build
     * @type {string}
     * @memberof InlineResponse20034
     */
    buildLabel?: string;
    /**
     * name of person or system that triggered the release/build
     * @type {string}
     * @memberof InlineResponse20034
     */
    builderName?: string;
    /**
     * tool used to report this release
     * @type {string}
     * @memberof InlineResponse20034
     */
    buildTool?: string;
    /**
     * number of errors introduced in this release
     * @type {number}
     * @memberof InlineResponse20034
     */
    errorsIntroducedCount?: number;
    /**
     * number of errors that happened in this release
     * @type {number}
     * @memberof InlineResponse20034
     */
    errorsSeenCount?: number;
    /**
     * number of sessions started for this release in the last 24 hours
     * @type {number}
     * @memberof InlineResponse20034
     */
    sessionsCountInLast24h?: number;
    /**
     * number of sessions that started in this release
     * @type {number}
     * @memberof InlineResponse20034
     */
    totalSessionsCount?: number;
    /**
     * number of sessions in this release that have seen at least one unhandled event. Session Stability can be computed with (1 - (unhandled_sessions_count / total_sessions_count)) * 100
     * @type {number}
     * @memberof InlineResponse20034
     */
    unhandledSessionsCount?: number;
    /**
     * number of user with at least one session in this release group
     * @type {number}
     * @memberof InlineResponse20034
     */
    accumulativeDailyUsersSeen?: number;
    /**
     * number of user sessions with at least one unhandled event. User Stability can be computed with (1 - (accumulative_daily_users_with_unhandled / accumulative_daily_users_seen)) * 100
     * @type {number}
     * @memberof InlineResponse20034
     */
    accumulativeDailyUsersWithUnhandled?: number;
    /**
     * metadata about the release
     * @type {any}
     * @memberof InlineResponse20034
     */
    metadata?: any;
    /**
     *
     * @type {ProjectsprojectIdreleasesReleaseStage}
     * @memberof InlineResponse20034
     */
    releaseStage?: ProjectsprojectIdreleasesReleaseStage;
    /**
     *
     * @type {ProjectsprojectIdreleasesSourceControl}
     * @memberof InlineResponse20034
     */
    sourceControl?: ProjectsprojectIdreleasesSourceControl;
    /**
     * ID of release group that this release belongs to
     * @type {string}
     * @memberof InlineResponse20034
     */
    releaseGroupId?: string;
}

/**
 * @export
 * @namespace InlineResponse20034
 */
export namespace InlineResponse20034 {
    /**
     * @export
     * @enum {string}
     */
    export enum ReleaseSourceEnum {
        UnknownSource = <any>'unknown_source',
        Event = <any>'event',
        Session = <any>'session',
        Api = <any>'api',
        Deploy = <any>'deploy',
        Error = <any>'error',
        ErrorIncompleteBuild = <any>'error_incomplete_build'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse20035
     */
    projectId?: string;
    /**
     * The name of the primary release stage for the given project.
     * @type {string}
     * @memberof InlineResponse20035
     */
    releaseStageName?: string;
    /**
     * Unhandled session information for each UTC day in the last 30 days.
     * @type {Array<InlineResponse20035TimelinePoints>}
     * @memberof InlineResponse20035
     */
    timelinePoints?: Array<InlineResponse20035TimelinePoints>;
}
/**
 *
 * @export
 * @interface InlineResponse2003515fb9337c1074f6fd000001
 */
export interface InlineResponse2003515fb9337c1074f6fd000001 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    assignedCollaboratorId?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    assignedTeamId?: string;
    /**
     *
     * @type {Array<InlineResponse2003515fb9337c1074f6fd000001LinkedIssues>}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    linkedIssues?: Array<InlineResponse2003515fb9337c1074f6fd000001LinkedIssues>;
    /**
     *
     * @type {InlineResponse2003515fb9337c1074f6fd000001LinkedIssues}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    createdIssue?: InlineResponse2003515fb9337c1074f6fd000001LinkedIssues;
    /**
     *
     * @type {InlineResponse2003515fb9337c1074f6fd000001ReopenRules}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    reopenRules?: InlineResponse2003515fb9337c1074f6fd000001ReopenRules;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    status?: InlineResponse2003515fb9337c1074f6fd000001.StatusEnum;
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001
     */
    discarded?: boolean;
}

/**
 * @export
 * @namespace InlineResponse2003515fb9337c1074f6fd000001
 */
export namespace InlineResponse2003515fb9337c1074f6fd000001 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Open = <any>'open',
        InProgress = <any>'in progress',
        ForReview = <any>'for_review',
        Fixed = <any>'fixed',
        Snoozed = <any>'snoozed',
        Ignored = <any>'ignored'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2003515fb9337c1074f6fd000001LinkedIssues
 */
export interface InlineResponse2003515fb9337c1074f6fd000001LinkedIssues {
    /**
     * The immutable issue id.
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001LinkedIssues
     */
    id: string;
    /**
     * The issue key (if applicable). For example, in the case of a Jira story, this will be the mutable key (e.g. ENG-10)
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001LinkedIssues
     */
    key?: string;
    /**
     * The issue number (if applicable). For example, in the case of a github issue with the url `https://github.com/foo/bar/issues/123` this field will be set to `123`.
     * @type {number}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001LinkedIssues
     */
    number?: number;
    /**
     * An identifier for the 3rd party service
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001LinkedIssues
     */
    type: string;
    /**
     * The url to the issue on the 3rd party service
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001LinkedIssues
     */
    url: string;
}
/**
 *
 * @export
 * @interface InlineResponse2003515fb9337c1074f6fd000001ReopenRules
 */
export interface InlineResponse2003515fb9337c1074f6fd000001ReopenRules {
    /**
     * Must be one of the following: - `n_additional_occurrences` - Indicates that the Error should be reopened after n more occurrences. In this case, the `occurrence_threshold` field indicates the number of total occurrences at which the Error should be reopened, and the `additional_occurrences` field indicates the number of additional occurrences that were allowed before reopening. - `n_occurrences_in_m_hours` - Indicates that the Error should be reopened after n occurrences over some configurable number of hours. In this case, the `occurrences` and `hours` fields will both be present. - `occurs_after` - Indicates that the error should be reopened if there are any occurrences after the specified time period. The `seconds` field contains the number of seconds that the Error has been snoozed for. In this case, the `seconds` and `reopen_after` fields will both be present.
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    reopenIf: InlineResponse2003515fb9337c1074f6fd000001ReopenRules.ReopenIfEnum;
    /**
     * for `occurs_after` reopen rules, this field indicates the time after which the Error should be reopened if there is an additional occurrence.
     * @type {string}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    reopenAfter?: string;
    /**
     * for `occurs_after` reopen rules, the number of seconds that the Error was set to snooze for.
     * @type {number}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    seconds?: number;
    /**
     * for `n_occurrences_in_m_hours` reopen rules, the number of occurrences to allow in the number of hours indicated by the `hours` field, before the Error is automatically reopened.
     * @type {number}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    occurrences?: number;
    /**
     * for `n_occurrences_in_m_hours` reopen rules, the number of hours.
     * @type {number}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    hours?: number;
    /**
     * for `n_additional_occurrences` reopen rules, the number of total occurrences at which the Error should be reopened.
     * @type {number}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    occurrenceThreshold?: number;
    /**
     * for `n_additional_occurrences` reopen rules, the number of additional occurrences allowed before reopening.
     * @type {number}
     * @memberof InlineResponse2003515fb9337c1074f6fd000001ReopenRules
     */
    additionalOccurrences?: number;
}

/**
 * @export
 * @namespace InlineResponse2003515fb9337c1074f6fd000001ReopenRules
 */
export namespace InlineResponse2003515fb9337c1074f6fd000001ReopenRules {
    /**
     * @export
     * @enum {string}
     */
    export enum ReopenIfEnum {
        NAdditionalOccurrences = <any>'n_additional_occurrences',
        NOccurrencesInMHours = <any>'n_occurrences_in_m_hours',
        OccursAfter = <any>'occurs_after'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20035TimelinePoints
 */
export interface InlineResponse20035TimelinePoints {
    /**
     * The timestamp marking the beginning of the range for the timeline point.
     * @type {string}
     * @memberof InlineResponse20035TimelinePoints
     */
    bucketStart?: string;
    /**
     * The timestamp marking the end of the range for the timeline point.
     * @type {string}
     * @memberof InlineResponse20035TimelinePoints
     */
    bucketEnd?: string;
    /**
     * The total number of sessions that occurred within the time range.
     * @type {number}
     * @memberof InlineResponse20035TimelinePoints
     */
    totalSessionsCount?: number;
    /**
     * The number of unhandled sessions seen in the time range.
     * @type {number}
     * @memberof InlineResponse20035TimelinePoints
     */
    unhandledSessionsCount?: number;
    /**
     * The total number of users sessions that occurred within the time range.
     * @type {number}
     * @memberof InlineResponse20035TimelinePoints
     */
    usersSeen?: number;
    /**
     * The number of users experiencing an unhandled session seen in the time range.
     * @type {number}
     * @memberof InlineResponse20035TimelinePoints
     */
    usersWithUnhandled?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * The ID of the feature flag.
     * @type {string}
     * @memberof InlineResponse20036
     */
    id: string;
    /**
     * The name of the feature flag.
     * @type {string}
     * @memberof InlineResponse20036
     */
    name: string;
    /**
     * The date and time that the feature flag was first seen in the requested release stage (regardless of retention).
     * @type {string}
     * @memberof InlineResponse20036
     */
    firstSeen: string;
    /**
     * Whether the feature flag is starred for the current user.
     * @type {boolean}
     * @memberof InlineResponse20036
     */
    isStarred: boolean;
    /**
     * Whether the feature flag is one that has been seen in events in the requested release stage in the last 7 days.
     * @type {boolean}
     * @memberof InlineResponse20036
     */
    isActive: boolean;
    /**
     *
     * @type {ProjectsprojectIdfeatureFlagsVariantSummary}
     * @memberof InlineResponse20036
     */
    variantSummary?: ProjectsprojectIdfeatureFlagsVariantSummary;
}
/**
 *
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * The ID of the feature flag.
     * @type {string}
     * @memberof InlineResponse20037
     */
    id: string;
    /**
     * The name of the feature flag.
     * @type {string}
     * @memberof InlineResponse20037
     */
    name: string;
}
/**
 *
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * The ID of the feature flag.
     * @type {string}
     * @memberof InlineResponse20038
     */
    id: string;
    /**
     * The name of the feature flag.
     * @type {string}
     * @memberof InlineResponse20038
     */
    name: string;
    /**
     * The date and time that the feature flag was first seen in the requested release stage (regardless of retention).
     * @type {string}
     * @memberof InlineResponse20038
     */
    firstSeen: string;
    /**
     * Whether the feature flag is starred for the current user.
     * @type {boolean}
     * @memberof InlineResponse20038
     */
    isStarred: boolean;
    /**
     * Whether the feature flag is one that has been seen in events in the requested release stage in the last 7 days.
     * @type {boolean}
     * @memberof InlineResponse20038
     */
    isActive: boolean;
    /**
     *
     * @type {ProjectsprojectIdfeatureFlagsVariantSummary}
     * @memberof InlineResponse20038
     */
    variantSummary?: ProjectsprojectIdfeatureFlagsVariantSummary;
}
/**
 *
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * The number of errors seen on this feature flag.
     * @type {number}
     * @memberof InlineResponse20039
     */
    errorsSeen: number;
    /**
     * The number of errors exclusively seen on this feature flag.
     * @type {number}
     * @memberof InlineResponse20039
     */
    exclusiveErrors: number;
    /**
     * The last time an error was received on this feature flag.
     * @type {string}
     * @memberof InlineResponse20039
     */
    lastSeen: string;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * The severity of the Error
     * @type {string}
     * @memberof InlineResponse2004
     */
    severity?: InlineResponse2004.SeverityEnum;
    /**
     * Identifies the collaborator, if any, who has been assigned to the Error.
     * @type {string}
     * @memberof InlineResponse2004
     */
    assignedCollaboratorId?: string;
    /**
     * Identifies the team, if any, that has been assigned to the Error.
     * @type {string}
     * @memberof InlineResponse2004
     */
    assignedTeamId?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    projectId?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    url?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    projectUrl?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    errorClass?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2004
     */
    context?: string;
    /**
     * The Error's original severity. Present if the Error's default severity has been modified.
     * @type {string}
     * @memberof InlineResponse2004
     */
    originalSeverity?: InlineResponse2004.OriginalSeverityEnum;
    /**
     * The Error's updated severity. Present if the Error's default severity has been modified.
     * @type {string}
     * @memberof InlineResponse2004
     */
    overriddenSeverity?: InlineResponse2004.OverriddenSeverityEnum;
    /**
     * The number of occurrences of the Error. If the Error request includes filters, this will be a filtered count.
     * @type {number}
     * @memberof InlineResponse2004
     */
    events?: number;
    /**
     * The API URL for the Error's Events.
     * @type {string}
     * @memberof InlineResponse2004
     */
    eventsUrl?: string;
    /**
     * The absolute count of all received Events for the Error.
     * @type {number}
     * @memberof InlineResponse2004
     */
    unthrottledOccurrenceCount?: number;
    /**
     * The number of users affected by the Error. If the Error request includes filters, this will be a filtered count.
     * @type {number}
     * @memberof InlineResponse2004
     */
    users?: number;
    /**
     * The time of the first occurrence of the Error. This time will be within the bounds of any applied time Filters.
     * @type {string}
     * @memberof InlineResponse2004
     */
    firstSeen?: string;
    /**
     * The time of the last occurrence of the Error. This time will be within the bounds of any applied time Filters.
     * @type {string}
     * @memberof InlineResponse2004
     */
    lastSeen?: string;
    /**
     * The time of the first occurrence of this Error. This is an absolute time which may extend beyond the bounds of any applied time Filters.
     * @type {string}
     * @memberof InlineResponse2004
     */
    firstSeenUnfiltered?: string;
    /**
     * The time of the last occurrence of this Error. This is an absolute time which may extend beyond the bounds of any applied time Filters.
     * @type {string}
     * @memberof InlineResponse2004
     */
    lastSeenUnfiltered?: string;
    /**
     *
     * @type {InlineResponse2004ReopenRules}
     * @memberof InlineResponse2004
     */
    reopenRules?: InlineResponse2004ReopenRules;
    /**
     * The Error's work flow status.
     * @type {string}
     * @memberof InlineResponse2004
     */
    status?: InlineResponse2004.StatusEnum;
    /**
     * Issues linked to this error
     * @type {Array<InlineResponse2003515fb9337c1074f6fd000001LinkedIssues>}
     * @memberof InlineResponse2004
     */
    linkedIssues?: Array<InlineResponse2003515fb9337c1074f6fd000001LinkedIssues>;
    /**
     *
     * @type {InlineResponse2004CreatedIssue}
     * @memberof InlineResponse2004
     */
    createdIssue?: InlineResponse2004CreatedIssue;
    /**
     * The number of comments on the Error. This count does not consider time Filters.
     * @type {number}
     * @memberof InlineResponse2004
     */
    commentCount?: number;
    /**
     * An array of UUIDs for dSYMs that were not [uploaded](https://docs.bugsnag.com/platforms/ios/symbolication-guide/) but are required to symbolicate the Error. Applies to iOS, macOS, and tvOS projects.
     * @type {Array<string>}
     * @memberof InlineResponse2004
     */
    missingDsyms?: Array<string>;
    /**
     * The release stages where this Error has occurred.
     * @type {Array<string>}
     * @memberof InlineResponse2004
     */
    releaseStages?: Array<string>;
    /**
     * The reason that events were grouped into this error. - `frame-code` - same code location - `frame-inner` - top in-project stackframe - `context-inner` - context - `error_class-inner` - error class - `user_defined` - custom grouping hash - `js-blob` - from blobs (JS only) - `js-tag` - same inline script (JS only) - `js-html` - same page location (JS only) - `js-eval` - originate from eval statements (JS only) - `js-structure` - same point in the code using the structure of the surrounding minified code (JS only) - `js-codebase` - same point in the code using the surrounding minified code (JS only) - `js-location` - similar location (JS only)
     * @type {string}
     * @memberof InlineResponse2004
     */
    groupingReason?: InlineResponse2004.GroupingReasonEnum;
    /**
     * A map of the fields and their values that were used for the grouping of this error. Long field values may be truncated. The specific fields included in this response are dependent on the `grouping_reason`.
     * @type {any}
     * @memberof InlineResponse2004
     */
    groupingFields?: any;
    /**
     * Whether future Events for this error are being discarded.
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    discarded?: boolean;
}

/**
 * @export
 * @namespace InlineResponse2004
 */
export namespace InlineResponse2004 {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OriginalSeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OverriddenSeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Open = <any>'open',
        InProgress = <any>'in progress',
        ForReview = <any>'for_review',
        Fixed = <any>'fixed',
        Snoozed = <any>'snoozed',
        Ignored = <any>'ignored'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum GroupingReasonEnum {
        FrameCode = <any>'frame-code',
        FrameInner = <any>'frame-inner',
        ContextInner = <any>'context-inner',
        ErrorClassInner = <any>'error_class-inner',
        UserDefined = <any>'user_defined',
        JsBlob = <any>'js-blob',
        JsTag = <any>'js-tag',
        JsHtml = <any>'js-html',
        JsEval = <any>'js-eval',
        JsStructure = <any>'js-structure',
        JsCodebase = <any>'js-codebase',
        JsLocation = <any>'js-location'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * The ID for this variant.
     * @type {string}
     * @memberof InlineResponse20040
     */
    variantId: string;
    /**
     * The number of errors seen for this variant.
     * @type {number}
     * @memberof InlineResponse20040
     */
    errorsSeen: number;
    /**
     * The number of errors exclusively seen for this variant.
     * @type {number}
     * @memberof InlineResponse20040
     */
    exclusiveErrors: number;
    /**
     * The last time an error was received for this variant.
     * @type {string}
     * @memberof InlineResponse20040
     */
    lastSeen: string;
}
/**
 *
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * The ID of the variant.
     * @type {string}
     * @memberof InlineResponse20041
     */
    id: string;
    /**
     * The name of the variant.
     * @type {string}
     * @memberof InlineResponse20041
     */
    name: string;
    /**
     * The first the time variant was received regardless of retention. Only present if the `release_stage_name` parameter was provided and the Variant has been seen in that release stage.
     * @type {string}
     * @memberof InlineResponse20041
     */
    firstSeen?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * The ID of the Span Group.
     * @type {string}
     * @memberof InlineResponse20042
     */
    id: string;
    /**
     * The performance category of the Span Group.
     * @type {string}
     * @memberof InlineResponse20042
     */
    category: InlineResponse20042.CategoryEnum;
    /**
     * The name of the Span Group.
     * @type {string}
     * @memberof InlineResponse20042
     */
    name: string;
    /**
     * The name of the Span Group for display purposes.
     * @type {string}
     * @memberof InlineResponse20042
     */
    displayName: string;
    /**
     * Whether the requesting user has starred the Span Group.
     * @type {boolean}
     * @memberof InlineResponse20042
     */
    isStarred?: boolean;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatistics}
     * @memberof InlineResponse20042
     */
    statistics?: ProjectsprojectIdspanGroupsStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTarget}
     * @memberof InlineResponse20042
     */
    performanceTarget?: ProjectsprojectIdspanGroupsPerformanceTarget;
}

/**
 * @export
 * @namespace InlineResponse20042
 */
export namespace InlineResponse20042 {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        AppStart = <any>'app_start',
        ViewLoad = <any>'view_load',
        PageLoad = <any>'page_load',
        RouteChange = <any>'route_change',
        FullPageLoad = <any>'full_page_load',
        Network = <any>'network',
        Custom = <any>'custom',
        Navigation = <any>'navigation',
        InboundHttp = <any>'inbound_http',
        OutboundHttp = <any>'outbound_http',
        InboundRpc = <any>'inbound_rpc',
        OutboundRpc = <any>'outbound_rpc',
        CustomServer = <any>'custom_server',
        FrozenFrame = <any>'frozen_frame'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * The ID of the Span Group.
     * @type {string}
     * @memberof InlineResponse20043
     */
    id: string;
    /**
     * The performance category of the Span Group.
     * @type {string}
     * @memberof InlineResponse20043
     */
    category: InlineResponse20043.CategoryEnum;
    /**
     * The name of the Span Group.
     * @type {string}
     * @memberof InlineResponse20043
     */
    name: string;
    /**
     * The name of the Span Group for display purposes.
     * @type {string}
     * @memberof InlineResponse20043
     */
    displayName: string;
    /**
     * Whether the requesting user has starred the Span Group.
     * @type {boolean}
     * @memberof InlineResponse20043
     */
    isStarred?: boolean;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatistics}
     * @memberof InlineResponse20043
     */
    statistics?: ProjectsprojectIdspanGroupsStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTarget}
     * @memberof InlineResponse20043
     */
    performanceTarget?: ProjectsprojectIdspanGroupsPerformanceTarget;
}

/**
 * @export
 * @namespace InlineResponse20043
 */
export namespace InlineResponse20043 {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        AppStart = <any>'app_start',
        ViewLoad = <any>'view_load',
        PageLoad = <any>'page_load',
        RouteChange = <any>'route_change',
        FullPageLoad = <any>'full_page_load',
        Network = <any>'network',
        Custom = <any>'custom',
        Navigation = <any>'navigation',
        InboundHttp = <any>'inbound_http',
        OutboundHttp = <any>'outbound_http',
        InboundRpc = <any>'inbound_rpc',
        OutboundRpc = <any>'outbound_rpc',
        CustomServer = <any>'custom_server',
        FrozenFrame = <any>'frozen_frame'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * The ID of the Span Group.
     * @type {string}
     * @memberof InlineResponse20044
     */
    id: string;
    /**
     * The performance category of the Span Group.
     * @type {string}
     * @memberof InlineResponse20044
     */
    category: InlineResponse20044.CategoryEnum;
    /**
     * The name of the Span Group.
     * @type {string}
     * @memberof InlineResponse20044
     */
    name: string;
    /**
     * The name of the Span Group for display purposes.
     * @type {string}
     * @memberof InlineResponse20044
     */
    displayName: string;
}

/**
 * @export
 * @namespace InlineResponse20044
 */
export namespace InlineResponse20044 {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        AppStart = <any>'app_start',
        ViewLoad = <any>'view_load',
        PageLoad = <any>'page_load',
        RouteChange = <any>'route_change',
        FullPageLoad = <any>'full_page_load',
        Network = <any>'network',
        Custom = <any>'custom',
        Navigation = <any>'navigation',
        InboundHttp = <any>'inbound_http',
        OutboundHttp = <any>'outbound_http',
        InboundRpc = <any>'inbound_rpc',
        OutboundRpc = <any>'outbound_rpc',
        CustomServer = <any>'custom_server',
        FrozenFrame = <any>'frozen_frame'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * The timestamp (inclusive) representing the start point of the bucketed statistics.
     * @type {string}
     * @memberof InlineResponse20045
     */
    bucketStart: string;
    /**
     * The timestamp (exclusive) representing the end point of the bucketed statistics.
     * @type {string}
     * @memberof InlineResponse20045
     */
    bucketEnd: string;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsidtimelineStatistics}
     * @memberof InlineResponse20045
     */
    statistics?: ProjectsprojectIdspanGroupsidtimelineStatistics;
}
/**
 *
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * The minimum time (in milliseconds; inclusive) represented by this distribution point.
     * @type {number}
     * @memberof InlineResponse20046
     */
    bucketMin: number;
    /**
     * The maximum time (in milliseconds; exclusive) represented by this distribution point.
     * @type {number}
     * @memberof InlineResponse20046
     */
    bucketMax: number;
    /**
     * The number of spans represented by this distribution point.
     * @type {number}
     * @memberof InlineResponse20046
     */
    totalSpans: number;
}
/**
 *
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * The ID of the Span Group.
     * @type {string}
     * @memberof InlineResponse20047
     */
    id: string;
    /**
     * The name of the Span Group being described.
     * @type {string}
     * @memberof InlineResponse20047
     */
    name: string;
    /**
     * The name of the Span Group for display purposes.
     * @type {string}
     * @memberof InlineResponse20047
     */
    displayName: string;
}
/**
 *
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * The ID of the Performance Target.
     * @type {string}
     * @memberof InlineResponse20048
     */
    id: string;
    /**
     * The ID of the Project that the Performance Target belongs to.
     * @type {string}
     * @memberof InlineResponse20048
     */
    projectId: string;
    /**
     * The type of Performance Target.
     * @type {string}
     * @memberof InlineResponse20048
     */
    type: InlineResponse20048.TypeEnum;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup}
     * @memberof InlineResponse20048
     */
    spanGroup: ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTargetConfig}
     * @memberof InlineResponse20048
     */
    config: ProjectsprojectIdspanGroupsPerformanceTargetConfig;
}

/**
 * @export
 * @namespace InlineResponse20048
 */
export namespace InlineResponse20048 {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Category = <any>'category',
        SpanGroup = <any>'span_group'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * The ID of the (virtual) Span Group.
     * @type {string}
     * @memberof InlineResponse20049
     */
    id: string;
    /**
     * The name of the (virtual) Span Group for display purposes.
     * @type {string}
     * @memberof InlineResponse20049
     */
    displayName: string;
    /**
     * Whether the requesting user has starred the (virtual) Span Group.
     * @type {boolean}
     * @memberof InlineResponse20049
     */
    isStarred?: boolean;
    /**
     *
     * @type {ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup}
     * @memberof InlineResponse20049
     */
    fullPageLoadSpanGroup: ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup;
    /**
     *
     * @type {ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup}
     * @memberof InlineResponse20049
     */
    routeChangeSpanGroup: ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup;
}
/**
 * Deprecated field that returns the first `linked_issue`. Consider using the `linked_issues` field instead.
 * @export
 * @interface InlineResponse2004CreatedIssue
 */
export interface InlineResponse2004CreatedIssue {
    /**
     * The immutable issue id.
     * @type {string}
     * @memberof InlineResponse2004CreatedIssue
     */
    id: string;
    /**
     * The issue key (if applicable). For example, in the case of a Jira story, this will be the mutable key (e.g. ENG-10)
     * @type {string}
     * @memberof InlineResponse2004CreatedIssue
     */
    key?: string;
    /**
     * The issue number (if applicable). For example, in the case of a github issue with the url `https://github.com/foo/bar/issues/123` this field will be set to `123`.
     * @type {number}
     * @memberof InlineResponse2004CreatedIssue
     */
    number?: number;
    /**
     * An identifier for the 3rd party service
     * @type {string}
     * @memberof InlineResponse2004CreatedIssue
     */
    type: string;
    /**
     * The url to the issue on the 3rd party service
     * @type {string}
     * @memberof InlineResponse2004CreatedIssue
     */
    url: string;
}
/**
 * Snooze rules for automatically reopening the Error
 * @export
 * @interface InlineResponse2004ReopenRules
 */
export interface InlineResponse2004ReopenRules {
    /**
     * Must be one of the following: - `n_additional_occurrences` - Indicates that the Error should be reopened after n more occurrences. In this case, the `occurrence_threshold` field indicates the number of total occurrences at which the Error should be reopened, and the `additional_occurrences` field indicates the number of additional occurrences that were allowed before reopening. - `n_occurrences_in_m_hours` - Indicates that the Error should be reopened after n occurrences over some configurable number of hours. In this case, the `occurrences` and `hours` fields will both be present. - `occurs_after` - Indicates that the error should be reopened if there are any occurrences after the specified time period. The `seconds` field contains the number of seconds that the Error has been snoozed for. In this case, the `seconds` and `reopen_after` fields will both be present.
     * @type {string}
     * @memberof InlineResponse2004ReopenRules
     */
    reopenIf: InlineResponse2004ReopenRules.ReopenIfEnum;
    /**
     * for `occurs_after` reopen rules, this field indicates the time after which the Error should be reopened if there is an additional occurrence.
     * @type {string}
     * @memberof InlineResponse2004ReopenRules
     */
    reopenAfter?: string;
    /**
     * for `occurs_after` reopen rules, the number of seconds that the Error was set to snooze for.
     * @type {number}
     * @memberof InlineResponse2004ReopenRules
     */
    seconds?: number;
    /**
     * for `n_occurrences_in_m_hours` reopen rules, the number of occurrences to allow in the number of hours indicated by the `hours` field, before the Error is automatically reopened.
     * @type {number}
     * @memberof InlineResponse2004ReopenRules
     */
    occurrences?: number;
    /**
     * for `n_occurrences_in_m_hours` reopen rules, the number of hours.
     * @type {number}
     * @memberof InlineResponse2004ReopenRules
     */
    hours?: number;
    /**
     * for `n_additional_occurrences` reopen rules, the number of total occurrences at which the Error should be reopened.
     * @type {number}
     * @memberof InlineResponse2004ReopenRules
     */
    occurrenceThreshold?: number;
    /**
     * for `n_additional_occurrences` reopen rules, the number of additional occurrences allowed before reopening.
     * @type {number}
     * @memberof InlineResponse2004ReopenRules
     */
    additionalOccurrences?: number;
}

/**
 * @export
 * @namespace InlineResponse2004ReopenRules
 */
export namespace InlineResponse2004ReopenRules {
    /**
     * @export
     * @enum {string}
     */
    export enum ReopenIfEnum {
        NAdditionalOccurrences = <any>'n_additional_occurrences',
        NOccurrencesInMHours = <any>'n_occurrences_in_m_hours',
        OccursAfter = <any>'occurs_after'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2005
     */
    id?: string;
    /**
     * The URL for the event
     * @type {string}
     * @memberof InlineResponse2005
     */
    url?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2005
     */
    projectUrl?: string;
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    isFullReport?: boolean;
    /**
     * The Error this Event is an occurrence of
     * @type {string}
     * @memberof InlineResponse2005
     */
    errorId?: string;
    /**
     * The time the Bugsnag [error reporting API](https://docs.bugsnag.com/api/error-reporting/) was notified of this Event
     * @type {string}
     * @memberof InlineResponse2005
     */
    receivedAt?: string;
    /**
     * An array of exceptions that occurred during this event. Most of the time there will only be one exception, but some languages support \"nested\" or \"caused by\" exceptions. The first item in the array represents the outermost exception. Each subsequent item represents the exception that caused the preceding one.
     * @type {Array<InlineResponse2005Exceptions>}
     * @memberof InlineResponse2005
     */
    exceptions?: Array<InlineResponse2005Exceptions>;
    /**
     * An array of the threads running when this event was reported.
     * @type {Array<InlineResponse2005Threads>}
     * @memberof InlineResponse2005
     */
    threads?: Array<InlineResponse2005Threads>;
    /**
     * Custom metadata passed with the event manually or via the notifier library. The API preserves the original casing and key format as received.
     * @type {any}
     * @memberof InlineResponse2005
     */
    metaData?: any;
    /**
     *
     * @type {InlineResponse2005Request}
     * @memberof InlineResponse2005
     */
    request?: InlineResponse2005Request;
    /**
     *
     * @type {InlineResponse2005App}
     * @memberof InlineResponse2005
     */
    app?: InlineResponse2005App;
    /**
     *
     * @type {InlineResponse2005Device}
     * @memberof InlineResponse2005
     */
    device?: InlineResponse2005Device;
    /**
     *
     * @type {InlineResponse2005User}
     * @memberof InlineResponse2005
     */
    user?: InlineResponse2005User;
    /**
     * An array of user- and system-initiated events which led up to an error, providing additional context. This list is sequential and ordered newest to oldest.
     * @type {Array<InlineResponse2005Breadcrumbs>}
     * @memberof InlineResponse2005
     */
    breadcrumbs?: Array<InlineResponse2005Breadcrumbs>;
    /**
     * This refers to the action that was happening when the event occurred.
     * @type {string}
     * @memberof InlineResponse2005
     */
    context?: string;
    /**
     * - info - can be used in manual Bugsnag.notify calls - warning - the default severity when Bugsnag.notify is called manually - error - the default severity for uncaught exceptions and crashes
     * @type {string}
     * @memberof InlineResponse2005
     */
    severity?: InlineResponse2005.SeverityEnum;
    /**
     * Whether or not the event was from an unhandled exception.
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    unhandled?: boolean;
    /**
     * Whether or not there's a missing dsym (only included in response if event includes a dsym_uuid).
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    missingDsym?: boolean;
    /**
     *
     * @type {InlineResponse2005Correlation}
     * @memberof InlineResponse2005
     */
    correlation?: InlineResponse2005Correlation;
    /**
     * Feature flags and variants that were active when the event occurred.
     * @type {Array<InlineResponse2005FeatureFlags>}
     * @memberof InlineResponse2005
     */
    featureFlags?: Array<InlineResponse2005FeatureFlags>;
}

/**
 * @export
 * @namespace InlineResponse2005
 */
export namespace InlineResponse2005 {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * The ID of the (virtual) Span Group.
     * @type {string}
     * @memberof InlineResponse20050
     */
    id: string;
    /**
     * The name of the (virtual) Span Group for display purposes.
     * @type {string}
     * @memberof InlineResponse20050
     */
    displayName: string;
    /**
     * Whether the requesting user has starred the (virtual) Span Group.
     * @type {boolean}
     * @memberof InlineResponse20050
     */
    isStarred?: boolean;
    /**
     *
     * @type {ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup}
     * @memberof InlineResponse20050
     */
    fullPageLoadSpanGroup: ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup;
    /**
     *
     * @type {ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup}
     * @memberof InlineResponse20050
     */
    routeChangeSpanGroup: ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup;
}
/**
 *
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * Identifier that is used as the key for filtering by this field.
     * @type {string}
     * @memberof InlineResponse20051
     */
    displayId: string;
    /**
     *
     * @type {ProjectsprojectIdtraceFieldsFilterOptions}
     * @memberof InlineResponse20051
     */
    filterOptions: ProjectsprojectIdtraceFieldsFilterOptions;
    /**
     * Whether or not this Trace Field is for a user-specified attribute rather than a pre-defined filter.
     * @type {boolean}
     * @memberof InlineResponse20051
     */
    custom: boolean;
    /**
     * The key in metadata to use for this Trace Field. Only present when `custom` is `true`.
     * @type {string}
     * @memberof InlineResponse20051
     */
    metadataKey?: string;
    /**
     * The location of the metadata key within a Trace. Only present when `custom` is `true`.
     * @type {string}
     * @memberof InlineResponse20051
     */
    metadataLocation?: InlineResponse20051.MetadataLocationEnum;
    /**
     * The type of the field. Only present when `custom` is `true`.
     * @type {string}
     * @memberof InlineResponse20051
     */
    fieldType?: InlineResponse20051.FieldTypeEnum;
}

/**
 * @export
 * @namespace InlineResponse20051
 */
export namespace InlineResponse20051 {
    /**
     * @export
     * @enum {string}
     */
    export enum MetadataLocationEnum {
        SpanAttribute = <any>'span_attribute',
        ResourceAttribute = <any>'resource_attribute'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FieldTypeEnum {
        String = <any>'string',
        Boolean = <any>'boolean',
        Number = <any>'number'
    }
}
/**
 *
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * The ID of the project this is for
     * @type {string}
     * @memberof InlineResponse20052
     */
    projectId: string;
    /**
     * The URL patterns by which network spans are grouped.
     * @type {Array<string>}
     * @memberof InlineResponse20052
     */
    endpoints: Array<string>;
}
/**
 * Information about the application that reported the event.
 * @export
 * @interface InlineResponse2005App
 */
export interface InlineResponse2005App {
    /**
     * A unique ID for the application.
     * @type {string}
     * @memberof InlineResponse2005App
     */
    id?: string;
    /**
     * The version number of the application which generated the error.
     * @type {string}
     * @memberof InlineResponse2005App
     */
    version?: string;
    /**
     * The [version code](https://developer.android.com/studio/publish/versioning.html) of the application (Android only)
     * @type {number}
     * @memberof InlineResponse2005App
     */
    versionCode?: number;
    /**
     * The [bundle version/build number](https://developer.apple.com/library/content/technotes/tn2420/_index.html) of the application (iOS/macOS/tvOS only)
     * @type {string}
     * @memberof InlineResponse2005App
     */
    bundleVersion?: string;
    /**
     * A unique identifier to identify a code bundle release when using tools like CodePush (mobile only).
     * @type {string}
     * @memberof InlineResponse2005App
     */
    codeBundleId?: string;
    /**
     * A build ID that is required to identify a specific build when the version and version code are the same.
     * @type {string}
     * @memberof InlineResponse2005App
     */
    buildUUID?: string;
    /**
     * The release stage that this error occurred in, for example \"development\", \"staging\" or \"production\".
     * @type {string}
     * @memberof InlineResponse2005App
     */
    releaseStage?: string;
    /**
     * The application type, such as a web framework or mobile platform, for example \"rails\" or \"android\".
     * @type {string}
     * @memberof InlineResponse2005App
     */
    type?: string;
    /**
     * The UUIDs of the [debug symbols file](http://lldb.llvm.org/symbols.html) corresponding to this application, if any.
     * @type {Array<string>}
     * @memberof InlineResponse2005App
     */
    dsymUUIDs?: Array<string>;
    /**
     * How long the app has been running for in milliseconds.
     * @type {number}
     * @memberof InlineResponse2005App
     */
    duration?: number;
    /**
     * How long the app has been in the foreground of the device in milliseconds.
     * @type {number}
     * @memberof InlineResponse2005App
     */
    durationInForeground?: number;
    /**
     * Whether or not the app was in the foreground when the error occurred.
     * @type {boolean}
     * @memberof InlineResponse2005App
     */
    inForeground?: boolean;
    /**
     * Whether or not the application was still in the process of launching when the event was created.
     * @type {boolean}
     * @memberof InlineResponse2005App
     */
    isLaunching?: boolean;
    /**
     * The architecture of the running binary (Android only). - `x86` - x86/i386 (32-bit). - `x86_64` - x86 (64-bit). - `arm32` - armeabi/armeabi-v7a (32-bit). - `arm64` - arm64-v8a (64-bit). - `amd64` - amd64 (64-bit).
     * @type {string}
     * @memberof InlineResponse2005App
     */
    binaryArch?: InlineResponse2005App.BinaryArchEnum;
    /**
     * Whether or not the application was running through Rosetta (iOS only).
     * @type {boolean}
     * @memberof InlineResponse2005App
     */
    runningOnRosetta?: boolean;
}

/**
 * @export
 * @namespace InlineResponse2005App
 */
export namespace InlineResponse2005App {
    /**
     * @export
     * @enum {string}
     */
    export enum BinaryArchEnum {
        X86 = <any>'x86',
        X8664 = <any>'x86_64',
        Arm32 = <any>'arm32',
        Arm64 = <any>'arm64',
        Amd64 = <any>'amd64'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2005Breadcrumbs
 */
export interface InlineResponse2005Breadcrumbs {
    /**
     * A short summary describing the event, such as the user action taken or a new application state.
     * @type {string}
     * @memberof InlineResponse2005Breadcrumbs
     */
    name: string;
    /**
     * A category which describes the breadcrumb, from the list of allowed values. - `navigation` - Changing screens or content being displayed, with a defined destination and optionally a previous location. - `request` - Sending and receiving requests and responses. - `process` - Performing an intensive task or query. - `log` - Messages and severity sent to a logging platform. - `user` - Actions performed by the user, like text input, button presses, or confirming/cancelling an alert dialog. - `state` - Changing the overall state of an app, such as closing, pausing, or being moved to the background, as well as device state changes like memory or battery warnings and network connectivity changes. - `error` - An error which was reported to Bugsnag encountered in the same session. - `manual` - User-defined, manually added breadcrumbs.
     * @type {string}
     * @memberof InlineResponse2005Breadcrumbs
     */
    type: InlineResponse2005Breadcrumbs.TypeEnum;
    /**
     * The time at which the event occurred, in [ISO 8601 format](https://tools.ietf.org/html/rfc3339#section-5.8).
     * @type {Date}
     * @memberof InlineResponse2005Breadcrumbs
     */
    timestamp: Date;
    /**
     * An object containing extra information about a breadcrumb
     * @type {any}
     * @memberof InlineResponse2005Breadcrumbs
     */
    metaData?: any;
}

/**
 * @export
 * @namespace InlineResponse2005Breadcrumbs
 */
export namespace InlineResponse2005Breadcrumbs {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Navigation = <any>'navigation',
        Request = <any>'request',
        Process = <any>'process',
        Log = <any>'log',
        User = <any>'user',
        State = <any>'state',
        Error = <any>'error',
        Manual = <any>'manual'
    }
}
/**
 * Information about the trace and span linked to the event.
 * @export
 * @interface InlineResponse2005Correlation
 */
export interface InlineResponse2005Correlation {
    /**
     * The ID of the OTel trace during which this event occurred
     * @type {string}
     * @memberof InlineResponse2005Correlation
     */
    traceId?: string;
    /**
     * The ID of the OTel span during which this event occurred
     * @type {string}
     * @memberof InlineResponse2005Correlation
     */
    spanId?: string;
}
/**
 * Information about the device the error occurred on.
 * @export
 * @interface InlineResponse2005Device
 */
export interface InlineResponse2005Device {
    /**
     * A unique identifier for the device.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    id?: string;
    /**
     * The hostname of the server running your code, if applicable.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    hostname?: string;
    /**
     * The manufacturer of the device.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    manufacturer?: string;
    /**
     * The model of the device.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    model?: string;
    /**
     * The model number of the device.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    modelNumber?: string;
    /**
     * The device's operating system name.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    osName?: string;
    /**
     * The device's operating system version.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    osVersion?: string;
    /**
     * The number of bytes unused in the device's RAM.
     * @type {number}
     * @memberof InlineResponse2005Device
     */
    freeMemory?: number;
    /**
     * The number of total bytes in the device's RAM.
     * @type {number}
     * @memberof InlineResponse2005Device
     */
    totalMemory?: number;
    /**
     * The number of unused bytes on the drive running the application.
     * @type {number}
     * @memberof InlineResponse2005Device
     */
    freeDisk?: number;
    /**
     * If a web application, the web browser used by the device.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    browserName?: string;
    /**
     * If a web application, the version of the browser used by the device.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    browserVersion?: string;
    /**
     * Whether or not the device has been modified to give users root access.
     * @type {boolean}
     * @memberof InlineResponse2005Device
     */
    jailbroken?: boolean;
    /**
     * The orientation of the device at the time of the error.
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    orientation?: string;
    /**
     * The locale of the device
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    locale?: string;
    /**
     * Whether the device was charging
     * @type {boolean}
     * @memberof InlineResponse2005Device
     */
    charging?: boolean;
    /**
     * The battery level of the device as a decimal
     * @type {number}
     * @memberof InlineResponse2005Device
     */
    batteryLevel?: number;
    /**
     * The time at which the error occurred, in [ISO 8601 format](https://tools.ietf.org/html/rfc3339#section-5.8).
     * @type {Date}
     * @memberof InlineResponse2005Device
     */
    time?: Date;
    /**
     * The timezone in which the error occurred
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    timezone?: string;
    /**
     * The [ABIs](https://developer.android.com/ndk/guides/abis) supported by the device (Android only).
     * @type {Array<string>}
     * @memberof InlineResponse2005Device
     */
    cpuAbi?: Array<string>;
    /**
     * Hash of the versions of the relevant runtimes, languages and/or frameworks for the platform.
     * @type {any}
     * @memberof InlineResponse2005Device
     */
    runtimeVersions?: any;
    /**
     * The Mac Catalyst version (iOS only).
     * @type {string}
     * @memberof InlineResponse2005Device
     */
    macCatalystIosVersion?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005Exceptions
 */
export interface InlineResponse2005Exceptions {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2005Exceptions
     */
    errorClass?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2005Exceptions
     */
    message?: string;
    /**
     * The type of the exception. `null` if not recorded.
     * @type {string}
     * @memberof InlineResponse2005Exceptions
     */
    type?: string;
    /**
     * An array of stack trace objects. Each object represents one line in the exception's stack trace. Bugsnag uses this information to help with error grouping, as well as displaying it to the user.
     * @type {Array<InlineResponse2005Stacktrace>}
     * @memberof InlineResponse2005Exceptions
     */
    stacktrace?: Array<InlineResponse2005Stacktrace>;
    /**
     * An array of register details for minidump stackframes.
     * @type {Array<InlineResponse2005Registers>}
     * @memberof InlineResponse2005Exceptions
     */
    registers?: Array<InlineResponse2005Registers>;
}
/**
 *
 * @export
 * @interface InlineResponse2005FeatureFlags
 */
export interface InlineResponse2005FeatureFlags {
    /**
     * The name of the feature_flag.
     * @type {string}
     * @memberof InlineResponse2005FeatureFlags
     */
    featureFlagName?: string;
    /**
     * The ID of the feature_flag.
     * @type {string}
     * @memberof InlineResponse2005FeatureFlags
     */
    featureFlagId?: string;
    /**
     * The name of the variant if present.
     * @type {string}
     * @memberof InlineResponse2005FeatureFlags
     */
    variantName?: string;
    /**
     * The ID of the variant if present.
     * @type {string}
     * @memberof InlineResponse2005FeatureFlags
     */
    variantId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005RegisterValues
 */
export interface InlineResponse2005RegisterValues {
    /**
     * The name of the register
     * @type {string}
     * @memberof InlineResponse2005RegisterValues
     */
    registerName?: string;
    /**
     * The value of the register
     * @type {string}
     * @memberof InlineResponse2005RegisterValues
     */
    registerValue?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005Registers
 */
export interface InlineResponse2005Registers {
    /**
     * The index of the frame in the stacktrace that the registers apply to
     * @type {number}
     * @memberof InlineResponse2005Registers
     */
    frameIndex?: number;
    /**
     * Details of a register
     * @type {Array<InlineResponse2005RegisterValues>}
     * @memberof InlineResponse2005Registers
     */
    registerValues?: Array<InlineResponse2005RegisterValues>;
}
/**
 *
 * @export
 * @interface InlineResponse2005Request
 */
export interface InlineResponse2005Request {
    /**
     * The URL the request was made to
     * @type {string}
     * @memberof InlineResponse2005Request
     */
    url?: string;
    /**
     * The IP making the request
     * @type {string}
     * @memberof InlineResponse2005Request
     */
    clientIp?: string;
    /**
     * The HTTP method used for the request
     * @type {string}
     * @memberof InlineResponse2005Request
     */
    httpMethod?: string;
    /**
     * The URL referring the user
     * @type {string}
     * @memberof InlineResponse2005Request
     */
    referer?: string;
    /**
     * Hash of headers sent with the request
     * @type {any}
     * @memberof InlineResponse2005Request
     */
    headers?: any;
    /**
     * Hash of parameter sent with the request
     * @type {any}
     * @memberof InlineResponse2005Request
     */
    params?: any;
}
/**
 *
 * @export
 * @interface InlineResponse2005Stacktrace
 */
export interface InlineResponse2005Stacktrace {
    /**
     * The line of the file that this frame of the stack was in.
     * @type {number}
     * @memberof InlineResponse2005Stacktrace
     */
    lineNumber?: number;
    /**
     * The column of the file that this frame of the stack was in.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    columnNumber?: string;
    /**
     * The file that this stack frame was executing
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    file?: string;
    /**
     * Indicates if this stack trace line is in the project's application code (true) or form a 3rd party library (false).
     * @type {boolean}
     * @memberof InlineResponse2005Stacktrace
     */
    inProject?: boolean;
    /**
     * Path of the code file for the module referenced.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    codeFile?: string;
    /**
     * Offset of the frame's return address from the base of the line, function, or module in a minidump.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    addressOffset?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    machoUuid?: string;
    /**
     * Offset of the frame's return address from the base of the line, function, or module.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    relativeAddress?: string;
    /**
     * The frame's return address from the base of the line, function, or module in a minidump.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    frameAddress?: string;
    /**
     * The method that this particular stack frame is within.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    method?: string;
    /**
     * A link to the affected line of code in source control.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    sourceControlLink?: string;
    /**
     * The name of the source control service being used.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace
     */
    sourceControlName?: string;
    /**
     * The code in the file surrounding this line, with up to three lines on either side of the line that crashed.
     * @type {any}
     * @memberof InlineResponse2005Stacktrace
     */
    code?: any;
}
/**
 *
 * @export
 * @interface InlineResponse2005Stacktrace1
 */
export interface InlineResponse2005Stacktrace1 {
    /**
     * The line of the file that this frame of the stack was in.
     * @type {number}
     * @memberof InlineResponse2005Stacktrace1
     */
    lineNumber?: number;
    /**
     * The column of the file that this frame of the stack was in.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    columnNumber?: string;
    /**
     * The file that this stack frame was executing
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    file?: string;
    /**
     * Indicates if this stack trace line is in the project's application code (true) or form a 3rd party library (false).
     * @type {boolean}
     * @memberof InlineResponse2005Stacktrace1
     */
    inProject?: boolean;
    /**
     * Path of the code file for the module referenced.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    codeFile?: string;
    /**
     * Offset of the frame's return address from the base of the line, function, or module in a minidump.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    addressOffset?: string;
    /**
     * Offset of the frame's return address from the base of the line, function, or module.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    relativeAddress?: string;
    /**
     * the frame's return address from the base of the line, function, or module in a minidump.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    frameAddress?: string;
    /**
     * The method that this particular stack frame is within.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    method?: string;
    /**
     * The type of the stackframe. This may be different for each stackframe, for example when the error occures in native extension of a scripting language.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    type?: string;
    /**
     * A link to the affected line of code in source control.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    sourceControlLink?: string;
    /**
     * The name of the source control service being used.
     * @type {string}
     * @memberof InlineResponse2005Stacktrace1
     */
    sourceControlName?: string;
    /**
     * The code in the file surrounding this line, with up to three lines on either side of the line that crashed.
     * @type {any}
     * @memberof InlineResponse2005Stacktrace1
     */
    code?: any;
}
/**
 *
 * @export
 * @interface InlineResponse2005Threads
 */
export interface InlineResponse2005Threads {
    /**
     * The id of the thread in the application.
     * @type {number}
     * @memberof InlineResponse2005Threads
     */
    id?: number;
    /**
     * A human readable name for the thread.
     * @type {string}
     * @memberof InlineResponse2005Threads
     */
    name?: string;
    /**
     * The type of the thread
     * @type {string}
     * @memberof InlineResponse2005Threads
     */
    type?: string;
    /**
     * An array of stack trace objects. Each object represents one line in the exception's stack trace. Bugsnag uses this information to help with error grouping, as well as displaying it to the user.
     * @type {Array<InlineResponse2005Stacktrace1>}
     * @memberof InlineResponse2005Threads
     */
    stacktrace?: Array<InlineResponse2005Stacktrace1>;
    /**
     * Indicates if this is the thread from which the error was reported.
     * @type {boolean}
     * @memberof InlineResponse2005Threads
     */
    errorReportingThread?: boolean;
    /**
     * The state of the thread
     * @type {string}
     * @memberof InlineResponse2005Threads
     */
    state?: string;
}
/**
 * Information about the user that reported the event. This field can be sent in with extra metadata, and thus may return keys alongside those documented here.
 * @export
 * @interface InlineResponse2005User
 */
export interface InlineResponse2005User {
    /**
     * A unique identifier for a user affected by this event. This could be any distinct identifier that makes sense for your application/platform.
     * @type {string}
     * @memberof InlineResponse2005User
     */
    id?: string;
    /**
     * The user's name, or a string you use to identify them.
     * @type {string}
     * @memberof InlineResponse2005User
     */
    name?: string;
    /**
     * The user's email address.
     * @type {string}
     * @memberof InlineResponse2005User
     */
    email?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse2006
     */
    id?: string;
    /**
     *
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    isFullReport?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2006
     */
    url?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2006
     */
    projectUrl?: string;
    /**
     * The Error this Event is an occurrence of
     * @type {string}
     * @memberof InlineResponse2006
     */
    errorId?: string;
    /**
     * The time the Bugsnag [error reporting API](https://docs.bugsnag.com/api/error-reporting/) was notified of this Event
     * @type {string}
     * @memberof InlineResponse2006
     */
    receivedAt?: string;
    /**
     * An array of exceptions that occurred during this event. Most of the time there will only be one exception, but some languages support \"nested\" or \"caused by\" exceptions. The first item in the array represents the outermost exception. Each subsequent item represents the exception that caused the preceding one.
     * @type {Array<any>}
     * @memberof InlineResponse2006
     */
    exceptions?: Array<any>;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2006
     */
    errorClass?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2006
     */
    message?: string;
    /**
     * - info - can be used in manual Bugsnag.notify calls - warning - the default severity when Bugsnag.notify is called manually - error - the default severity for uncaught exceptions and crashes
     * @type {string}
     * @memberof InlineResponse2006
     */
    severity?: InlineResponse2006.SeverityEnum;
    /**
     * Whether or not the event was from an unhandled exception
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    unhandled?: boolean;
    /**
     * This refers to the action that was happening when the event occurred.
     * @type {string}
     * @memberof InlineResponse2006
     */
    context?: string;
    /**
     *
     * @type {ProjectsprojectIderrorserrorIdeventsApp}
     * @memberof InlineResponse2006
     */
    app?: ProjectsprojectIderrorserrorIdeventsApp;
}

/**
 * @export
 * @namespace InlineResponse2006
 */
export namespace InlineResponse2006 {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * the ID of the Event Field that this Pivot describes
     * @type {string}
     * @memberof InlineResponse2007
     */
    eventFieldDisplayId: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse2007
     */
    name: string;
    /**
     * how many unique values of the given Event Field are present in the Events matching the provided Filters. For example, in the case of the `app.release_stage` Pivot, if the Events matching the provided Filters occurred only in production and staging, then the cardinality would be 2.  Applicable to some Event Fields.
     * @type {number}
     * @memberof InlineResponse2007
     */
    cardinality?: number;
    /**
     * A summary of the top values for this Pivot. Applicable to some Event Fields.
     * @type {any}
     * @memberof InlineResponse2007
     */
    summary?: any;
    /**
     * A list of the values of the Event Field which have had the most occurrences. The data in this list along with the `no_value` and `other` properties will account for all of the occurrences of the Event that match the Filters.
     * @type {Array<ProjectsprojectIderrorserrorIdpivotsList>}
     * @memberof InlineResponse2007
     */
    list?: Array<ProjectsprojectIderrorserrorIdpivotsList>;
    /**
     * The number of Events that matched the provided Filters that had no value for the given Event Field
     * @type {number}
     * @memberof InlineResponse2007
     */
    noValue?: number;
    /**
     * The number of Events that matched the provided Filters that had a value for the given Event Field other than those described in `list`
     * @type {number}
     * @memberof InlineResponse2007
     */
    other?: number;
    /**
     * The average value for the given Event Field. Applicable to some Event Fields. This will be null if there is no average value (if there are no values to be averaged).
     * @type {number}
     * @memberof InlineResponse2007
     */
    average?: number;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * One of the values for this event field. For example, for the release stage event field, the values will be the stage names; for versions they will be the version number; for users they will be the user IDs, and so on.
     * @type {string}
     * @memberof InlineResponse2008
     */
    eventFieldValue: string;
    /**
     * The number of Events matching the given Filters that affected this particular value of the pivot. For example, how many events occurred in the production release stage.
     * @type {number}
     * @memberof InlineResponse2008
     */
    events?: number;
    /**
     * the proportion of the total Events matching the Filters represented by this value.
     * @type {number}
     * @memberof InlineResponse2008
     */
    proportion?: number;
    /**
     * the first Event occurrence with this particular value and matching the Filters (including time filters)
     * @type {string}
     * @memberof InlineResponse2008
     */
    firstSeen?: string;
    /**
     * the last Event occurrence with this particular value and matching the Filters (including time filters)
     * @type {string}
     * @memberof InlineResponse2008
     */
    lastSeen?: string;
    /**
     * some pivot values will include additional event field values. for example, in the case of a pivot value describing how many events affected a particular user, fields will contain the values of the `user.name` and `user.email` event fields, to provide more details about the user.
     * @type {Array<ProjectsprojectIderrorserrorIdpivotseventFieldDisplayIdvaluesFields>}
     * @memberof InlineResponse2008
     */
    fields?: Array<ProjectsprojectIderrorserrorIdpivotseventFieldDisplayIdvaluesFields>;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * The key to uniquely identify the integration service.
     * @type {string}
     * @memberof InlineResponse2009
     */
    key?: string;
    /**
     * The name of the integration service.
     * @type {string}
     * @memberof InlineResponse2009
     */
    name?: string;
    /**
     * The URL of the integration service.
     * @type {string}
     * @memberof InlineResponse2009
     */
    url?: string;
    /**
     * The type of the integration service. - `issue-tracker` - An issue tracker integration. Used for creating and linking issues to Bugsnag errors. - `team-notification` - A team communication tool integration. Used for alerting engineering teams when errors are reported to Bugsnag. - `on-call` - An on call integration. Used for alerting ops teams when errors are reported to Bugsnag. - `data-forwarding` - A data forwarding integration. Used for forwarding detailed error data when errors are reported to Bugsnag.
     * @type {string}
     * @memberof InlineResponse2009
     */
    type?: InlineResponse2009.TypeEnum;
    /**
     * Whether the integration supports two-way sync.
     * @type {boolean}
     * @memberof InlineResponse2009
     */
    twoWaySync?: boolean;
    /**
     * A brief explanation of what the integration does.
     * @type {string}
     * @memberof InlineResponse2009
     */
    description?: string;
    /**
     *
     * @type {IntegrationsActions}
     * @memberof InlineResponse2009
     */
    actions?: IntegrationsActions;
    /**
     * The fields required to configure the integration.
     * @type {Array<IntegrationsFields>}
     * @memberof InlineResponse2009
     */
    fields?: Array<IntegrationsFields>;
    /**
     * A URL containing an icon representing the service.
     * @type {string}
     * @memberof InlineResponse2009
     */
    iconUrl?: string;
    /**
     * A noun representing the entity that this integration can create (for issue-tracker type integrations only).
     * @type {string}
     * @memberof InlineResponse2009
     */
    createdEntityName?: string;
    /**
     * Automation settings (for `issue-tracker` integrations only).
     * @type {Array<IntegrationsIssueAutomationOptions>}
     * @memberof InlineResponse2009
     */
    issueAutomationOptions?: Array<IntegrationsIssueAutomationOptions>;
}

/**
 * @export
 * @namespace InlineResponse2009
 */
export namespace InlineResponse2009 {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        IssueTracker = <any>'issue-tracker',
        TeamNotification = <any>'team-notification',
        OnCall = <any>'on-call',
        DataForwarding = <any>'data-forwarding'
    }
}
/**
 *
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse201
     */
    id: string;
    /**
     * ID of user who created the saved search
     * @type {string}
     * @memberof InlineResponse201
     */
    userId: string;
    /**
     * ID of project this saved search is for
     * @type {string}
     * @memberof InlineResponse201
     */
    projectId: string;
    /**
     * name of the saved search
     * @type {string}
     * @memberof InlineResponse201
     */
    name: string;
    /**
     *
     * @type {ProjectsprojectIdsavedSearchesFilters}
     * @memberof InlineResponse201
     */
    filters: ProjectsprojectIdsavedSearchesFilters;
    /**
     * the `error` property to sort results by
     * @type {string}
     * @memberof InlineResponse201
     */
    sort: InlineResponse201.SortEnum;
    /**
     * whether this saved search is shared among collaborators
     * @type {boolean}
     * @memberof InlineResponse201
     */
    shared: boolean;
    /**
     * whether this saved search is the project default for the current user
     * @type {boolean}
     * @memberof InlineResponse201
     */
    projectDefault: boolean;
    /**
     * ID of user who last updated this saved search
     * @type {string}
     * @memberof InlineResponse201
     */
    updatedById: string;
    /**
     * time this saved search was created
     * @type {string}
     * @memberof InlineResponse201
     */
    createdAt: string;
    /**
     * time this saved search was last updated
     * @type {string}
     * @memberof InlineResponse201
     */
    updatedAt: string;
    /**
     * indicates if the saved search has a filter with `assigned_to` set to `me`
     * @type {boolean}
     * @memberof InlineResponse201
     */
    hasAssignedToMe: boolean;
    /**
     * indicates if the saved search has a filter with `assigned_to` set to anything other than `me`
     * @type {boolean}
     * @memberof InlineResponse201
     */
    hasAssignedTo: boolean;
    /**
     * indicates if the saved search has a filter with any criteria related to created issues
     * @type {boolean}
     * @memberof InlineResponse201
     */
    hasCreatedIssueFilter: boolean;
    /**
     * indicates if the saved search contains an explicit error status filter
     * @type {boolean}
     * @memberof InlineResponse201
     */
    hasStatusFilter: boolean;
    /**
     * indicates if the saved search may include errors less than 24hrs old
     * @type {string}
     * @memberof InlineResponse201
     */
    newErrorInclusion: InlineResponse201.NewErrorInclusionEnum;
    /**
     * indicates if the saved search may include open errors
     * @type {string}
     * @memberof InlineResponse201
     */
    openErrorInclusion: InlineResponse201.OpenErrorInclusionEnum;
    /**
     * indicates if the saved search may include open errors that are unassigned and have no linked issue
     * @type {string}
     * @memberof InlineResponse201
     */
    forReviewErrorInclusion: InlineResponse201.ForReviewErrorInclusionEnum;
    /**
     * indicates if the saved search may include errors that are snoozed
     * @type {string}
     * @memberof InlineResponse201
     */
    snoozedErrorInclusion: InlineResponse201.SnoozedErrorInclusionEnum;
    /**
     * indicates if the saved search may include errors that are fixed
     * @type {string}
     * @memberof InlineResponse201
     */
    fixedErrorInclusion: InlineResponse201.FixedErrorInclusionEnum;
    /**
     * indicates if the saved search may include errors that are ignored
     * @type {string}
     * @memberof InlineResponse201
     */
    ignoredErrorInclusion: InlineResponse201.IgnoredErrorInclusionEnum;
}

/**
 * @export
 * @namespace InlineResponse201
 */
export namespace InlineResponse201 {
    /**
     * @export
     * @enum {string}
     */
    export enum SortEnum {
        FirstSeen = <any>'first_seen',
        Users = <any>'users',
        Events = <any>'events',
        LastSeen = <any>'last_seen'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NewErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OpenErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ForReviewErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SnoozedErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FixedErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum IgnoredErrorInclusionEnum {
        All = <any>'all',
        Some = <any>'some',
        None = <any>'none'
    }
}
/**
 *
 * @export
 * @interface InlineResponse2011
 */
export interface InlineResponse2011 {
    /**
     * ID of the event data request
     * @type {string}
     * @memberof InlineResponse2011
     */
    id: string;
    /**
     * URL for downloading the report of the requested event data. This may be a signed URL that is accessible for short amount of time. This field is not present for on-premise installations. For on-premise installations, check the configured directory (it defaults to /data/event-data) on the server for a file having a name in the format \"[event data request ID].json\"
     * @type {string}
     * @memberof InlineResponse2011
     */
    url?: string;
    /**
     * status of the request
     * @type {string}
     * @memberof InlineResponse2011
     */
    status: InlineResponse2011.StatusEnum;
    /**
     * the total number of events that are expected to be returned; this field will be null if the status is `PREPARING`
     * @type {number}
     * @memberof InlineResponse2011
     */
    total?: number;
    /**
     * the type of report to return; this is blank if all event fields were requested
     * @type {string}
     * @memberof InlineResponse2011
     */
    reportType?: InlineResponse2011.ReportTypeEnum;
    /**
     *
     * @type {InlineResponse2011Filters}
     * @memberof InlineResponse2011
     */
    filters: InlineResponse2011Filters;
    /**
     * when the request was created
     * @type {string}
     * @memberof InlineResponse2011
     */
    createdAt: string;
    /**
     * when the request was completed
     * @type {string}
     * @memberof InlineResponse2011
     */
    completedAt?: string;
    /**
     * when the request expires (and any stored data is removed)
     * @type {string}
     * @memberof InlineResponse2011
     */
    expiresAt?: string;
}

/**
 * @export
 * @namespace InlineResponse2011
 */
export namespace InlineResponse2011 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PREPARING = <any>'PREPARING',
        AWAITINGCONFIRMATION = <any>'AWAITING_CONFIRMATION',
        ACCEPTED = <any>'ACCEPTED',
        INPROGRESS = <any>'IN_PROGRESS',
        COMPLETED = <any>'COMPLETED',
        EXPIRED = <any>'EXPIRED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReportTypeEnum {
        Gdpr = <any>'gdpr'
    }
}
/**
 * The filters used to determine which events will be included in the report. See [Filtering](/insight-hub/docs/filtering) for details.
 * @export
 * @interface InlineResponse2011Filters
 */
export interface InlineResponse2011Filters {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof InlineResponse2011Filters
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof InlineResponse2011Filters
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof InlineResponse2011Filters
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof InlineResponse2011Filters
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof InlineResponse2011Filters
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof InlineResponse2011Filters
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof InlineResponse2011Filters
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof InlineResponse2011Filters
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof InlineResponse2011Filters
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof InlineResponse2011Filters
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof InlineResponse2011Filters
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof InlineResponse2011Filters
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof InlineResponse2011Filters
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof InlineResponse2011Filters
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof InlineResponse2011Filters
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof InlineResponse2011Filters
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof InlineResponse2011Filters
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof InlineResponse2011Filters
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof InlineResponse2011Filters
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof InlineResponse2011Filters
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof InlineResponse2011Filters
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof InlineResponse2011Filters
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof InlineResponse2011Filters
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof InlineResponse2011Filters
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof InlineResponse2011Filters
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof InlineResponse2011Filters
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof InlineResponse2011Filters
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof InlineResponse2011Filters
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof InlineResponse2011Filters
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof InlineResponse2011Filters
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof InlineResponse2011Filters
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof InlineResponse2011Filters
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof InlineResponse2011Filters
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof InlineResponse2011Filters
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface InlineResponse2012
 */
export interface InlineResponse2012 {
    /**
     * ID of the event deletion request
     * @type {string}
     * @memberof InlineResponse2012
     */
    id: string;
    /**
     * status of the request
     * @type {string}
     * @memberof InlineResponse2012
     */
    status: InlineResponse2012.StatusEnum;
    /**
     * the total number of events that are expected to be deleted; this field will be null if the status is `PREPARING`
     * @type {number}
     * @memberof InlineResponse2012
     */
    total?: number;
    /**
     *
     * @type {InlineResponse2012Filters}
     * @memberof InlineResponse2012
     */
    filters: InlineResponse2012Filters;
    /**
     * when the request was created
     * @type {string}
     * @memberof InlineResponse2012
     */
    createdAt: string;
    /**
     * when the request was completed
     * @type {string}
     * @memberof InlineResponse2012
     */
    completedAt?: string;
}

/**
 * @export
 * @namespace InlineResponse2012
 */
export namespace InlineResponse2012 {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PREPARING = <any>'PREPARING',
        AWAITINGCONFIRMATION = <any>'AWAITING_CONFIRMATION',
        ACCEPTED = <any>'ACCEPTED',
        INPROGRESS = <any>'IN_PROGRESS',
        COMPLETED = <any>'COMPLETED',
        EXPIRED = <any>'EXPIRED'
    }
}
/**
 * The filters used to determine which events to delete. See [Filtering](/insight-hub/docs/filtering) for details.
 * @export
 * @interface InlineResponse2012Filters
 */
export interface InlineResponse2012Filters {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof InlineResponse2012Filters
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof InlineResponse2012Filters
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof InlineResponse2012Filters
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof InlineResponse2012Filters
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof InlineResponse2012Filters
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof InlineResponse2012Filters
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof InlineResponse2012Filters
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof InlineResponse2012Filters
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof InlineResponse2012Filters
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof InlineResponse2012Filters
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof InlineResponse2012Filters
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof InlineResponse2012Filters
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof InlineResponse2012Filters
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof InlineResponse2012Filters
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof InlineResponse2012Filters
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof InlineResponse2012Filters
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof InlineResponse2012Filters
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof InlineResponse2012Filters
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof InlineResponse2012Filters
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof InlineResponse2012Filters
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof InlineResponse2012Filters
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof InlineResponse2012Filters
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof InlineResponse2012Filters
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof InlineResponse2012Filters
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof InlineResponse2012Filters
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof InlineResponse2012Filters
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof InlineResponse2012Filters
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof InlineResponse2012Filters
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof InlineResponse2012Filters
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof InlineResponse2012Filters
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof InlineResponse2012Filters
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof InlineResponse2012Filters
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof InlineResponse2012Filters
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof InlineResponse2012Filters
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface InlineResponse2013
 */
export interface InlineResponse2013 {
    /**
     * Whether the field is a custom event field created by your organization
     * @type {boolean}
     * @memberof InlineResponse2013
     */
    custom?: boolean;
    /**
     * Identifier which is the key to use for filtering by this field
     * @type {string}
     * @memberof InlineResponse2013
     */
    displayId?: string;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsFilterOptions}
     * @memberof InlineResponse2013
     */
    filterOptions: ProjectsprojectIdeventFieldsFilterOptions;
    /**
     * Possible values for this filter, only if this filter has a finite set of values
     * @type {Array<ProjectsprojectIdeventFieldsValues>}
     * @memberof InlineResponse2013
     */
    values?: Array<ProjectsprojectIdeventFieldsValues>;
    /**
     * The valid match types when filtering by this field   - eq - Results must equal the value   - ne - Results must not equal the value
     * @type {Array<string>}
     * @memberof InlineResponse2013
     */
    matchTypes?: Array<InlineResponse2013.MatchTypesEnum>;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsPivotOptions}
     * @memberof InlineResponse2013
     */
    pivotOptions: ProjectsprojectIdeventFieldsPivotOptions;
    /**
     * Whether a reindex of this field is currently in progress (applicable to custom fields only)
     * @type {boolean}
     * @memberof InlineResponse2013
     */
    reindexInProgress?: boolean;
    /**
     * The percentage complete of the reindexing of this field (applicable to custom fields only)
     * @type {number}
     * @memberof InlineResponse2013
     */
    reindexPercentage?: number;
}

/**
 * @export
 * @namespace InlineResponse2013
 */
export namespace InlineResponse2013 {
    /**
     * @export
     * @enum {string}
     */
    export enum MatchTypesEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse400
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4001
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40010
 */
export interface InlineResponse40010 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40010
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40011
 */
export interface InlineResponse40011 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40011
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40012
 */
export interface InlineResponse40012 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40012
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40013
 */
export interface InlineResponse40013 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse40013
     */
    detail?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse40013
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse40013
     */
    scimType?: string;
}
/**
 *
 * @export
 * @interface InlineResponse40014
 */
export interface InlineResponse40014 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40014
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40015
 */
export interface InlineResponse40015 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40015
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40016
 */
export interface InlineResponse40016 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40016
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40017
 */
export interface InlineResponse40017 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40017
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40018
 */
export interface InlineResponse40018 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40018
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40019
 */
export interface InlineResponse40019 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40019
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4002
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4003
 */
export interface InlineResponse4003 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4003
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4004
 */
export interface InlineResponse4004 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4004
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4005
 */
export interface InlineResponse4005 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4005
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4006
 */
export interface InlineResponse4006 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4006
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4007
 */
export interface InlineResponse4007 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4007
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4008
 */
export interface InlineResponse4008 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4008
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4009
 */
export interface InlineResponse4009 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4009
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse401
     */
    detail?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse401
     */
    status?: string;
}
/**
 *
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     *
     * @type {number}
     * @memberof InlineResponse403
     */
    code?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse403
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4031
 */
export interface InlineResponse4031 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4031
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4032
 */
export interface InlineResponse4032 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4032
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4033
 */
export interface InlineResponse4033 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4033
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4034
 */
export interface InlineResponse4034 {
}
/**
 *
 * @export
 * @interface InlineResponse4035
 */
export interface InlineResponse4035 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4035
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4036
 */
export interface InlineResponse4036 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4036
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4037
 */
export interface InlineResponse4037 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4037
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4038
 */
export interface InlineResponse4038 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4038
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4039
 */
export interface InlineResponse4039 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4039
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse404
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4041
 */
export interface InlineResponse4041 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4041
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40410
 */
export interface InlineResponse40410 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40410
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40411
 */
export interface InlineResponse40411 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40411
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40412
 */
export interface InlineResponse40412 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse40412
     */
    details?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse40412
     */
    status?: string;
}
/**
 *
 * @export
 * @interface InlineResponse40413
 */
export interface InlineResponse40413 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40413
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40414
 */
export interface InlineResponse40414 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40414
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40415
 */
export interface InlineResponse40415 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40415
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse40416
 */
export interface InlineResponse40416 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse40416
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4042
 */
export interface InlineResponse4042 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4042
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4043
 */
export interface InlineResponse4043 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4043
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4044
 */
export interface InlineResponse4044 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4044
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4045
 */
export interface InlineResponse4045 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4045
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4046
 */
export interface InlineResponse4046 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4046
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4047
 */
export interface InlineResponse4047 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4047
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4048
 */
export interface InlineResponse4048 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4048
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse4049
 */
export interface InlineResponse4049 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4049
     */
    errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse409
 */
export interface InlineResponse409 {
    /**
     *
     * @type {string}
     * @memberof InlineResponse409
     */
    detail?: string;
    /**
     *
     * @type {string}
     * @memberof InlineResponse409
     */
    status?: string;
}
/**
 *
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse422
     */
    errors?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof InlineResponse422
     */
    code?: number;
}
/**
 *
 * @export
 * @interface InlineResponse4221
 */
export interface InlineResponse4221 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4221
     */
    errors?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof InlineResponse4221
     */
    code?: number;
}
/**
 *
 * @export
 * @interface InlineResponse4222
 */
export interface InlineResponse4222 {
    /**
     *
     * @type {Array<string>}
     * @memberof InlineResponse4222
     */
    errors?: Array<string>;
}
/**
 * Descriptions of the various actions supported by the integration.
 * @export
 * @interface IntegrationsActions
 */
export interface IntegrationsActions {
    /**
     * Description of creating an entity in the integrated service (e.g. an issue tracker ticket).
     * @type {string}
     * @memberof IntegrationsActions
     */
    create?: string;
    /**
     * Optional description of viewing an entity in the integrated service.
     * @type {string}
     * @memberof IntegrationsActions
     */
    view?: string;
    /**
     * Optional the name of a single entity in the integrated service.
     * @type {string}
     * @memberof IntegrationsActions
     */
    object?: string;
    /**
     * Optional description of adding an entity to the service to receive data (e.g. a stream, a queue, a webhook url).
     * @type {string}
     * @memberof IntegrationsActions
     */
    _new?: string;
}
/**
 * The style of this automation. Most integrations have a single 'default' style but some can have multiple.
 * @export
 * @interface IntegrationsAutomationStyle
 */
export interface IntegrationsAutomationStyle {
    /**
     * A type of the integration automation (unique within an integration).
     * @type {string}
     * @memberof IntegrationsAutomationStyle
     */
    type?: string;
    /**
     * A description of the automation style.
     * @type {string}
     * @memberof IntegrationsAutomationStyle
     */
    description?: string;
}
/**
 *
 * @export
 * @interface IntegrationsConditions
 */
export interface IntegrationsConditions {
    /**
     * The field that needs to be compared.
     * @type {string}
     * @memberof IntegrationsConditions
     */
    field?: IntegrationsConditions.FieldEnum;
    /**
     * The value the compared field needs to be set to.
     * @type {string}
     * @memberof IntegrationsConditions
     */
    value?: string;
}

/**
 * @export
 * @namespace IntegrationsConditions
 */
export namespace IntegrationsConditions {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldEnum {
        AuthenticationType = <any>'authenticationType'
    }
}
/**
 * Options for automations when an error is marked as fixed in Bugsnag.
 * @export
 * @interface IntegrationsErrorFixed
 */
export interface IntegrationsErrorFixed {
    /**
     * True if this automation has configuration options.
     * @type {boolean}
     * @memberof IntegrationsErrorFixed
     */
    configurable?: boolean;
    /**
     * Possible values for the state that may be selected.
     * @type {Array<string>}
     * @memberof IntegrationsErrorFixed
     */
    options?: Array<string>;
    /**
     * Default state for the item (only applicable if `multiple_states` is false)
     * @type {boolean}
     * @memberof IntegrationsErrorFixed
     */
    defaultOption?: boolean;
    /**
     * Default set of states for the item (only applicable if `multiple_states` is true)
     * @type {Array<string>}
     * @memberof IntegrationsErrorFixed
     */
    defaultOptions?: Array<string>;
    /**
     * True if multiple states can be selected for this automation.
     * @type {boolean}
     * @memberof IntegrationsErrorFixed
     */
    multipleStates?: boolean;
}
/**
 * Options for automations when a new error is received by Bugsnag.
 * @export
 * @interface IntegrationsErrorNew
 */
export interface IntegrationsErrorNew {
    /**
     * True if this automation has configuration options.
     * @type {boolean}
     * @memberof IntegrationsErrorNew
     */
    configurable?: boolean;
    /**
     * Possible values for the state that may be selected.
     * @type {Array<string>}
     * @memberof IntegrationsErrorNew
     */
    options?: Array<string>;
    /**
     * Default state for the item (only applicable if `multiple_states` is false)
     * @type {boolean}
     * @memberof IntegrationsErrorNew
     */
    defaultOption?: boolean;
    /**
     * Default set of states for the item (only applicable if `multiple_states` is true)
     * @type {Array<string>}
     * @memberof IntegrationsErrorNew
     */
    defaultOptions?: Array<string>;
    /**
     * True if multiple states can be selected for this automation.
     * @type {boolean}
     * @memberof IntegrationsErrorNew
     */
    multipleStates?: boolean;
}
/**
 * Options for automations when an error is reopened in Bugsnag.
 * @export
 * @interface IntegrationsErrorReopened
 */
export interface IntegrationsErrorReopened {
    /**
     * True if this automation has configuration options.
     * @type {boolean}
     * @memberof IntegrationsErrorReopened
     */
    configurable?: boolean;
    /**
     * Possible values for the state that may be selected.
     * @type {Array<string>}
     * @memberof IntegrationsErrorReopened
     */
    options?: Array<string>;
    /**
     * Default state for the item (only applicable if `multiple_states` is false)
     * @type {boolean}
     * @memberof IntegrationsErrorReopened
     */
    defaultOption?: boolean;
    /**
     * Default set of states for the item (only applicable if `multiple_states` is true)
     * @type {Array<string>}
     * @memberof IntegrationsErrorReopened
     */
    defaultOptions?: Array<string>;
    /**
     * True if multiple states can be selected for this automation.
     * @type {boolean}
     * @memberof IntegrationsErrorReopened
     */
    multipleStates?: boolean;
}
/**
 *
 * @export
 * @interface IntegrationsFields
 */
export interface IntegrationsFields {
    /**
     * The unique name of the field.
     * @type {string}
     * @memberof IntegrationsFields
     */
    name?: string;
    /**
     * The human readable name of the field.
     * @type {string}
     * @memberof IntegrationsFields
     */
    label?: string;
    /**
     * The human readable description of the field.
     * @type {string}
     * @memberof IntegrationsFields
     */
    description?: string;
    /**
     * A URL that helps with finding the value associated with the field.
     * @type {string}
     * @memberof IntegrationsFields
     */
    link?: string;
    /**
     * True if the field is optional for an integration (defaults to false).
     * @type {boolean}
     * @memberof IntegrationsFields
     */
    optional?: boolean;
    /**
     * The default value of the field if the field is optional.
     * @type {string}
     * @memberof IntegrationsFields
     */
    defaultValue?: string;
    /**
     * An array of values that are permitted for the field (required when the `type` is `select` only).
     * @type {Array<string>}
     * @memberof IntegrationsFields
     */
    allowedValues?: Array<string>;
    /**
     * The input type of the field (defaults to text input if not provided). - password - A string value but a dummy value will be returned after it is initially saved. Intended for sensitive information. - select - An option to select one of the `allowed_values`. - boolean - A boolean value either 'true' or 'false'. - toggle - An option to toggle between one of the `allowed_values`
     * @type {string}
     * @memberof IntegrationsFields
     */
    type?: IntegrationsFields.TypeEnum;
    /**
     * The value of the field (not present when retrieving general information about fields for an integration).
     * @type {string}
     * @memberof IntegrationsFields
     */
    value?: string;
    /**
     * The regular expression pattern which values are required to match if supplied.
     * @type {string}
     * @memberof IntegrationsFields
     */
    pattern?: string;
    /**
     * True if the field is deprecated and should not be used.
     * @type {boolean}
     * @memberof IntegrationsFields
     */
    deprecated?: boolean;
    /**
     * An array of conditions that must be met for the field to be submitted.
     * @type {Array<IntegrationsConditions>}
     * @memberof IntegrationsFields
     */
    conditions?: Array<IntegrationsConditions>;
}

/**
 * @export
 * @namespace IntegrationsFields
 */
export namespace IntegrationsFields {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Password = <any>'password',
        Select = <any>'select',
        Boolean = <any>'boolean',
        Toggle = <any>'toggle'
    }
}
/**
 *
 * @export
 * @interface IntegrationsIssueAutomationOptions
 */
export interface IntegrationsIssueAutomationOptions {
    /**
     *
     * @type {IntegrationsAutomationStyle}
     * @memberof IntegrationsIssueAutomationOptions
     */
    automationStyle?: IntegrationsAutomationStyle;
    /**
     *
     * @type {IntegrationsErrorNew}
     * @memberof IntegrationsIssueAutomationOptions
     */
    errorNew?: IntegrationsErrorNew;
    /**
     *
     * @type {IntegrationsErrorFixed}
     * @memberof IntegrationsIssueAutomationOptions
     */
    errorFixed?: IntegrationsErrorFixed;
    /**
     *
     * @type {IntegrationsErrorReopened}
     * @memberof IntegrationsIssueAutomationOptions
     */
    errorReopened?: IntegrationsErrorReopened;
    /**
     *
     * @type {IntegrationsIssueResolved}
     * @memberof IntegrationsIssueAutomationOptions
     */
    issueResolved?: IntegrationsIssueResolved;
    /**
     *
     * @type {IntegrationsIssueUnresolved}
     * @memberof IntegrationsIssueAutomationOptions
     */
    issueUnresolved?: IntegrationsIssueUnresolved;
}
/**
 * Options for automations when an issue is resolved in a configured issue tracker.
 * @export
 * @interface IntegrationsIssueResolved
 */
export interface IntegrationsIssueResolved {
    /**
     * True if this automation has configuration options.
     * @type {boolean}
     * @memberof IntegrationsIssueResolved
     */
    configurable?: boolean;
    /**
     * Possible values for the state that may be selected.
     * @type {Array<string>}
     * @memberof IntegrationsIssueResolved
     */
    options?: Array<string>;
    /**
     * Default state for the item (only applicable if `multiple_states` is false)
     * @type {boolean}
     * @memberof IntegrationsIssueResolved
     */
    defaultOption?: boolean;
    /**
     * Default set of states for the item (only applicable if `multiple_states` is true)
     * @type {Array<string>}
     * @memberof IntegrationsIssueResolved
     */
    defaultOptions?: Array<string>;
    /**
     * True if multiple states can be selected for this automation.
     * @type {boolean}
     * @memberof IntegrationsIssueResolved
     */
    multipleStates?: boolean;
}
/**
 * Options for automations when an issue is unresolved in a configured issue tracker.
 * @export
 * @interface IntegrationsIssueUnresolved
 */
export interface IntegrationsIssueUnresolved {
    /**
     * True if this automation has configuration options.
     * @type {boolean}
     * @memberof IntegrationsIssueUnresolved
     */
    configurable?: boolean;
    /**
     * Possible values for the state that may be selected.
     * @type {Array<string>}
     * @memberof IntegrationsIssueUnresolved
     */
    options?: Array<string>;
    /**
     * Default state for the item (only applicable if `multiple_states` is false)
     * @type {boolean}
     * @memberof IntegrationsIssueUnresolved
     */
    defaultOption?: boolean;
    /**
     * Default set of states for the item (only applicable if `multiple_states` is true)
     * @type {Array<string>}
     * @memberof IntegrationsIssueUnresolved
     */
    defaultOptions?: Array<string>;
    /**
     * True if multiple states can be selected for this automation.
     * @type {boolean}
     * @memberof IntegrationsIssueUnresolved
     */
    multipleStates?: boolean;
}
/**
 *
 * @export
 * @interface IntegrationsTestBody
 */
export interface IntegrationsTestBody {
    /**
     * The key of the integration service to test. The supported keys can be obtained from [/integrations](/insight-hub/docs/data-access-api-v-2#/Integrations/get_integrations)
     * @type {string}
     * @memberof IntegrationsTestBody
     */
    key: string;
    /**
     *
     * @type {IntegrationstestConfiguration}
     * @memberof IntegrationsTestBody
     */
    configuration: IntegrationstestConfiguration;
}
/**
 * The configuration fields and their values to test the integration with. The required fields for each integration service can be obtained from [/integrations](/insight-hub/docs/data-access-api-v-2#/Integrations/get_integrations).
 * @export
 * @interface IntegrationstestConfiguration
 */
export interface IntegrationstestConfiguration {
    /**
     *
     * @type {string}
     * @memberof IntegrationstestConfiguration
     */
    userName?: string;
    /**
     *
     * @type {string}
     * @memberof IntegrationstestConfiguration
     */
    projectId?: string;
    /**
     *
     * @type {string}
     * @memberof IntegrationstestConfiguration
     */
    password?: string;
}
/**
 *
 * @export
 * @interface OrganizationIdCollaboratorsBody
 */
export interface OrganizationIdCollaboratorsBody {
    /**
     * The email of the person to invite
     * @type {string}
     * @memberof OrganizationIdCollaboratorsBody
     */
    email: string;
    /**
     * A name for the invited user
     * @type {string}
     * @memberof OrganizationIdCollaboratorsBody
     */
    name?: string;
    /**
     * A password for the invited user
     * @type {string}
     * @memberof OrganizationIdCollaboratorsBody
     */
    password?: string;
    /**
     * The ids of projects in the current organization that the invited user should have access to.
     * @type {Array<string>}
     * @memberof OrganizationIdCollaboratorsBody
     */
    projectIds?: Array<string>;
    /**
     * The IDs of the projects to which the user should have access, and the roles they should have, either 'project_owner' or 'project_member'.
     * @type {{ [key: string]: string; }}
     * @memberof OrganizationIdCollaboratorsBody
     */
    projectRoles?: { [key: string]: string; };
    /**
     * Whether to give admin permissions to the invited user.
     * @type {boolean}
     * @memberof OrganizationIdCollaboratorsBody
     */
    admin?: boolean;
}
/**
 *
 * @export
 * @interface OrganizationIdEventDataDeletionsBody
 */
export interface OrganizationIdEventDataDeletionsBody {
    /**
     * whether to skip requiring another request to confirm the deletion
     * @type {boolean}
     * @memberof OrganizationIdEventDataDeletionsBody
     */
    skipConfirmation?: boolean;
    /**
     *
     * @type {OrganizationsorganizationIdeventDataDeletionsFilters}
     * @memberof OrganizationIdEventDataDeletionsBody
     */
    filters: OrganizationsorganizationIdeventDataDeletionsFilters;
}
/**
 *
 * @export
 * @interface OrganizationIdEventDataRequestsBody
 */
export interface OrganizationIdEventDataRequestsBody {
    /**
     * the type of report to request; omit this if you want all event fields
     * @type {string}
     * @memberof OrganizationIdEventDataRequestsBody
     */
    reportType?: OrganizationIdEventDataRequestsBody.ReportTypeEnum;
    /**
     *
     * @type {OrganizationsorganizationIdeventDataRequestsFilters}
     * @memberof OrganizationIdEventDataRequestsBody
     */
    filters: OrganizationsorganizationIdeventDataRequestsFilters;
}

/**
 * @export
 * @namespace OrganizationIdEventDataRequestsBody
 */
export namespace OrganizationIdEventDataRequestsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum ReportTypeEnum {
        Gdpr = <any>'gdpr'
    }
}
/**
 *
 * @export
 * @interface OrganizationIdProjectsBody
 */
export interface OrganizationIdProjectsBody {
    /**
     * The new Project's name. Note that the first character should not start with a '$'.
     * @type {string}
     * @memberof OrganizationIdProjectsBody
     */
    name: string;
    /**
     * used for Projects that use a framework other than those listed above
     * @type {string}
     * @memberof OrganizationIdProjectsBody
     */
    type: OrganizationIdProjectsBody.TypeEnum;
    /**
     * For javascript projects this will filter errors from older browsers
     * @type {boolean}
     * @memberof OrganizationIdProjectsBody
     */
    ignoreOldBrowsers?: boolean;
}

/**
 * @export
 * @namespace OrganizationIdProjectsBody
 */
export namespace OrganizationIdProjectsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Android = <any>'android',
        Angular = <any>'angular',
        Asgi = <any>'asgi',
        Aspnet = <any>'aspnet',
        AspnetCore = <any>'aspnet_core',
        Backbone = <any>'backbone',
        Bottle = <any>'bottle',
        Cocos2dx = <any>'cocos2dx',
        Connect = <any>'connect',
        Django = <any>'django',
        Dotnet = <any>'dotnet',
        DotnetDesktop = <any>'dotnet_desktop',
        DotnetMvc = <any>'dotnet_mvc',
        Electron = <any>'electron',
        Ember = <any>'ember',
        Eventmachine = <any>'eventmachine',
        Expo = <any>'expo',
        Express = <any>'express',
        Flask = <any>'flask',
        Flutter = <any>'flutter',
        Gin = <any>'gin',
        Go = <any>'go',
        GoNetHttp = <any>'go_net_http',
        Heroku = <any>'heroku',
        Ios = <any>'ios',
        Java = <any>'java',
        JavaDesktop = <any>'java_desktop',
        Js = <any>'js',
        Koa = <any>'koa',
        Laravel = <any>'laravel',
        Lumen = <any>'lumen',
        Magento = <any>'magento',
        Martini = <any>'martini',
        Minidump = <any>'minidump',
        Ndk = <any>'ndk',
        Negroni = <any>'negroni',
        NintendoSwitch = <any>'nintendo_switch',
        Node = <any>'node',
        Osx = <any>'osx',
        OtherDesktop = <any>'other_desktop',
        OtherMobile = <any>'other_mobile',
        OtherTv = <any>'other_tv',
        Php = <any>'php',
        Python = <any>'python',
        Rack = <any>'rack',
        Rails = <any>'rails',
        React = <any>'react',
        Reactnative = <any>'reactnative',
        Restify = <any>'restify',
        Revel = <any>'revel',
        Ruby = <any>'ruby',
        Silex = <any>'silex',
        Sinatra = <any>'sinatra',
        Spring = <any>'spring',
        Symfony = <any>'symfony',
        Tornado = <any>'tornado',
        Tvos = <any>'tvos',
        Unity = <any>'unity',
        Unrealengine = <any>'unrealengine',
        Vue = <any>'vue',
        Watchos = <any>'watchos',
        Webapi = <any>'webapi',
        Wordpress = <any>'wordpress',
        Wpf = <any>'wpf',
        Wsgi = <any>'wsgi',
        Other = <any>'other'
    }
}
/**
 *
 * @export
 * @interface OrganizationIdTeamsBody
 */
export interface OrganizationIdTeamsBody {
    /**
     *
     * @type {string}
     * @memberof OrganizationIdTeamsBody
     */
    name: string;
}
/**
 *
 * @export
 * @interface OrganizationsBody
 */
export interface OrganizationsBody {
    /**
     * Name of the company or organization to create
     * @type {string}
     * @memberof OrganizationsBody
     */
    name: string;
}
/**
 *
 * @export
 * @interface OrganizationsIdBody
 */
export interface OrganizationsIdBody {
    /**
     *
     * @type {string}
     * @memberof OrganizationsIdBody
     */
    name: string;
    /**
     *
     * @type {Array<string>}
     * @memberof OrganizationsIdBody
     */
    billingEmails?: Array<string>;
    /**
     * whether we should upgrade your plan in response to the organization reaching its plan limit of events. If this value is `false` your events will be throttled when you reach your plan limit.
     * @type {boolean}
     * @memberof OrganizationsIdBody
     */
    autoUpgrade: boolean;
    /**
     * Additional information to print on your invoice
     * @type {string}
     * @memberof OrganizationsIdBody
     */
    invoiceAddress?: string;
    /**
     * Deprecated field. Use `invoice_address`
     * @type {string}
     * @memberof OrganizationsIdBody
     */
    invoiceInfo?: string;
}
/**
 * A mapping of project IDs to the user's role on that project. The role is either `project_owner` or `project_member`. The `project_member` role is only available on Enterprise plans, see the [Roles and Permissions documentation](https://docs.bugsnag.com/product/roles-and-permissions/) for more details.
 * @export
 * @interface OrganizationsorganizationIdcollaboratorsProjectRoles
 */
export interface OrganizationsorganizationIdcollaboratorsProjectRoles {
    /**
     *
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorsProjectRoles
     */
    _515fb9337c1074f6fd000001: string;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators
 */
export interface OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators {
    /**
     * The ID of the collaborator.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators
     */
    id?: string;
    /**
     * The name of the collaborator.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators
     */
    name?: string;
    /**
     * The collaborator's email.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators
     */
    email?: string;
    /**
     * The role the collaborator has on the project.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators
     */
    projectRole?: string;
    /**
     * Indicates if the collaborator is an administrator for the organization.
     * @type {boolean}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesCollaborators
     */
    accountAdmin?: boolean;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam
 */
export interface OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam {
    /**
     * The ID of the team.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam
     */
    id?: string;
    /**
     * The name of the team.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam
     */
    name?: string;
    /**
     * The project role the team provides to its members.
     * @type {string}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam
     */
    projectRole?: string;
    /**
     * The number of collaborators in the team.
     * @type {number}
     * @memberof OrganizationsorganizationIdcollaboratorscollaboratorIdprojectAccessesTeam
     */
    collaboratorCount?: number;
}
/**
 * The filters used to determine which events will be deleted. See [Filtering](/insight-hub/docs/filtering) for details. Note that filters with an empty string value and filters that don't apply to a project (e.g. using a custom filter from one project on another project that doesn't have that custom filter) will be skipped. Before proceeding with an event data deletion request, it's recommended to verify the [project's event fields](/insight-hub/docs/data-access-api-v-2#/Projects/get_projects__project_id__event_fields) and test your filters using the [List the Events on an Error](/insight-hub/docs/data-access-api-v-2#/Errors/get_projects__project_id__errors__error_id__events) or [Create an event data request](/insight-hub/docs/data-access-api-v-2#/Projects/post_projects__project_id__event_data_requests) API.
 * @export
 * @interface OrganizationsorganizationIdeventDataDeletionsFilters
 */
export interface OrganizationsorganizationIdeventDataDeletionsFilters {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof OrganizationsorganizationIdeventDataDeletionsFilters
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 * The filters used to determine which events will be included in the report. See [Filtering](/insight-hub/docs/filtering) for details.
 * @export
 * @interface OrganizationsorganizationIdeventDataRequestsFilters
 */
export interface OrganizationsorganizationIdeventDataRequestsFilters {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof OrganizationsorganizationIdeventDataRequestsFilters
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 * The configuration of the integration connection
 * @export
 * @interface OrganizationsorganizationIdintegrationConnectionsConfiguration
 */
export interface OrganizationsorganizationIdintegrationConnectionsConfiguration {
    /**
     *
     * @type {OrganizationsorganizationIdintegrationConnectionsConfigurationJira}
     * @memberof OrganizationsorganizationIdintegrationConnectionsConfiguration
     */
    jira?: OrganizationsorganizationIdintegrationConnectionsConfigurationJira;
}
/**
 * A jira type configuration. Currently we only allow jira types.
 * @export
 * @interface OrganizationsorganizationIdintegrationConnectionsConfigurationJira
 */
export interface OrganizationsorganizationIdintegrationConnectionsConfigurationJira {
    /**
     * A manual configuration.
     * @type {any}
     * @memberof OrganizationsorganizationIdintegrationConnectionsConfigurationJira
     */
    manual?: any;
    /**
     * The Jira host (Used as the base for API calls)
     * @type {string}
     * @memberof OrganizationsorganizationIdintegrationConnectionsConfigurationJira
     */
    host?: string;
    /**
     * (manual configuration only) The username of the Jira user to make API calls as
     * @type {string}
     * @memberof OrganizationsorganizationIdintegrationConnectionsConfigurationJira
     */
    username?: string;
    /**
     * (manual configuration only) Whether to ignore TLS validation when making API calls
     * @type {boolean}
     * @memberof OrganizationsorganizationIdintegrationConnectionsConfigurationJira
     */
    ignoreTlsValidation?: boolean;
    /**
     * (manual configuration only) The authentication type used on this connection
     * @type {string}
     * @memberof OrganizationsorganizationIdintegrationConnectionsConfigurationJira
     */
    authenticationType?: OrganizationsorganizationIdintegrationConnectionsConfigurationJira.AuthenticationTypeEnum;
}

/**
 * @export
 * @namespace OrganizationsorganizationIdintegrationConnectionsConfigurationJira
 */
export namespace OrganizationsorganizationIdintegrationConnectionsConfigurationJira {
    /**
     * @export
     * @enum {string}
     */
    export enum AuthenticationTypeEnum {
        Basic = <any>'basic',
        Bearer = <any>'bearer'
    }
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdscimv2GroupsidValue
 */
export interface OrganizationsorganizationIdscimv2GroupsidValue {
    /**
     * the id of a BugSnag collaborators in the org
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2GroupsidValue
     */
    value: string;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdscimv2UsersidEmails
 */
export interface OrganizationsorganizationIdscimv2UsersidEmails {
    /**
     *
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2UsersidEmails
     */
    value: string;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdscimv2UsersidName
 */
export interface OrganizationsorganizationIdscimv2UsersidName {
    /**
     *
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2UsersidName
     */
    formatted?: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2UsersidName
     */
    givenName: string;
    /**
     *
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2UsersidName
     */
    familyName: string;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdscimv2UsersidOperations
 */
export interface OrganizationsorganizationIdscimv2UsersidOperations {
    /**
     * the operation to perform on the field, only `replace` is supported
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2UsersidOperations
     */
    op: string;
    /**
     * the field to update, only `active` is supported
     * @type {string}
     * @memberof OrganizationsorganizationIdscimv2UsersidOperations
     */
    path: string;
    /**
     * the value to set
     * @type {boolean}
     * @memberof OrganizationsorganizationIdscimv2UsersidOperations
     */
    value: boolean;
}
/**
 * A hash of project IDs and roles to add to the team. User making the request must be `project_owner` for all projects on the request, or an organization administrator.
 * @export
 * @interface OrganizationsorganizationIdteamsidprojectAccessesProjectRoles
 */
export interface OrganizationsorganizationIdteamsidprojectAccessesProjectRoles {
    /**
     *
     * @type {string}
     * @memberof OrganizationsorganizationIdteamsidprojectAccessesProjectRoles
     */
    _515fb9337c1074f6fd000002: OrganizationsorganizationIdteamsidprojectAccessesProjectRoles._515fb9337c1074f6fd000002Enum;
}

/**
 * @export
 * @namespace OrganizationsorganizationIdteamsidprojectAccessesProjectRoles
 */
export namespace OrganizationsorganizationIdteamsidprojectAccessesProjectRoles {
    /**
     * @export
     * @enum {string}
     */
    export enum _515fb9337c1074f6fd000002Enum {
        Owner = <any>'project_owner',
        Member = <any>'project_member'
    }
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdteamsidprojectAccessesProjectSummary
 */
export interface OrganizationsorganizationIdteamsidprojectAccessesProjectSummary {
    /**
     * The ID of the project.
     * @type {string}
     * @memberof OrganizationsorganizationIdteamsidprojectAccessesProjectSummary
     */
    id: string;
    /**
     * The name of the project.
     * @type {string}
     * @memberof OrganizationsorganizationIdteamsidprojectAccessesProjectSummary
     */
    name: string;
    /**
     * The type of the project.
     * @type {string}
     * @memberof OrganizationsorganizationIdteamsidprojectAccessesProjectSummary
     */
    type: string;
    /**
     * The project's slug.
     * @type {string}
     * @memberof OrganizationsorganizationIdteamsidprojectAccessesProjectSummary
     */
    slug: string;
}
/**
 * Additional metadata for the span
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansMetadata
 */
export interface OrganizationsorganizationIdtracestraceIdspansMetadata {
    /**
     * The key of the metadata
     * @type {string}
     * @memberof OrganizationsorganizationIdtracestraceIdspansMetadata
     */
    key: string;
    /**
     * The value of the metadata. May be a string or an integer.
     * @type {string}
     * @memberof OrganizationsorganizationIdtracestraceIdspansMetadata
     */
    value: string;
    /**
     * The location of the metadata attribute within the Trace payload
     * @type {string}
     * @memberof OrganizationsorganizationIdtracestraceIdspansMetadata
     */
    level: OrganizationsorganizationIdtracestraceIdspansMetadata.LevelEnum;
}

/**
 * @export
 * @namespace OrganizationsorganizationIdtracestraceIdspansMetadata
 */
export namespace OrganizationsorganizationIdtracestraceIdspansMetadata {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Unspecified = <any>'unspecified',
        Resource = <any>'resource',
        Span = <any>'span'
    }
}
/**
 * Any additional statistics for the span
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatistics
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatistics {
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatistics}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatistics
     */
    categoryStatistics?: OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatistics;
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatistics}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatistics
     */
    systemMetricStatistics?: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatistics;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatistics
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatistics {
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatistics
     */
    fullPageLoad?: OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad {
    /**
     * The largest contentful paint time in milliseconds
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
     */
    largestContentfulPaint?: number;
    /**
     * The first input delay time in milliseconds
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
     */
    firstInputDelay?: number;
    /**
     * The time the first input delay ended
     * @type {string}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
     */
    firstInputDelayEndedAt?: string;
    /**
     * Measure of how often visible elements move unexpectedly
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
     */
    cumulativeLayoutShift?: number;
    /**
     * The time to first byte in milliseconds
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
     */
    timeToFirstByte?: number;
    /**
     * The first contentful paint time in milliseconds
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsCategoryStatisticsFullPageLoad
     */
    firstContentfulPaint?: number;
}
/**
 *
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatistics
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatistics {
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpu}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatistics
     */
    cpu?: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpu;
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemory}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatistics
     */
    memory?: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemory;
}
/**
 * Details about the CPU usage of the Span
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpu
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpu {
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuTotal}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpu
     */
    total: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuTotal;
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuMainThread}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpu
     */
    mainThread: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuMainThread;
}
/**
 * Details of the main thread CPU usage measured at intervals across the Span's lifetime
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuMainThread
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuMainThread {
    /**
     * The mean value of the measurements (as a percentage)
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuMainThread
     */
    mean: number;
}
/**
 * Details of the total CPU usage measured at intervals across the Span's lifetime
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuTotal
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuTotal {
    /**
     * The mean value of the measurements (as a percentage)
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsCpuTotal
     */
    mean: number;
}
/**
 * Details about the device memory of the Span
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemory
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemory {
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryDevice}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemory
     */
    device: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryDevice;
    /**
     *
     * @type {OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryAndroidRuntime}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemory
     */
    androidRuntime?: OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryAndroidRuntime;
}
/**
 * Details of the Android Runtime memory measured at intervals across the Span's lifetime
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryAndroidRuntime
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryAndroidRuntime {
    /**
     * The mean value of the measurements (in bytes)
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryAndroidRuntime
     */
    mean: number;
}
/**
 * Details of the device memory measured at intervals across the Span's lifetime
 * @export
 * @interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryDevice
 */
export interface OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryDevice {
    /**
     * The mean value of the measurements (in bytes)
     * @type {number}
     * @memberof OrganizationsorganizationIdtracestraceIdspansStatisticsSystemMetricStatisticsMemoryDevice
     */
    mean: number;
}
/**
 *
 * @export
 * @interface ProjectIdConfiguredIntegrationsBody
 */
export interface ProjectIdConfiguredIntegrationsBody {
    /**
     * Key to identify the integration service.
     * @type {string}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    integrationKey: string;
    /**
     *
     * @type {ConfiguredIntegrationsidConfiguration}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    configuration: ConfiguredIntegrationsidConfiguration;
    /**
     * The release stages that this notification should not be triggered for. Example: { \"disable_release_stages\": [\"development\", \"staging\"] }
     * @type {Array<string>}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    disableReleaseStages?: Array<string>;
    /**
     * The severities that this notification should not be triggered for.
     * @type {Array<string>}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    disableSeverities?: Array<ProjectIdConfiguredIntegrationsBody.DisableSeveritiesEnum>;
    /**
     * The kinds of exceptions that this notification should not be triggered for.
     * @type {Array<string>}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    disableUnhandledStates?: Array<ProjectIdConfiguredIntegrationsBody.DisableUnhandledStatesEnum>;
    /**
     *
     * @type {ConfiguredIntegrationsidIssueAutomation}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    issueAutomation?: ConfiguredIntegrationsidIssueAutomation;
    /**
     * A label for use in identifying the issue tracker.
     * @type {string}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    label?: string;
    /**
     * The id of the integration connection to base this configured integration off of.
     * @type {string}
     * @memberof ProjectIdConfiguredIntegrationsBody
     */
    integrationConnectionId?: string;
}

/**
 * @export
 * @namespace ProjectIdConfiguredIntegrationsBody
 */
export namespace ProjectIdConfiguredIntegrationsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum DisableSeveritiesEnum {
        Error = <any>'error',
        Warning = <any>'warning',
        Info = <any>'info'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DisableUnhandledStatesEnum {
        Unhandled = <any>'unhandled',
        Handled = <any>'handled'
    }
}
/**
 *
 * @export
 * @interface ProjectIdErrorAssignmentRulesBody
 */
export interface ProjectIdErrorAssignmentRulesBody {
    /**
     *
     * @type {Array<ProjectsprojectIderrorAssignmentRulesAssignmentRules>}
     * @memberof ProjectIdErrorAssignmentRulesBody
     */
    assignmentRules?: Array<ProjectsprojectIderrorAssignmentRulesAssignmentRules>;
}
/**
 *
 * @export
 * @interface ProjectIdErrorsBody
 */
export interface ProjectIdErrorsBody {
    /**
     * The Error's new severity. This will be reflected in the Error's `overridden_severity` property. This is only applicable if the `override_severity` option is provided.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    severity?: ProjectIdErrorsBody.SeverityEnum;
    /**
     * The type of update operation to perform. The can be used to change the Error's workflow state (e.g. marking the Error as `fixed`). It must be one of the following: * `override_severity`   Set the Error's severity to the newly supplied `severity` parameter. * `assign`   Assign the Error to the Collaborator specified by the `assigned_collaborator_id` parameter. The error will be unassigned if `assigned_collaborator_id` is blank, the identified Collaborator has not accepted their invitation, or they do not have access to the Error's Project. * `create_issue`   Create an issue for the Error. If the `issue_title` parameter is set, the new issue will be created with this title. * `link_issue`   Link the Error to an existing issue. The url should be provided in the `issue_url` parameter. `verify_issue_url` can be set to control whether Bugsnag should attempt to verify the issue URL with any configured issue tracker integration. This is the default behaviour if `verify_issue_url` is not supplied. * `unlink_issue`   Remove the link between the Error and its current linked issue. * open   Set the Error's status to open. * `snooze`   Snooze the error per the `reopen_rules` parameter. * `fix`   Set the Error's status to fixed. * `ignore`   Ignore the Error. Errors that are ignored and can only be reopened manually. Events are collected, but no notifications are sent. * `delete`   Delete the Error. The Error and all related Events will be removed from Bugsnag. If the error occurs again, it will appear as a new Error with status `Open`. * `discard`   Discard future Events for this Error. The Error and all existing Events will remain in Bugsnag, but future occurrences of the Error will not be stored by Bugsnag or count toward Event usage limits. * `undiscard`   Undiscard the Error. Future Events will be stored for this Error. This undoes the `discard` option.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    operation: ProjectIdErrorsBody.OperationEnum;
    /**
     * The Collaborator to assign to the Error. Errors may be assigned only to users who have accepted their Bugsnag invitation and have access to the project.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    assignedCollaboratorId?: string;
    /**
     * The Team to assign to the Error. Mutually exclusive with `assigned_collaborator_id`.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    assignedTeamId?: string;
    /**
     * Specifies the HTTP link to an external issue when adding or updating a link.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    issueUrl?: string;
    /**
     * Setting `false` will prevent Bugsnag from attempting to verify the `issue_url` with the configured issue tracker when linking an issue. Defaults to `true` if the parameter is not supplied. If no configured issue tracker the parameter is ignored.
     * @type {boolean}
     * @memberof ProjectIdErrorsBody
     */
    verifyIssueUrl?: boolean;
    /**
     * If the Error has a `created_issue`, the `issue_title` request field can be set to update the issue's title.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    issueTitle?: string;
    /**
     * ID of the issue tracker to use for `create_issue` and `link_issue` operations. The most recent issue tracker is used if the parameter is omitted, and no issue tracker is used even if `notification_id` is set for `link_issue` operations if `verify_issue_url` is `false`.
     * @type {string}
     * @memberof ProjectIdErrorsBody
     */
    notificationId?: string;
    /**
     *
     * @type {ProjectsprojectIderrorsReopenRules}
     * @memberof ProjectIdErrorsBody
     */
    reopenRules?: ProjectsprojectIderrorsReopenRules;
}

/**
 * @export
 * @namespace ProjectIdErrorsBody
 */
export namespace ProjectIdErrorsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        OverrideSeverity = <any>'override_severity',
        Assign = <any>'assign',
        CreateIssue = <any>'create_issue',
        LinkIssue = <any>'link_issue',
        UnlinkIssue = <any>'unlink_issue',
        Open = <any>'open',
        Snooze = <any>'snooze',
        Fix = <any>'fix',
        Ignore = <any>'ignore',
        Delete = <any>'delete',
        Discard = <any>'discard',
        Undiscard = <any>'undiscard'
    }
}
/**
 *
 * @export
 * @interface ProjectIdEventDataDeletionsBody
 */
export interface ProjectIdEventDataDeletionsBody {
    /**
     * whether to skip requiring another request to confirm the deletion
     * @type {boolean}
     * @memberof ProjectIdEventDataDeletionsBody
     */
    skipConfirmation?: boolean;
    /**
     *
     * @type {OrganizationsorganizationIdeventDataDeletionsFilters}
     * @memberof ProjectIdEventDataDeletionsBody
     */
    filters: OrganizationsorganizationIdeventDataDeletionsFilters;
}
/**
 *
 * @export
 * @interface ProjectIdEventDataRequestsBody
 */
export interface ProjectIdEventDataRequestsBody {
    /**
     * the type of report to request; omit this if you want all event fields
     * @type {string}
     * @memberof ProjectIdEventDataRequestsBody
     */
    reportType?: ProjectIdEventDataRequestsBody.ReportTypeEnum;
    /**
     *
     * @type {OrganizationsorganizationIdeventDataRequestsFilters}
     * @memberof ProjectIdEventDataRequestsBody
     */
    filters: OrganizationsorganizationIdeventDataRequestsFilters;
}

/**
 * @export
 * @namespace ProjectIdEventDataRequestsBody
 */
export namespace ProjectIdEventDataRequestsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum ReportTypeEnum {
        Gdpr = <any>'gdpr'
    }
}
/**
 *
 * @export
 * @interface ProjectIdEventFieldsBody
 */
export interface ProjectIdEventFieldsBody {
    /**
     * [Path](https://docs.bugsnag.com/product/custom-filters/advanced-custom-filters/#custom-filter-path) to locate the relevant data inside an Event data structure
     * @type {string}
     * @memberof ProjectIdEventFieldsBody
     */
    path: string;
    /**
     * Whether to reindex historical events for this field
     * @type {boolean}
     * @memberof ProjectIdEventFieldsBody
     */
    reindex?: boolean;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsFilterOptions1}
     * @memberof ProjectIdEventFieldsBody
     */
    filterOptions: ProjectsprojectIdeventFieldsFilterOptions1;
    /**
     *
     * @type {ProjectsprojectIdeventFieldsPivotOptions1}
     * @memberof ProjectIdEventFieldsBody
     */
    pivotOptions?: ProjectsprojectIdeventFieldsPivotOptions1;
}
/**
 *
 * @export
 * @interface ProjectIdNetworkEndpointGroupingBody
 */
export interface ProjectIdNetworkEndpointGroupingBody {
    /**
     * The URL patterns by which network spans are grouped.
     * @type {Array<string>}
     * @memberof ProjectIdNetworkEndpointGroupingBody
     */
    endpoints: Array<string>;
}
/**
 *
 * @export
 * @interface ProjectIdStarredFeatureFlagsBody
 */
export interface ProjectIdStarredFeatureFlagsBody {
    /**
     * ID of the Feature Flag to star.
     * @type {string}
     * @memberof ProjectIdStarredFeatureFlagsBody
     */
    featureFlagId: string;
}
/**
 *
 * @export
 * @interface ProjectsProjectIdBody
 */
export interface ProjectsProjectIdBody {
    /**
     *
     * @type {string}
     * @memberof ProjectsProjectIdBody
     */
    name?: string;
    /**
     * A list of error classes. Events with these classes will be grouped by their class, regardless of the location that they occur in the Project's source code. Altering a Project's `global_grouping` will not cause existing errors to be regrouped.  Note: In the UI this is referred to as grouping by error class.  Example:  ``` [\"foo\", \"bar\"] ```
     * @type {Array<string>}
     * @memberof ProjectsProjectIdBody
     */
    globalGrouping?: Array<string>;
    /**
     * A list of error classes. Events with these classes will be grouped by their `context`. Altering a Project's `location_grouping` will not cause existing errors to be regrouped.  Note: In the UI this is referred to as grouping by error context.
     * @type {Array<string>}
     * @memberof ProjectsProjectIdBody
     */
    locationGrouping?: Array<string>;
    /**
     * A list of app versions whose events will be [discarded](https://docs.bugsnag.com/product/event-usage/#discard-by-app-version) if received for the Project. Supports [regular expressions](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions) and [semver ranges](https://github.com/npm/node-semver#ranges). Errors matching these versions won't be processed by Bugsnag, and you won't receive notifications about them.
     * @type {Array<string>}
     * @memberof ProjectsProjectIdBody
     */
    discardedAppVersions?: Array<string>;
    /**
     * A list of Error classes whose events will be [discarded](https://docs.bugsnag.com/product/event-usage/#discard-by-error-class) if received for the Project. Errors with these classes won't be processed by Bugsnag, and you won't receive notifications about them.
     * @type {Array<string>}
     * @memberof ProjectsProjectIdBody
     */
    discardedErrors?: Array<string>;
    /**
     * When configured, the script source of each error's innermost stack trace's top frame is checked. If the script was not served from a matching domain the error will not be processed by BugSnag and will be discarded.  Provide a list of newline separated domain names. To match example.com and its subdomains specify *.example.com.  Relevant to JavaScript Projects only.
     * @type {Array<string>}
     * @memberof ProjectsProjectIdBody
     */
    urlWhitelist?: Array<string>;
    /**
     * Whether the Events in the Project will be ignored if they originate from old web browsers.  Relevant to JavaScript Projects only.
     * @type {boolean}
     * @memberof ProjectsProjectIdBody
     */
    ignoreOldBrowsers?: boolean;
    /**
     * Relevant to JavaScript Projects only.  A mapping a of browser name to browser version. If set, Events in the Project will be ignored if they originate from a browser specified here whose version is earlier than the given version.  Keys must be one of the following strings: chrome, ie, firefox, safari, android, uc, opera, opera_mini, samsung, blackberry, sogou, other.  Values must be a number indicating which which version to ignore up to (but not including), or one of the strings: `ignore_all`, `ignore_none`  Example:  ``` { \"chrome\": \"ignore_none\", \"safari\": 6, \"other\": \"ignore_all\" } ```
     * @type {any}
     * @memberof ProjectsProjectIdBody
     */
    ignoredBrowserVersions?: any;
    /**
     * If true, every error in the Project will be marked as 'fixed' after using the Deploy Tracking API to notify Bugsnag of a new production deploy.  Applies to non-JavaScript Projects only.
     * @type {boolean}
     * @memberof ProjectsProjectIdBody
     */
    resolveOnDeploy?: boolean;
    /**
     * If provided in the request, the Project will be updated so that its set of Collaborators will reflect those indicated by this list of ids. Existing Collaborators whose ids do not appear in the list will be removed from the Project.
     * @type {Array<string>}
     * @memberof ProjectsProjectIdBody
     */
    collaboratorIds?: Array<string>;
}
/**
 * The assignee Team or User details.
 * @export
 * @interface ProjectsprojectIderrorAssignmentRulesAssignee
 */
export interface ProjectsprojectIderrorAssignmentRulesAssignee {
    /**
     * Whether the rule will assign to a team or a specific user.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesAssignee
     */
    type: ProjectsprojectIderrorAssignmentRulesAssignee.TypeEnum;
    /**
     * The ID of the User or Team being assigned the rule.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesAssignee
     */
    id: string;
}

/**
 * @export
 * @namespace ProjectsprojectIderrorAssignmentRulesAssignee
 */
export namespace ProjectsprojectIderrorAssignmentRulesAssignee {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        User = <any>'user',
        Team = <any>'team'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIderrorAssignmentRulesAssignmentRules
 */
export interface ProjectsprojectIderrorAssignmentRulesAssignmentRules {
    /**
     *
     * @type {ProjectsprojectIderrorAssignmentRulesAssignee}
     * @memberof ProjectsprojectIderrorAssignmentRulesAssignmentRules
     */
    assignee: ProjectsprojectIderrorAssignmentRulesAssignee;
    /**
     *
     * @type {ProjectsprojectIderrorAssignmentRulesPattern}
     * @memberof ProjectsprojectIderrorAssignmentRulesAssignmentRules
     */
    pattern: ProjectsprojectIderrorAssignmentRulesPattern;
    /**
     * Freeform text about the rule.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesAssignmentRules
     */
    comment?: string;
}
/**
 * The matching logic to apply to the rule scope.
 * @export
 * @interface ProjectsprojectIderrorAssignmentRulesPattern
 */
export interface ProjectsprojectIderrorAssignmentRulesPattern {
    /**
     * The pattern variant.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesPattern
     */
    type: ProjectsprojectIderrorAssignmentRulesPattern.TypeEnum;
    /**
     * The file glob or dot notation payload path that, when matched, will activate the path.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesPattern
     */
    scope: string;
    /**
     * The value to match to the resolved scope - required for payload_path matches, unset for file_path and code_method matches.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesPattern
     */
    matchValue?: string;
    /**
     * Whether to match on any line or only the first line - required for file_path and code_method matches, unset for payload_path mathces.
     * @type {string}
     * @memberof ProjectsprojectIderrorAssignmentRulesPattern
     */
    matchFrame?: ProjectsprojectIderrorAssignmentRulesPattern.MatchFrameEnum;
}

/**
 * @export
 * @namespace ProjectsprojectIderrorAssignmentRulesPattern
 */
export namespace ProjectsprojectIderrorAssignmentRulesPattern {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PayloadPath = <any>'payload_path',
        FilePath = <any>'file_path',
        CodeMethod = <any>'code_method'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MatchFrameEnum {
        Any = <any>'any',
        First = <any>'first'
    }
}
/**
 * Snooze rules for automatically reopening the Error
 * @export
 * @interface ProjectsprojectIderrorsReopenRules
 */
export interface ProjectsprojectIderrorsReopenRules {
    /**
     * Must be one of the following: - `occurs_after` - Indicates that the error should be reopened if there are any occurrences after the specified time period. In this case, the `seconds` field must also be provided. - `n_occurrences_in_m_hours` - Indicates that the Error should be reopened after n occurrences over some period of hours. In this case, the `occurrences` and `hours` fields will both be present. - `n_additional_occurrences` - Indicates that the Error should be reopened after n more occurrences. In this case, the `additional_occurrences` field indicates the number of additional occurrences that were allowed before reopening. Cannot be set if more than 10,000 existing users are already affected by an error. - `n_additional_users` - Reopen the error after `n` more users are affected. In this case, the `additional_users` field must be provided.
     * @type {string}
     * @memberof ProjectsprojectIderrorsReopenRules
     */
    reopenIf: ProjectsprojectIderrorsReopenRules.ReopenIfEnum;
    /**
     * for `n_additional_users` reopen rules, the number of additional users to be affected by an Error before the Error is automatically reopened. Value cannot exceed 100,000.
     * @type {number}
     * @memberof ProjectsprojectIderrorsReopenRules
     */
    additionalUsers?: number;
    /**
     * for `occurs_after` reopen rules, the number of seconds that the Error should be snoozed for.
     * @type {number}
     * @memberof ProjectsprojectIderrorsReopenRules
     */
    seconds?: number;
    /**
     * for `n_occurrences_in_m_hours` reopen rules, the number of occurrences to allow in the number of hours indicated by the `hours` field, before the Error is automatically reopened.
     * @type {number}
     * @memberof ProjectsprojectIderrorsReopenRules
     */
    occurrences?: number;
    /**
     * for `n_occurrences_in_m_hours` reopen rules, the number of hours.
     * @type {number}
     * @memberof ProjectsprojectIderrorsReopenRules
     */
    hours?: number;
    /**
     * for `n_additional_occurrences` reopen rules, the number of additional occurrences allowed before reopening.
     * @type {number}
     * @memberof ProjectsprojectIderrorsReopenRules
     */
    additionalOccurrences?: number;
}

/**
 * @export
 * @namespace ProjectsprojectIderrorsReopenRules
 */
export namespace ProjectsprojectIderrorsReopenRules {
    /**
     * @export
     * @enum {string}
     */
    export enum ReopenIfEnum {
        OccursAfter = <any>'occurs_after',
        NOccurrencesInMHours = <any>'n_occurrences_in_m_hours',
        NAdditionalOccurrences = <any>'n_additional_occurrences',
        NAdditionalUsers = <any>'n_additional_users'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIderrorserrorIdeventsApp
 */
export interface ProjectsprojectIderrorserrorIdeventsApp {
    /**
     * release stage where this Event occurred
     * @type {string}
     * @memberof ProjectsprojectIderrorserrorIdeventsApp
     */
    releaseStage?: string;
    /**
     * The application type, such as a web framework or mobile platform, for example \"rails\" or \"android\".
     * @type {string}
     * @memberof ProjectsprojectIderrorserrorIdeventsApp
     */
    type?: string;
}
/**
 *
 * @export
 * @interface ProjectsprojectIderrorserrorIdpivotsList
 */
export interface ProjectsprojectIderrorserrorIdpivotsList {
    /**
     * A particular value for the given Event Field
     * @type {string}
     * @memberof ProjectsprojectIderrorserrorIdpivotsList
     */
    value?: string;
    /**
     * The number of Events that matched the provided Filters that had this value for the given Event Field
     * @type {number}
     * @memberof ProjectsprojectIderrorserrorIdpivotsList
     */
    events?: number;
}
/**
 *
 * @export
 * @interface ProjectsprojectIderrorserrorIdpivotseventFieldDisplayIdvaluesFields
 */
export interface ProjectsprojectIderrorserrorIdpivotseventFieldDisplayIdvaluesFields {
    /**
     *
     * @type {string}
     * @memberof ProjectsprojectIderrorserrorIdpivotseventFieldDisplayIdvaluesFields
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectsprojectIderrorserrorIdpivotseventFieldDisplayIdvaluesFields
     */
    name?: string;
}
/**
 *
 * @export
 * @interface ProjectsprojectIdeventFieldsFilterOptions
 */
export interface ProjectsprojectIdeventFieldsFilterOptions {
    /**
     * Human readable display name for the filter
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsFilterOptions
     */
    name: string;
    /**
     * Description of what the filter is
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsFilterOptions
     */
    description?: string;
    /**
     * Other possible names that match this field when filtering
     * @type {Array<string>}
     * @memberof ProjectsprojectIdeventFieldsFilterOptions
     */
    aliases?: Array<string>;
    /**
     * Hint text to clarify the use of the field for filtering
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsFilterOptions
     */
    hintText?: string;
    /**
     * Link to Bugsnag documentation about this filter
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsFilterOptions
     */
    hintUrl?: string;
}
/**
 *
 * @export
 * @interface ProjectsprojectIdeventFieldsFilterOptions1
 */
export interface ProjectsprojectIdeventFieldsFilterOptions1 {
    /**
     * Human readable name for the filter
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsFilterOptions1
     */
    name?: string;
}
/**
 *
 * @export
 * @interface ProjectsprojectIdeventFieldsPivotOptions
 */
export interface ProjectsprojectIdeventFieldsPivotOptions {
    /**
     * Human readable display name of the pivot.
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions
     */
    name?: string;
    /**
     * Additional fields that are displayed in the pivot tab, for example the users pivot displays user name and email in addition to ID.
     * @type {Array<ProjectsprojectIdeventFieldsValues>}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions
     */
    fields?: Array<ProjectsprojectIdeventFieldsValues>;
    /**
     * Whether this field is displayed in the error summary section of the dashboard
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions
     */
    summary?: boolean;
    /**
     * Whether this field is displayed as a pivot tab in the dashboard
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions
     */
    values?: boolean;
    /**
     * Whether the unique values of this field are calculated
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions
     */
    cardinality?: boolean;
    /**
     * Whether an average value of this field is calculated
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions
     */
    average?: boolean;
}
/**
 * Configuration for how this field will appear in pivots and on the Error page
 * @export
 * @interface ProjectsprojectIdeventFieldsPivotOptions1
 */
export interface ProjectsprojectIdeventFieldsPivotOptions1 {
    /**
     * Human readable display name of the pivot.
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions1
     */
    name?: string;
    /**
     * Additional fields that are displayed in the pivot tab, for example the users pivot displays user name and email in addition to ID.
     * @type {Array<ProjectsprojectIdeventFieldsValues>}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions1
     */
    fields?: Array<ProjectsprojectIdeventFieldsValues>;
    /**
     * Whether this field is displayed in the error summary section of the dashboard
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions1
     */
    summary?: boolean;
    /**
     * Whether this field is displayed as a pivot tab in the dashboard
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions1
     */
    values?: boolean;
    /**
     * Whether the unique values of this field are calculated
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions1
     */
    cardinality?: boolean;
    /**
     * Whether an average value of this field is calculated
     * @type {boolean}
     * @memberof ProjectsprojectIdeventFieldsPivotOptions1
     */
    average?: boolean;
}
/**
 *
 * @export
 * @interface ProjectsprojectIdeventFieldsValues
 */
export interface ProjectsprojectIdeventFieldsValues {
    /**
     * The identifier to use when filtering by this value
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsValues
     */
    id?: string;
    /**
     * A human readable represenation of this value
     * @type {string}
     * @memberof ProjectsprojectIdeventFieldsValues
     */
    name?: string;
}
/**
 * A summary of the variants for the feature flag, only present if requested.
 * @export
 * @interface ProjectsprojectIdfeatureFlagsVariantSummary
 */
export interface ProjectsprojectIdfeatureFlagsVariantSummary {
    /**
     * The number of variants that have been seen on this feature flag in the requested release stage.
     * @type {number}
     * @memberof ProjectsprojectIdfeatureFlagsVariantSummary
     */
    variantCount: number;
    /**
     * The name of the first variant (alphabetically) that has been seen on this feature flag in the requested release stage.
     * @type {string}
     * @memberof ProjectsprojectIdfeatureFlagsVariantSummary
     */
    firstVariantName?: string;
}
/**
 * Span Group of full page load spans associated with this virtual Span Group.
 * @export
 * @interface ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
 */
export interface ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup {
    /**
     * The ID of the Span Group.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    id: string;
    /**
     * The performance category of the Span Group.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    category: ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup.CategoryEnum;
    /**
     * The name of the Span Group.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    name: string;
    /**
     * The name of the Span Group for display purposes.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    displayName: string;
    /**
     * Whether the requesting user has starred the Span Group.
     * @type {boolean}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    isStarred?: boolean;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatistics}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    statistics?: ProjectsprojectIdspanGroupsStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTarget}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
     */
    performanceTarget?: ProjectsprojectIdspanGroupsPerformanceTarget;
}

/**
 * @export
 * @namespace ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup
 */
export namespace ProjectsprojectIdpageLoadSpanGroupsFullPageLoadSpanGroup {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        AppStart = <any>'app_start',
        ViewLoad = <any>'view_load',
        PageLoad = <any>'page_load',
        RouteChange = <any>'route_change',
        FullPageLoad = <any>'full_page_load',
        Network = <any>'network',
        Custom = <any>'custom',
        Navigation = <any>'navigation',
        InboundHttp = <any>'inbound_http',
        OutboundHttp = <any>'outbound_http',
        InboundRpc = <any>'inbound_rpc',
        OutboundRpc = <any>'outbound_rpc',
        CustomServer = <any>'custom_server',
        FrozenFrame = <any>'frozen_frame'
    }
}
/**
 * Span Group of route change spans associated with this virtual Span Group.
 * @export
 * @interface ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
 */
export interface ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup {
    /**
     * The ID of the Span Group.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    id: string;
    /**
     * The performance category of the Span Group.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    category: ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup.CategoryEnum;
    /**
     * The name of the Span Group.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    name: string;
    /**
     * The name of the Span Group for display purposes.
     * @type {string}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    displayName: string;
    /**
     * Whether the requesting user has starred the Span Group.
     * @type {boolean}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    isStarred?: boolean;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatistics}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    statistics?: ProjectsprojectIdspanGroupsStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTarget}
     * @memberof ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
     */
    performanceTarget?: ProjectsprojectIdspanGroupsPerformanceTarget;
}

/**
 * @export
 * @namespace ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup
 */
export namespace ProjectsprojectIdpageLoadSpanGroupsRouteChangeSpanGroup {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        AppStart = <any>'app_start',
        ViewLoad = <any>'view_load',
        PageLoad = <any>'page_load',
        RouteChange = <any>'route_change',
        FullPageLoad = <any>'full_page_load',
        Network = <any>'network',
        Custom = <any>'custom',
        Navigation = <any>'navigation',
        InboundHttp = <any>'inbound_http',
        OutboundHttp = <any>'outbound_http',
        InboundRpc = <any>'inbound_rpc',
        OutboundRpc = <any>'outbound_rpc',
        CustomServer = <any>'custom_server',
        FrozenFrame = <any>'frozen_frame'
    }
}
/**
 * source control related information about the first release of this release group
 * @export
 * @interface ProjectsprojectIdreleaseGroupsSourceControl
 */
export interface ProjectsprojectIdreleaseGroupsSourceControl {
    /**
     * the source control provider/service
     * @type {string}
     * @memberof ProjectsprojectIdreleaseGroupsSourceControl
     */
    service?: string;
    /**
     * URL to the revision/commit corresponding to the release
     * @type {string}
     * @memberof ProjectsprojectIdreleaseGroupsSourceControl
     */
    commitUrl?: string;
    /**
     * identifier for the revision of the release
     * @type {string}
     * @memberof ProjectsprojectIdreleaseGroupsSourceControl
     */
    revision?: string;
    /**
     * URL to view the changes from the previous release
     * @type {string}
     * @memberof ProjectsprojectIdreleaseGroupsSourceControl
     */
    diffUrlToPrevious?: string;
    /**
     * Previous app version for the diff
     * @type {string}
     * @memberof ProjectsprojectIdreleaseGroupsSourceControl
     */
    previousAppVersion?: string;
}
/**
 * information about this release's release stage
 * @export
 * @interface ProjectsprojectIdreleasesReleaseStage
 */
export interface ProjectsprojectIdreleasesReleaseStage {
    /**
     * name of the release stage
     * @type {string}
     * @memberof ProjectsprojectIdreleasesReleaseStage
     */
    name?: string;
}
/**
 * source control related information about the release
 * @export
 * @interface ProjectsprojectIdreleasesSourceControl
 */
export interface ProjectsprojectIdreleasesSourceControl {
    /**
     * the source control provider/service
     * @type {string}
     * @memberof ProjectsprojectIdreleasesSourceControl
     */
    service?: string;
    /**
     * URL to the revision/commit corresponding to the release
     * @type {string}
     * @memberof ProjectsprojectIdreleasesSourceControl
     */
    commitUrl?: string;
    /**
     * identifier for the revision of the release
     * @type {string}
     * @memberof ProjectsprojectIdreleasesSourceControl
     */
    revision?: string;
    /**
     * URL to view the changes from the previous release
     * @type {string}
     * @memberof ProjectsprojectIdreleasesSourceControl
     */
    diffUrlToPrevious?: string;
}
/**
 * The filters used to determine which Errors will be returned by the search. See [Filtering](/insight-hub/docs/filtering) for details.
 * @export
 * @interface ProjectsprojectIdsavedSearchesFilters
 */
export interface ProjectsprojectIdsavedSearchesFilters {
    /**
     * An array of user ids. Matches Errors affecting any of these users. This refers to user ids in the context of your application. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserId>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    userId?: Array<ProjectsprojectIdsavedSearchesFiltersUserId>;
    /**
     * An array of email addresses. Matches Errors that have affected users with email addresses matching any of the provided emails. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    userEmail?: Array<ProjectsprojectIdsavedSearchesFiltersUserEmail>;
    /**
     * An array of user names. Matches Errors that have affected users with names matching any of the provided names. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersUserName>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    userName?: Array<ProjectsprojectIdsavedSearchesFiltersUserName>;
    /**
     * An array of error ids. Matches errors with IDs matching any of the given error IDs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorId>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    errorId?: Array<ProjectsprojectIdsavedSearchesFiltersErrorId>;
    /**
     * An array of error statuses. Matches Errors that have any of the given statuses. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    errorStatus?: Array<ProjectsprojectIdsavedSearchesFiltersErrorStatus>;
    /**
     * An array of collaborator identifiers. Matches Errors that have been assigned to any of the given collaborators. Exact match only.  Values can be `me` (for errors assigned to the current user), `anyone` (for errors assigned to anyone), a collaborator ID, or an email address.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    errorAssignedTo?: Array<ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo>;
    /**
     * If set to true, matches Errors that have had an issue created for them. If set to false, matches Errors that have not had an issue created for them.
     * @type {boolean}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    errorHasIssue?: boolean;
    /**
     * An array of release stages. Matches Errors that have occurred in any of the given release stages. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    appReleaseStage?: Array<ProjectsprojectIdsavedSearchesFiltersAppReleaseStage>;
    /**
     * An array of application contexts. This refers to the action that was happening when the event occurred. Matches Errors that occurred in any of the given contexts. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppContext>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    appContext?: Array<ProjectsprojectIdsavedSearchesFiltersAppContext>;
    /**
     * An array of application types. Matches Errors that occurred in any of the given application types. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppType>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    appType?: Array<ProjectsprojectIdsavedSearchesFiltersAppType>;
    /**
     * An array of application versions. Matches Errors that occurred for the first time in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    versionIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn>;
    /**
     * An array of application versions. Matches Errors that occurred in any of the given versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    versionSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionSeenIn>;
    /**
     * An array of version codes. Matches Errors that occurred for the first time in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    versionCodeIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of version codes. Matches Errors that occurred in a version of the application identified by any of the given versions codes. The value of an Error's versionCode depends on the corresponding Project's type. In Android apps this will match the versionCode setting. In iOS apps, versionCode is taken from the Build Number setting. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    versionCodeSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred for the first time in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    releaseIntroducedIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of Release `build_label`s, `app_version`s, `app_version_code`s, or `app_bundle_version`s. Matches Errors that occurred in any of the given Releases. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    releaseSeenIn?: Array<ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn>;
    /**
     * An array of classes. Matches Errors with any of the given classes. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventClass>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventClass?: Array<ProjectsprojectIdsavedSearchesFiltersEventClass>;
    /**
     * An array of messages. Matches Errors with any of the given messages. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventMessage?: Array<ProjectsprojectIdsavedSearchesFiltersEventMessage>;
    /**
     * An array of file paths. Matches Errors with any of the given files in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventFile>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventFile?: Array<ProjectsprojectIdsavedSearchesFiltersEventFile>;
    /**
     * An array of method names. Matches Errors with any of the given methods in their stack traces'. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventMethod?: Array<ProjectsprojectIdsavedSearchesFiltersEventMethod>;
    /**
     * An array of severities. Matches Errors with any of the given severities. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventSeverity?: Array<ProjectsprojectIdsavedSearchesFiltersEventSeverity>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring after the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventSince?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing a single timestamp. Matches Errors with events occurring before the given time. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersEventSince>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    eventBefore?: Array<ProjectsprojectIdsavedSearchesFiltersEventSince>;
    /**
     * An array containing web browser names. Matches Errors with events originating from any of the given web browsers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    browserName?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserName>;
    /**
     * An array containing web browser versions. Matches Errors with events originating from any browser with the given version. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    browserVersion?: Array<ProjectsprojectIdsavedSearchesFiltersBrowserVersion>;
    /**
     * An array containing operating system names. Matches Errors with events originating from devices running any of the given operating systems. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsName>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    osName?: Array<ProjectsprojectIdsavedSearchesFiltersOsName>;
    /**
     * An array containing operating system versions. Matches Errors with events originating from devices running any of the given operating system versions. Supports the `?` and `*` wildcards.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    osVersion?: Array<ProjectsprojectIdsavedSearchesFiltersOsVersion>;
    /**
     * An array containing hostnames. Matches Errors with events occurring on any hosts with one of the given hostnames. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    deviceHostname?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceHostname>;
    /**
     * An array containing device manufacturer names. Matches Errors with events occurring on any devices made by the given manufacturers. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    deviceManufacturer?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer>;
    /**
     * An array containing device model names. Matches Errors with events occurring on any of the given device models. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    deviceModel?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceModel>;
    /**
     * An array of URLs. Matches Errors with events associated with requests to any of the given URLs. Supports substring matches.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    requestUrl?: Array<ProjectsprojectIdsavedSearchesFiltersRequestUrl>;
    /**
     * An array of IP addresses. Matches Errors with events affecting any of the given IPs. Exact match only.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    requestIp?: Array<ProjectsprojectIdsavedSearchesFiltersRequestIp>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring on jailbroken devices.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    deviceJailbroken?: Array<ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken>;
    /**
     * An array containing a boolean. If `true`, matches Errors with events occurring when the application was in the foreground.
     * @type {Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>}
     * @memberof ProjectsprojectIdsavedSearchesFilters
     */
    appInForeground?: Array<ProjectsprojectIdsavedSearchesFiltersAppInForeground>;
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersAppContext
 */
export interface ProjectsprojectIdsavedSearchesFiltersAppContext {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppContext
     */
    type: ProjectsprojectIdsavedSearchesFiltersAppContext.TypeEnum;
    /**
     * Application context
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppContext
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersAppContext
 */
export namespace ProjectsprojectIdsavedSearchesFiltersAppContext {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersAppInForeground
 */
export interface ProjectsprojectIdsavedSearchesFiltersAppInForeground {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppInForeground
     */
    type: ProjectsprojectIdsavedSearchesFiltersAppInForeground.TypeEnum;
    /**
     * Foreground status
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppInForeground
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersAppInForeground
 */
export namespace ProjectsprojectIdsavedSearchesFiltersAppInForeground {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersAppReleaseStage
 */
export interface ProjectsprojectIdsavedSearchesFiltersAppReleaseStage {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppReleaseStage
     */
    type: ProjectsprojectIdsavedSearchesFiltersAppReleaseStage.TypeEnum;
    /**
     * Release stage
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppReleaseStage
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersAppReleaseStage
 */
export namespace ProjectsprojectIdsavedSearchesFiltersAppReleaseStage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersAppType
 */
export interface ProjectsprojectIdsavedSearchesFiltersAppType {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppType
     */
    type: ProjectsprojectIdsavedSearchesFiltersAppType.TypeEnum;
    /**
     * Application type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersAppType
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersAppType
 */
export namespace ProjectsprojectIdsavedSearchesFiltersAppType {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersBrowserName
 */
export interface ProjectsprojectIdsavedSearchesFiltersBrowserName {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersBrowserName
     */
    type: ProjectsprojectIdsavedSearchesFiltersBrowserName.TypeEnum;
    /**
     * Browser name
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersBrowserName
     */
    value: ProjectsprojectIdsavedSearchesFiltersBrowserName.ValueEnum;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersBrowserName
 */
export namespace ProjectsprojectIdsavedSearchesFiltersBrowserName {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValueEnum {
        Chrome = <any>'Chrome',
        Firefox = <any>'Firefox',
        Safari = <any>'Safari',
        Opera = <any>'Opera'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersBrowserVersion
 */
export interface ProjectsprojectIdsavedSearchesFiltersBrowserVersion {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersBrowserVersion
     */
    type: ProjectsprojectIdsavedSearchesFiltersBrowserVersion.TypeEnum;
    /**
     * Browser version
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersBrowserVersion
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersBrowserVersion
 */
export namespace ProjectsprojectIdsavedSearchesFiltersBrowserVersion {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersDeviceHostname
 */
export interface ProjectsprojectIdsavedSearchesFiltersDeviceHostname {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceHostname
     */
    type: ProjectsprojectIdsavedSearchesFiltersDeviceHostname.TypeEnum;
    /**
     * Device hostname
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceHostname
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersDeviceHostname
 */
export namespace ProjectsprojectIdsavedSearchesFiltersDeviceHostname {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken
 */
export interface ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken
     */
    type: ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken.TypeEnum;
    /**
     * Jailbroken status
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken
 */
export namespace ProjectsprojectIdsavedSearchesFiltersDeviceJailbroken {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer
 */
export interface ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer
     */
    type: ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer.TypeEnum;
    /**
     * Device manufacturer
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer
 */
export namespace ProjectsprojectIdsavedSearchesFiltersDeviceManufacturer {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersDeviceModel
 */
export interface ProjectsprojectIdsavedSearchesFiltersDeviceModel {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceModel
     */
    type: ProjectsprojectIdsavedSearchesFiltersDeviceModel.TypeEnum;
    /**
     * Device model
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersDeviceModel
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersDeviceModel
 */
export namespace ProjectsprojectIdsavedSearchesFiltersDeviceModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo
 */
export interface ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo
     */
    type: ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo.TypeEnum;
    /**
     * Collaborator ID
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo
 */
export namespace ProjectsprojectIdsavedSearchesFiltersErrorAssignedTo {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersErrorId
 */
export interface ProjectsprojectIdsavedSearchesFiltersErrorId {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersErrorId
     */
    type: ProjectsprojectIdsavedSearchesFiltersErrorId.TypeEnum;
    /**
     * Error ID
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersErrorId
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersErrorId
 */
export namespace ProjectsprojectIdsavedSearchesFiltersErrorId {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersErrorStatus
 */
export interface ProjectsprojectIdsavedSearchesFiltersErrorStatus {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersErrorStatus
     */
    type: ProjectsprojectIdsavedSearchesFiltersErrorStatus.TypeEnum;
    /**
     * Error status
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersErrorStatus
     */
    value: ProjectsprojectIdsavedSearchesFiltersErrorStatus.ValueEnum;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersErrorStatus
 */
export namespace ProjectsprojectIdsavedSearchesFiltersErrorStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValueEnum {
        Open = <any>'open',
        InProgress = <any>'in progress',
        ForReview = <any>'for_review',
        Fixed = <any>'fixed',
        Snoozed = <any>'snoozed',
        Ignored = <any>'ignored'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersEventClass
 */
export interface ProjectsprojectIdsavedSearchesFiltersEventClass {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventClass
     */
    type: ProjectsprojectIdsavedSearchesFiltersEventClass.TypeEnum;
    /**
     * Event class
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventClass
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersEventClass
 */
export namespace ProjectsprojectIdsavedSearchesFiltersEventClass {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersEventFile
 */
export interface ProjectsprojectIdsavedSearchesFiltersEventFile {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventFile
     */
    type: ProjectsprojectIdsavedSearchesFiltersEventFile.TypeEnum;
    /**
     * File path
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventFile
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersEventFile
 */
export namespace ProjectsprojectIdsavedSearchesFiltersEventFile {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersEventMessage
 */
export interface ProjectsprojectIdsavedSearchesFiltersEventMessage {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventMessage
     */
    type: ProjectsprojectIdsavedSearchesFiltersEventMessage.TypeEnum;
    /**
     * Event message
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventMessage
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersEventMessage
 */
export namespace ProjectsprojectIdsavedSearchesFiltersEventMessage {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersEventMethod
 */
export interface ProjectsprojectIdsavedSearchesFiltersEventMethod {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventMethod
     */
    type: ProjectsprojectIdsavedSearchesFiltersEventMethod.TypeEnum;
    /**
     * Method name
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventMethod
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersEventMethod
 */
export namespace ProjectsprojectIdsavedSearchesFiltersEventMethod {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersEventSeverity
 */
export interface ProjectsprojectIdsavedSearchesFiltersEventSeverity {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventSeverity
     */
    type: ProjectsprojectIdsavedSearchesFiltersEventSeverity.TypeEnum;
    /**
     * Error severity
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventSeverity
     */
    value: ProjectsprojectIdsavedSearchesFiltersEventSeverity.ValueEnum;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersEventSeverity
 */
export namespace ProjectsprojectIdsavedSearchesFiltersEventSeverity {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValueEnum {
        Info = <any>'info',
        Warning = <any>'warning',
        Error = <any>'error'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersEventSince
 */
export interface ProjectsprojectIdsavedSearchesFiltersEventSince {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventSince
     */
    type: ProjectsprojectIdsavedSearchesFiltersEventSince.TypeEnum;
    /**
     * Timestamp
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersEventSince
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersEventSince
 */
export namespace ProjectsprojectIdsavedSearchesFiltersEventSince {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersOsName
 */
export interface ProjectsprojectIdsavedSearchesFiltersOsName {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersOsName
     */
    type: ProjectsprojectIdsavedSearchesFiltersOsName.TypeEnum;
    /**
     * Operating system name
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersOsName
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersOsName
 */
export namespace ProjectsprojectIdsavedSearchesFiltersOsName {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersOsVersion
 */
export interface ProjectsprojectIdsavedSearchesFiltersOsVersion {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersOsVersion
     */
    type: ProjectsprojectIdsavedSearchesFiltersOsVersion.TypeEnum;
    /**
     * Operating system version
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersOsVersion
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersOsVersion
 */
export namespace ProjectsprojectIdsavedSearchesFiltersOsVersion {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn
 */
export interface ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn
     */
    type: ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn.TypeEnum;
    /**
     * Release identifier
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn
 */
export namespace ProjectsprojectIdsavedSearchesFiltersReleaseIntroducedIn {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersRequestIp
 */
export interface ProjectsprojectIdsavedSearchesFiltersRequestIp {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersRequestIp
     */
    type: ProjectsprojectIdsavedSearchesFiltersRequestIp.TypeEnum;
    /**
     * IP address
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersRequestIp
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersRequestIp
 */
export namespace ProjectsprojectIdsavedSearchesFiltersRequestIp {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersRequestUrl
 */
export interface ProjectsprojectIdsavedSearchesFiltersRequestUrl {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersRequestUrl
     */
    type: ProjectsprojectIdsavedSearchesFiltersRequestUrl.TypeEnum;
    /**
     * Request URL
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersRequestUrl
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersRequestUrl
 */
export namespace ProjectsprojectIdsavedSearchesFiltersRequestUrl {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersUserEmail
 */
export interface ProjectsprojectIdsavedSearchesFiltersUserEmail {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersUserEmail
     */
    type: ProjectsprojectIdsavedSearchesFiltersUserEmail.TypeEnum;
    /**
     * User email
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersUserEmail
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersUserEmail
 */
export namespace ProjectsprojectIdsavedSearchesFiltersUserEmail {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersUserId
 */
export interface ProjectsprojectIdsavedSearchesFiltersUserId {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersUserId
     */
    type: ProjectsprojectIdsavedSearchesFiltersUserId.TypeEnum;
    /**
     * User ID
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersUserId
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersUserId
 */
export namespace ProjectsprojectIdsavedSearchesFiltersUserId {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersUserName
 */
export interface ProjectsprojectIdsavedSearchesFiltersUserName {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersUserName
     */
    type: ProjectsprojectIdsavedSearchesFiltersUserName.TypeEnum;
    /**
     * User name
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersUserName
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersUserName
 */
export namespace ProjectsprojectIdsavedSearchesFiltersUserName {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn
 */
export interface ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn
     */
    type: ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn.TypeEnum;
    /**
     * Version code
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn
 */
export namespace ProjectsprojectIdsavedSearchesFiltersVersionCodeIntroducedIn {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn
 */
export interface ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn
     */
    type: ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn.TypeEnum;
    /**
     * Application version
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn
 */
export namespace ProjectsprojectIdsavedSearchesFiltersVersionIntroducedIn {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdsavedSearchesFiltersVersionSeenIn
 */
export interface ProjectsprojectIdsavedSearchesFiltersVersionSeenIn {
    /**
     * The match type
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersVersionSeenIn
     */
    type: ProjectsprojectIdsavedSearchesFiltersVersionSeenIn.TypeEnum;
    /**
     * Application version
     * @type {string}
     * @memberof ProjectsprojectIdsavedSearchesFiltersVersionSeenIn
     */
    value: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdsavedSearchesFiltersVersionSeenIn
 */
export namespace ProjectsprojectIdsavedSearchesFiltersVersionSeenIn {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdspanGroupsFilterValues
 */
export interface ProjectsprojectIdspanGroupsFilterValues {
    /**
     *
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsFilterValues
     */
    value: string;
    /**
     * - eq - Filter for items that match the value - ne - Filter for items that don't match the value - lt - Filter for items that are less than the value - gt - Filter for items that are greater than the value - empty - Filter for items that are not populated or missing
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsFilterValues
     */
    matchType: ProjectsprojectIdspanGroupsFilterValues.MatchTypeEnum;
}

/**
 * @export
 * @namespace ProjectsprojectIdspanGroupsFilterValues
 */
export namespace ProjectsprojectIdspanGroupsFilterValues {
    /**
     * @export
     * @enum {string}
     */
    export enum MatchTypeEnum {
        Eq = <any>'eq',
        Ne = <any>'ne',
        Lt = <any>'lt',
        Gt = <any>'gt',
        Empty = <any>'empty'
    }
}
/**
 * The Performance Target for the Span Group.
 * @export
 * @interface ProjectsprojectIdspanGroupsPerformanceTarget
 */
export interface ProjectsprojectIdspanGroupsPerformanceTarget {
    /**
     * The ID of the Performance Target.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTarget
     */
    id: string;
    /**
     * The ID of the Project that the Performance Target belongs to.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTarget
     */
    projectId: string;
    /**
     * The type of Performance Target.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTarget
     */
    type: ProjectsprojectIdspanGroupsPerformanceTarget.TypeEnum;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTarget
     */
    spanGroup: ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTargetConfig}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTarget
     */
    config: ProjectsprojectIdspanGroupsPerformanceTargetConfig;
}

/**
 * @export
 * @namespace ProjectsprojectIdspanGroupsPerformanceTarget
 */
export namespace ProjectsprojectIdspanGroupsPerformanceTarget {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Category = <any>'category',
        SpanGroup = <any>'span_group'
    }
}
/**
 * The configuration details for the Performance Target.
 * @export
 * @interface ProjectsprojectIdspanGroupsPerformanceTargetConfig
 */
export interface ProjectsprojectIdspanGroupsPerformanceTargetConfig {
    /**
     * The state of the Performance Target.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetConfig
     */
    state: ProjectsprojectIdspanGroupsPerformanceTargetConfig.StateEnum;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTargetConfigWarningPerformance}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetConfig
     */
    warningPerformance?: ProjectsprojectIdspanGroupsPerformanceTargetConfigWarningPerformance;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsPerformanceTargetConfigCriticalPerformance}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetConfig
     */
    criticalPerformance?: ProjectsprojectIdspanGroupsPerformanceTargetConfigCriticalPerformance;
}

/**
 * @export
 * @namespace ProjectsprojectIdspanGroupsPerformanceTargetConfig
 */
export namespace ProjectsprojectIdspanGroupsPerformanceTargetConfig {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Enabled = <any>'enabled',
        Disabled = <any>'disabled'
    }
}
/**
 * The critical performance threshold for the Performance Target. Requires the advanced performance targets feature.
 * @export
 * @interface ProjectsprojectIdspanGroupsPerformanceTargetConfigCriticalPerformance
 */
export interface ProjectsprojectIdspanGroupsPerformanceTargetConfigCriticalPerformance {
    /**
     * The duration threshold in milliseconds.
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetConfigCriticalPerformance
     */
    duration: number;
}
/**
 * The warning performance threshold for the Performance Target. Required when state is enabled.
 * @export
 * @interface ProjectsprojectIdspanGroupsPerformanceTargetConfigWarningPerformance
 */
export interface ProjectsprojectIdspanGroupsPerformanceTargetConfigWarningPerformance {
    /**
     * The duration threshold in milliseconds.
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetConfigWarningPerformance
     */
    duration: number;
}
/**
 * The details of the Span Group(s) that the Performance Target is for.
 * @export
 * @interface ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup
 */
export interface ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup {
    /**
     * The category of the affected Span Group(s).
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup
     */
    category: ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup.CategoryEnum;
    /**
     * The ID of the Span Group. Required when Performance Target type is span_group.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup
     */
    id?: string;
    /**
     * The name of the Span Group for display purposes. Required when Performance Target type is span_group.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup
     */
    displayName?: string;
}

/**
 * @export
 * @namespace ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup
 */
export namespace ProjectsprojectIdspanGroupsPerformanceTargetSpanGroup {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        AppStart = <any>'app_start',
        ViewLoad = <any>'view_load',
        PageLoad = <any>'page_load',
        RouteChange = <any>'route_change',
        FullPageLoad = <any>'full_page_load',
        Network = <any>'network',
        Custom = <any>'custom',
        Navigation = <any>'navigation',
        InboundHttp = <any>'inbound_http',
        OutboundHttp = <any>'outbound_http',
        InboundRpc = <any>'inbound_rpc',
        OutboundRpc = <any>'outbound_rpc',
        CustomServer = <any>'custom_server',
        FrozenFrame = <any>'frozen_frame'
    }
}
/**
 * Statistics of spans in the Span Group.
 * @export
 * @interface ProjectsprojectIdspanGroupsStatistics
 */
export interface ProjectsprojectIdspanGroupsStatistics {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsDurationStatistics}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    durationStatistics: ProjectsprojectIdspanGroupsStatisticsDurationStatistics;
    /**
     * The total number of Spans that were sampled in the bucketed time period.
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    totalSpans: number;
    /**
     * The estimated total of Spans that were generated in the bucketed time period, before sampling was applied.
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    estimatedSpans?: number;
    /**
     * When the last filtered Span within this Span Group was seen.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    lastSeen: string;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsCategoryStatistics}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    categoryStatistics?: ProjectsprojectIdspanGroupsStatisticsCategoryStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsRenderingStatistics}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    renderingStatistics?: ProjectsprojectIdspanGroupsStatisticsRenderingStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics}
     * @memberof ProjectsprojectIdspanGroupsStatistics
     */
    systemMetricsStatistics?: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics;
}
/**
 * Statistics that are specific to the Span Group's category. This is populated by only one property object based on the category type.
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsCategoryStatistics
 */
export interface ProjectsprojectIdspanGroupsStatisticsCategoryStatistics {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad}
     * @memberof ProjectsprojectIdspanGroupsStatisticsCategoryStatistics
     */
    fullPageLoad?: ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad;
}
/**
 * Statistics for the full_page_load category
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad
 */
export interface ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad {
    /**
     * P75 Time (integer, in ms) from a navigation event to the largest element on the page rendered
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad
     */
    largestContentfulPaint?: number;
    /**
     * P75 Time (integer, in ms) from a user interaction with the page (e.g. click) to the page becoming interactive
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad
     */
    firstInputDelay?: number;
    /**
     * P75 Measure (float) of how often visible elements move unexpectedly
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad
     */
    cumulativeLayoutShift?: number;
    /**
     * P75 Time (integer, in ms) from a navigation event starting to the first byte arriving
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad
     */
    timeToFirstByte?: number;
    /**
     * P75 Time (in ms) from a navigation event to the first element rendered
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsCategoryStatisticsFullPageLoad
     */
    firstContentfulPaint?: number;
}
/**
 * The aggregated statistics for the filtered Span durations.
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsDurationStatistics
 */
export interface ProjectsprojectIdspanGroupsStatisticsDurationStatistics {
    /**
     * The P50 duration (in ms).
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsDurationStatistics
     */
    p50: number;
    /**
     * The P75 duration (in ms).
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsDurationStatistics
     */
    p75: number;
    /**
     * The P90 duration (in ms).
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsDurationStatistics
     */
    p90: number;
    /**
     * The P95 duration (in ms).
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsDurationStatistics
     */
    p95: number;
    /**
     * The P99 duration (in ms).
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsDurationStatistics
     */
    p99: number;
}
/**
 * Statistics about rendering issues encountered while the Spans in the Span Group were active.
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsRenderingStatistics
 */
export interface ProjectsprojectIdspanGroupsStatisticsRenderingStatistics {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsSlowFrames}
     * @memberof ProjectsprojectIdspanGroupsStatisticsRenderingStatistics
     */
    slowFrames?: ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsSlowFrames;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsFrozenFrames}
     * @memberof ProjectsprojectIdspanGroupsStatisticsRenderingStatistics
     */
    frozenFrames?: ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsFrozenFrames;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsTotalFrames}
     * @memberof ProjectsprojectIdspanGroupsStatisticsRenderingStatistics
     */
    totalFrames?: ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsTotalFrames;
}
/**
 * Details about the frozen frames (those that took longer than 700ms to render)
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsFrozenFrames
 */
export interface ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsFrozenFrames {
    /**
     * The number of Spans that has at least one frozen frame
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsFrozenFrames
     */
    spanCount: number;
}
/**
 * Details about the slow frames (those that missed their render deadline)
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsSlowFrames
 */
export interface ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsSlowFrames {
    /**
     * The number of Spans that has at least one slow frame
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsSlowFrames
     */
    spanCount: number;
}
/**
 * Details about the total number of frames
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsTotalFrames
 */
export interface ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsTotalFrames {
    /**
     * The number of Spans that tracked at least one frame
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsRenderingStatisticsTotalFrames
     */
    spanCount: number;
}
/**
 * Statistics about system measurements recorded while the Spans in the Span Group were active.
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpu}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics
     */
    cpu?: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpu;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemory}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics
     */
    memory?: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemory;
}
/**
 * Details about the CPU usage of the Spans
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpu
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpu {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotal}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpu
     */
    total: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotal;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuMainThread}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpu
     */
    mainThread: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuMainThread;
}
/**
 * Aggregated statistics for the main thread CPU usage for the Spans in the Span Group
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuMainThread
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuMainThread {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuMainThread
     */
    mean: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean;
}
/**
 * Aggregated statistics for the total CPU usage for the Spans in the Span Group
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotal
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotal {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotal
     */
    mean: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean;
}
/**
 * The aggregated mean value
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean {
    /**
     * The number of Spans that reported CPU system metric
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
     */
    spanCount: number;
    /**
     * The P50 CPU usage percentage between 0 and 100 - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
     */
    p50?: number;
    /**
     * The p75 CPU usage percentage between 0 and 100 - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
     */
    p75?: number;
    /**
     * The p90 CPU usage percentage between 0 and 100 - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
     */
    p90?: number;
    /**
     * The p95 CPU usage percentage between 0 and 100 - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
     */
    p95?: number;
    /**
     * The p99 CPU usage percentage between 0 and 100 - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsCpuTotalMean
     */
    p99?: number;
}
/**
 * Details about the memory usage of the Spans
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemory
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemory {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDevice}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemory
     */
    device: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDevice;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryAndroidRuntime}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemory
     */
    androidRuntime?: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryAndroidRuntime;
}
/**
 * Aggregated statistics for the Android Runtime memory usage for the Spans in the Span Group
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryAndroidRuntime
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryAndroidRuntime {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryAndroidRuntime
     */
    mean: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean;
}
/**
 * Aggregated statistics for the device memory usage for the Spans in the Span Group
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDevice
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDevice {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDevice
     */
    mean: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean;
}
/**
 * The aggregated mean value
 * @export
 * @interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
 */
export interface ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean {
    /**
     * The number of Spans that reported memory system metrics of this type
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
     */
    spanCount: number;
    /**
     * The P50 memory usage (in bytes) - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
     */
    p50?: number;
    /**
     * The p75 memory usage (in bytes) - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
     */
    p75?: number;
    /**
     * The p90 memory usage (in bytes) - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
     */
    p90?: number;
    /**
     * The p95 memory usage (in bytes) - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
     */
    p95?: number;
    /**
     * The p99 memory usage (in bytes) - (Only present if span_count > 0)
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatisticsMemoryDeviceMean
     */
    p99?: number;
}
/**
 * Statistics for the time period.
 * @export
 * @interface ProjectsprojectIdspanGroupsidtimelineStatistics
 */
export interface ProjectsprojectIdspanGroupsidtimelineStatistics {
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsDurationStatistics}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    durationStatistics: ProjectsprojectIdspanGroupsStatisticsDurationStatistics;
    /**
     * The total number of Spans that were sampled in the bucketed time period.
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    totalSpans: number;
    /**
     * The estimated total of Spans that were generated in the bucketed time period, before sampling was applied.
     * @type {number}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    estimatedSpans?: number;
    /**
     * When the last filtered Span within this Span Group was seen.
     * @type {string}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    lastSeen: string;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsCategoryStatistics}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    categoryStatistics?: ProjectsprojectIdspanGroupsStatisticsCategoryStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsRenderingStatistics}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    renderingStatistics?: ProjectsprojectIdspanGroupsStatisticsRenderingStatistics;
    /**
     *
     * @type {ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics}
     * @memberof ProjectsprojectIdspanGroupsidtimelineStatistics
     */
    systemMetricsStatistics?: ProjectsprojectIdspanGroupsStatisticsSystemMetricsStatistics;
}
/**
 * The values to filter by.
 * @export
 * @interface ProjectsprojectIdtraceFieldsFilterOptions
 */
export interface ProjectsprojectIdtraceFieldsFilterOptions {
    /**
     * Human readable display name for the filter.
     * @type {string}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptions
     */
    name: string;
    /**
     * Description of what the filter is.
     * @type {string}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptions
     */
    description: string;
    /**
     * Possible values for this filter, only if this filter has a fixed set of values.
     * @type {Array<ProjectsprojectIdtraceFieldsFilterOptionsValues>}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptions
     */
    values?: Array<ProjectsprojectIdtraceFieldsFilterOptionsValues>;
    /**
     * The match types that are supported by this filter.
     * @type {Array<string>}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptions
     */
    matchTypes: Array<ProjectsprojectIdtraceFieldsFilterOptions.MatchTypesEnum>;
    /**
     * Whether the filter is searchable in the search bar suggestions.
     * @type {boolean}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptions
     */
    searchable: boolean;
}

/**
 * @export
 * @namespace ProjectsprojectIdtraceFieldsFilterOptions
 */
export namespace ProjectsprojectIdtraceFieldsFilterOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum MatchTypesEnum {
        Eq = <any>'eq',
        Ne = <any>'ne',
        Lt = <any>'lt',
        Gt = <any>'gt',
        Empty = <any>'empty'
    }
}
/**
 *
 * @export
 * @interface ProjectsprojectIdtraceFieldsFilterOptionsValues
 */
export interface ProjectsprojectIdtraceFieldsFilterOptionsValues {
    /**
     * The identifier to use when filtering by this value.
     * @type {string}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptionsValues
     */
    id: string;
    /**
     * A human readable represenation of this value.
     * @type {string}
     * @memberof ProjectsprojectIdtraceFieldsFilterOptionsValues
     */
    name: string;
}
/**
 *
 * @export
 * @interface ReleaseGroupsIdBody
 */
export interface ReleaseGroupsIdBody {
    /**
     * the updated visibility
     * @type {boolean}
     * @memberof ReleaseGroupsIdBody
     */
    visible: boolean;
}
/**
 *
 * @export
 * @interface SavedSearchesBody
 */
export interface SavedSearchesBody {
    /**
     * ID of project this saved search is for
     * @type {string}
     * @memberof SavedSearchesBody
     */
    projectId: string;
    /**
     * name of the saved search
     * @type {string}
     * @memberof SavedSearchesBody
     */
    name: string;
    /**
     *
     * @type {ProjectsprojectIdsavedSearchesFilters}
     * @memberof SavedSearchesBody
     */
    filters: ProjectsprojectIdsavedSearchesFilters;
    /**
     * the `error` property to sort results by
     * @type {string}
     * @memberof SavedSearchesBody
     */
    sort?: SavedSearchesBody.SortEnum;
    /**
     * whether this saved search is shared among collaborators
     * @type {boolean}
     * @memberof SavedSearchesBody
     */
    shared?: boolean;
    /**
     * whether this saved search is the project default for the current user
     * @type {boolean}
     * @memberof SavedSearchesBody
     */
    projectDefault: boolean;
}

/**
 * @export
 * @namespace SavedSearchesBody
 */
export namespace SavedSearchesBody {
    /**
     * @export
     * @enum {string}
     */
    export enum SortEnum {
        FirstSeen = <any>'first_seen',
        Users = <any>'users',
        Events = <any>'events',
        LastSeen = <any>'last_seen'
    }
}
/**
 *
 * @export
 * @interface SavedSearchesIdBody
 */
export interface SavedSearchesIdBody {
    /**
     * name of the saved search
     * @type {string}
     * @memberof SavedSearchesIdBody
     */
    name?: string;
    /**
     *
     * @type {ProjectsprojectIdsavedSearchesFilters}
     * @memberof SavedSearchesIdBody
     */
    filters?: ProjectsprojectIdsavedSearchesFilters;
    /**
     * the `error` property to sort results by
     * @type {string}
     * @memberof SavedSearchesIdBody
     */
    sort?: SavedSearchesIdBody.SortEnum;
    /**
     * whether this saved search is shared among collaborators
     * @type {boolean}
     * @memberof SavedSearchesIdBody
     */
    shared?: boolean;
    /**
     * whether this saved search is the project default for the current user
     * @type {boolean}
     * @memberof SavedSearchesIdBody
     */
    projectDefault?: boolean;
}

/**
 * @export
 * @namespace SavedSearchesIdBody
 */
export namespace SavedSearchesIdBody {
    /**
     * @export
     * @enum {string}
     */
    export enum SortEnum {
        FirstSeen = <any>'first_seen',
        Users = <any>'users',
        Events = <any>'events',
        LastSeen = <any>'last_seen'
    }
}
/**
 *
 * @export
 * @interface SpanGroupsIdBody
 */
export interface SpanGroupsIdBody {
    /**
     * whether or not the Span Group is starred by the user.
     * @type {boolean}
     * @memberof SpanGroupsIdBody
     */
    isStarred?: boolean;
}
/**
 *
 * @export
 * @interface TeamsIdBody
 */
export interface TeamsIdBody {
    /**
     *
     * @type {string}
     * @memberof TeamsIdBody
     */
    name: string;
}
/**
 *
 * @export
 * @interface TriggerConfigsTriggerConfigKeyBody
 */
export interface TriggerConfigsTriggerConfigKeyBody {
    /**
     *
     * @type {boolean}
     * @memberof TriggerConfigsTriggerConfigKeyBody
     */
    active: boolean;
    /**
     * settings for the trigger
     * @type {Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings>}
     * @memberof TriggerConfigsTriggerConfigKeyBody
     */
    settings?: Array<ConfiguredIntegrationsidtriggerConfigstriggerConfigKeySettings>;
}
/**
 *
 * @export
 * @interface UsersIdBody
 */
export interface UsersIdBody {
    /**
     *
     * @type {string}
     * @memberof UsersIdBody
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof UsersIdBody
     */
    userName: string;
    /**
     *
     * @type {OrganizationsorganizationIdscimv2UsersidName}
     * @memberof UsersIdBody
     */
    name: OrganizationsorganizationIdscimv2UsersidName;
    /**
     *
     * @type {Array<OrganizationsorganizationIdscimv2UsersidEmails>}
     * @memberof UsersIdBody
     */
    emails: Array<OrganizationsorganizationIdscimv2UsersidEmails>;
    /**
     * Whether the user is part of the organization.
     * @type {boolean}
     * @memberof UsersIdBody
     */
    active?: boolean;
}
/**
 *
 * @export
 * @interface UsersIdBody1
 */
export interface UsersIdBody1 {
    /**
     *
     * @type {Array<OrganizationsorganizationIdscimv2UsersidOperations>}
     * @memberof UsersIdBody1
     */
    operations?: Array<OrganizationsorganizationIdscimv2UsersidOperations>;
}
/**
 *
 * @export
 * @interface V2GroupsBody
 */
export interface V2GroupsBody {
    /**
     *
     * @type {string}
     * @memberof V2GroupsBody
     */
    displayName: string;
}
/**
 * CurrentUserApi - fetch parameter creator
 * @export
 */
export const CurrentUserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Saved Search
         * @param {SavedSearchesBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(body?: SavedSearchesBody, options: any = {}): FetchArgs {
            const localVarPath = `/saved_searches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SavedSearchesBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Saved Search
         * @param {string} id The ID of the saved search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteSavedSearchById.');
            }
            const localVarPath = `/saved_searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of projects for the given organization.
         * @summary List an Organization's Projects
         * @param {string} organizationId the ID of the organization
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationProjects.');
            }
            const localVarPath = `/organizations/{organization_id}/projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Saved Search
         * @param {string} id The ID of the saved search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getSavedSearchById.');
            }
            const localVarPath = `/saved_searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a short usage summary for a saved search.
         * @summary Get the Usage Summary for a Saved Search
         * @param {string} id the ID of the saved search to get a summary for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchUsageSummary(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getSavedSearchUsageSummary.');
            }
            const localVarPath = `/saved_searches/{id}/usage_summary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the saved searches for a given project sorted by name in lexographic order.
         * @summary List Saved Searches on a Project
         * @param {string} projectId
         * @param {string} [shared] Limit Saved Searches returned to only those with this &#x60;shared&#x60; property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSavedSearches(projectId: string, shared?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectSavedSearches.');
            }
            const localVarPath = `/projects/{project_id}/saved_searches`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the Current User's Organizations
         * @param {boolean} [admin] &#x60;true&#x60; if only Organizations the Current User is an admin of should be returned
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOrganizations(admin?: boolean, perPage?: number, options: any = {}): FetchArgs {
            const localVarPath = `/user/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (admin !== undefined) {
                localVarQueryParameter['admin'] = admin;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Saved Search
         * @param {string} id The ID of the saved search
         * @param {SavedSearchesIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedSearchById(id: string, body?: SavedSearchesIdBody, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateSavedSearchById.');
            }
            const localVarPath = `/saved_searches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SavedSearchesIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrentUserApi - functional programming interface
 * @export
 */
export const CurrentUserApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Saved Search
         * @param {SavedSearchesBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(body?: SavedSearchesBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).createSavedSearch(body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a Saved Search
         * @param {string} id The ID of the saved search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).deleteSavedSearchById(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of projects for the given organization.
         * @summary List an Organization's Projects
         * @param {string} organizationId the ID of the organization
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).getOrganizationProjects(organizationId, q, sort, direction, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Saved Search
         * @param {string} id The ID of the saved search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).getSavedSearchById(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a short usage summary for a saved search.
         * @summary Get the Usage Summary for a Saved Search
         * @param {string} id the ID of the saved search to get a summary for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchUsageSummary(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).getSavedSearchUsageSummary(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the saved searches for a given project sorted by name in lexographic order.
         * @summary List Saved Searches on a Project
         * @param {string} projectId
         * @param {string} [shared] Limit Saved Searches returned to only those with this &#x60;shared&#x60; property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSavedSearches(projectId: string, shared?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200>> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).listProjectSavedSearches(projectId, shared, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List the Current User's Organizations
         * @param {boolean} [admin] &#x60;true&#x60; if only Organizations the Current User is an admin of should be returned
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOrganizations(admin?: boolean, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).listUserOrganizations(admin, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a Saved Search
         * @param {string} id The ID of the saved search
         * @param {SavedSearchesIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedSearchById(id: string, body?: SavedSearchesIdBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = CurrentUserApiFetchParamCreator(configuration).updateSavedSearchById(id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CurrentUserApi - factory interface
 * @export
 */
export const CurrentUserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create a Saved Search
         * @param {SavedSearchesBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(body?: SavedSearchesBody, options?: any) {
            return CurrentUserApiFp(configuration).createSavedSearch(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a Saved Search
         * @param {string} id The ID of the saved search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchById(id: string, options?: any) {
            return CurrentUserApiFp(configuration).deleteSavedSearchById(id, options)(fetch, basePath);
        },
        /**
         * Returns a list of projects for the given organization.
         * @summary List an Organization's Projects
         * @param {string} organizationId the ID of the organization
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any) {
            return CurrentUserApiFp(configuration).getOrganizationProjects(organizationId, q, sort, direction, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Saved Search
         * @param {string} id The ID of the saved search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchById(id: string, options?: any) {
            return CurrentUserApiFp(configuration).getSavedSearchById(id, options)(fetch, basePath);
        },
        /**
         * Returns a short usage summary for a saved search.
         * @summary Get the Usage Summary for a Saved Search
         * @param {string} id the ID of the saved search to get a summary for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearchUsageSummary(id: string, options?: any) {
            return CurrentUserApiFp(configuration).getSavedSearchUsageSummary(id, options)(fetch, basePath);
        },
        /**
         * Returns the saved searches for a given project sorted by name in lexographic order.
         * @summary List Saved Searches on a Project
         * @param {string} projectId
         * @param {string} [shared] Limit Saved Searches returned to only those with this &#x60;shared&#x60; property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSavedSearches(projectId: string, shared?: string, options?: any) {
            return CurrentUserApiFp(configuration).listProjectSavedSearches(projectId, shared, options)(fetch, basePath);
        },
        /**
         *
         * @summary List the Current User's Organizations
         * @param {boolean} [admin] &#x60;true&#x60; if only Organizations the Current User is an admin of should be returned
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOrganizations(admin?: boolean, perPage?: number, options?: any) {
            return CurrentUserApiFp(configuration).listUserOrganizations(admin, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a Saved Search
         * @param {string} id The ID of the saved search
         * @param {SavedSearchesIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedSearchById(id: string, body?: SavedSearchesIdBody, options?: any) {
            return CurrentUserApiFp(configuration).updateSavedSearchById(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * CurrentUserApi - object-oriented interface
 * @export
 * @class CurrentUserApi
 * @extends {BaseAPI}
 */
export class CurrentUserApi extends BaseAPI {
    /**
     *
     * @summary Create a Saved Search
     * @param {SavedSearchesBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public createSavedSearch(body?: SavedSearchesBody, options?: any) {
        return CurrentUserApiFp(this.configuration).createSavedSearch(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a Saved Search
     * @param {string} id The ID of the saved search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public deleteSavedSearchById(id: string, options?: any) {
        return CurrentUserApiFp(this.configuration).deleteSavedSearchById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of projects for the given organization.
     * @summary List an Organization's Projects
     * @param {string} organizationId the ID of the organization
     * @param {string} [q] Search projects with names matching parameter
     * @param {string} [sort] Which field to sort the results by
     * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
     * @param {number} [perPage] How many results to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any) {
        return CurrentUserApiFp(this.configuration).getOrganizationProjects(organizationId, q, sort, direction, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a Saved Search
     * @param {string} id The ID of the saved search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public getSavedSearchById(id: string, options?: any) {
        return CurrentUserApiFp(this.configuration).getSavedSearchById(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a short usage summary for a saved search.
     * @summary Get the Usage Summary for a Saved Search
     * @param {string} id the ID of the saved search to get a summary for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public getSavedSearchUsageSummary(id: string, options?: any) {
        return CurrentUserApiFp(this.configuration).getSavedSearchUsageSummary(id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the saved searches for a given project sorted by name in lexographic order.
     * @summary List Saved Searches on a Project
     * @param {string} projectId
     * @param {string} [shared] Limit Saved Searches returned to only those with this &#x60;shared&#x60; property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public listProjectSavedSearches(projectId: string, shared?: string, options?: any) {
        return CurrentUserApiFp(this.configuration).listProjectSavedSearches(projectId, shared, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List the Current User's Organizations
     * @param {boolean} [admin] &#x60;true&#x60; if only Organizations the Current User is an admin of should be returned
     * @param {number} [perPage] Number of results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public listUserOrganizations(admin?: boolean, perPage?: number, options?: any) {
        return CurrentUserApiFp(this.configuration).listUserOrganizations(admin, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a Saved Search
     * @param {string} id The ID of the saved search
     * @param {SavedSearchesIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public updateSavedSearchById(id: string, body?: SavedSearchesIdBody, options?: any) {
        return CurrentUserApiFp(this.configuration).updateSavedSearchById(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ErrorsApi - fetch parameter creator
 * @export
 */
export const ErrorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Bulk Update Errors
         * @param {ProjectIdErrorsBody} body
         * @param {string} projectId
         * @param {Array<string>} errorIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateErrors(body: ProjectIdErrorsBody, projectId: string, errorIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling bulkUpdateErrors.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling bulkUpdateErrors.');
            }
            // verify required parameter 'errorIds' is not null or undefined
            if (errorIds === null || errorIds === undefined) {
                throw new RequiredError('errorIds', 'Required parameter errorIds was null or undefined when calling bulkUpdateErrors.');
            }
            const localVarPath = `/projects/{project_id}/errors`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (errorIds) {
                localVarQueryParameter['error_ids'] = errorIds;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdErrorsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all Error and Event data in a project. Use with caution. This action cannot be reversed.
         * @summary Delete all Errors in a Project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllErrorsInProject(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteAllErrorsInProject.');
            }
            const localVarPath = `/projects/{project_id}/errors`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteErrorOnProject(projectId: string, errorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteErrorOnProject.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling deleteErrorOnProject.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Event
         * @param {string} projectId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById(projectId: string, eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteEventById.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId', 'Required parameter eventId was null or undefined when calling deleteEventById.');
            }
            const localVarPath = `/projects/{project_id}/events/{event_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts for an Error in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
         * @summary List the Trends for an Error
         * @param {string} projectId ID of the Project
         * @param {string} errorId ID of the error
         * @param {Filters3} [filters] Search filters to restrict the events reported in the trend
         * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
         * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketedAndUnbucketedTrendsOnError(projectId: string, errorId: string, filters?: Filters3, bucketsCount?: number, resolution?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getBucketedAndUnbucketedTrendsOnError.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling getBucketedAndUnbucketedTrendsOnError.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}/trends`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (bucketsCount !== undefined) {
                localVarQueryParameter['buckets_count'] = bucketsCount;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts for a Project in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
         * @summary List the Trends for a Project
         * @param {string} projectId ID of the project
         * @param {Filters4} [filters] Search filters to restrict the events reported in the trend
         * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
         * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketedAndUnbucketedTrendsOnProject(projectId: string, filters?: Filters4, bucketsCount?: number, resolution?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getBucketedAndUnbucketedTrendsOnProject.');
            }
            const localVarPath = `/projects/{project_id}/trends`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (bucketsCount !== undefined) {
                localVarQueryParameter['buckets_count'] = bucketsCount;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List values of a Pivot on a Project
         * @param {string} projectId
         * @param {string} eventFieldDisplayId
         * @param {Filters8} [filters]
         * @param {string} [sort]
         * @param {Date} [base]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotValuesOnAProject(projectId: string, eventFieldDisplayId: string, filters?: Filters8, sort?: string, base?: Date, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getPivotValuesOnAProject.');
            }
            // verify required parameter 'eventFieldDisplayId' is not null or undefined
            if (eventFieldDisplayId === null || eventFieldDisplayId === undefined) {
                throw new RequiredError('eventFieldDisplayId', 'Required parameter eventFieldDisplayId was null or undefined when calling getPivotValuesOnAProject.');
            }
            const localVarPath = `/projects/{project_id}/pivots/{event_field_display_id}/values`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_field_display_id"}}`, encodeURIComponent(String(eventFieldDisplayId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = (base as any).toISOString();
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List values of a Pivot on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {string} eventFieldDisplayId
         * @param {Filters6} [filters]
         * @param {string} [sort]
         * @param {Date} [base]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotValuesOnAnError(projectId: string, errorId: string, eventFieldDisplayId: string, filters?: Filters6, sort?: string, base?: Date, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getPivotValuesOnAnError.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling getPivotValuesOnAnError.');
            }
            // verify required parameter 'eventFieldDisplayId' is not null or undefined
            if (eventFieldDisplayId === null || eventFieldDisplayId === undefined) {
                throw new RequiredError('eventFieldDisplayId', 'Required parameter eventFieldDisplayId was null or undefined when calling getPivotValuesOnAnError.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}/pivots/{event_field_display_id}/values`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)))
                .replace(`{${"event_field_display_id"}}`, encodeURIComponent(String(eventFieldDisplayId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = (base as any).toISOString();
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Pivots on a Project
         * @param {string} projectId
         * @param {Filters7} [filters]
         * @param {number} [summarySize]
         * @param {Array<string>} [pivots]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotsOnAProject(projectId: string, filters?: Filters7, summarySize?: number, pivots?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getPivotsOnAProject.');
            }
            const localVarPath = `/projects/{project_id}/pivots`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (summarySize !== undefined) {
                localVarQueryParameter['summary_size'] = summarySize;
            }

            if (pivots) {
                localVarQueryParameter['pivots'] = pivots;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the events of an error. If you require a feed of all new events as they are reported consider setting up a webhook integration instead.
         * @summary List the Events on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters1} [filters]
         * @param {boolean} [fullReports]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsOnError(projectId: string, errorId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters1, fullReports?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listEventsOnError.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling listEventsOnError.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}/events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = (base as any).toISOString();
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fullReports !== undefined) {
                localVarQueryParameter['full_reports'] = fullReports;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the Events on a Project
         * @param {string} projectId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters2} [filters]
         * @param {boolean} [fullReports]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsOnProject(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters2, fullReports?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listEventsOnProject.');
            }
            const localVarPath = `/projects/{project_id}/events`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = (base as any).toISOString();
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fullReports !== undefined) {
                localVarQueryParameter['full_reports'] = fullReports;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Pivots on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {Filters5} [filters]
         * @param {number} [summarySize]
         * @param {Array<string>} [pivots]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPivotsOnAnError(projectId: string, errorId: string, filters?: Filters5, summarySize?: number, pivots?: Array<string>, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listPivotsOnAnError.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling listPivotsOnAnError.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}/pivots`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (summarySize !== undefined) {
                localVarQueryParameter['summary_size'] = summarySize;
            }

            if (pivots) {
                localVarQueryParameter['pivots'] = pivots;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the errors on a project. If you require a feed of all new errors as they are reported consider setting up a webhook integration instead.
         * @summary List the Errors on a Project
         * @param {string} projectId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters} [filters]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectErrors(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectErrors.');
            }
            const localVarPath = `/projects/{project_id}/errors`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = (base as any).toISOString();
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an Error
         * @param {ErrorsErrorIdBody} body
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateErrorOnProject(body: ErrorsErrorIdBody, projectId: string, errorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateErrorOnProject.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling updateErrorOnProject.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling updateErrorOnProject.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ErrorsErrorIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary View an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewErrorOnProject(projectId: string, errorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling viewErrorOnProject.');
            }
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling viewErrorOnProject.');
            }
            const localVarPath = `/projects/{project_id}/errors/{error_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note that event objects can include custom metadata and diagnostic fields configured directly in your app or added by the notifier library. The API preserves the original casing and key format as received, so any casing, including both snake_case and camelCase, may be valid for some fields.
         * @summary View an Event
         * @param {string} projectId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewEventById(projectId: string, eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling viewEventById.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId', 'Required parameter eventId was null or undefined when calling viewEventById.');
            }
            const localVarPath = `/projects/{project_id}/events/{event_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary View the latest Event on an Error
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewLatestEventOnError(errorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'errorId' is not null or undefined
            if (errorId === null || errorId === undefined) {
                throw new RequiredError('errorId', 'Required parameter errorId was null or undefined when calling viewLatestEventOnError.');
            }
            const localVarPath = `/errors/{error_id}/latest_event`
                .replace(`{${"error_id"}}`, encodeURIComponent(String(errorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorsApi - functional programming interface
 * @export
 */
export const ErrorsApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Bulk Update Errors
         * @param {ProjectIdErrorsBody} body
         * @param {string} projectId
         * @param {Array<string>} errorIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateErrors(body: ProjectIdErrorsBody, projectId: string, errorIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).bulkUpdateErrors(body, projectId, errorIds, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all Error and Event data in a project. Use with caution. This action cannot be reversed.
         * @summary Delete all Errors in a Project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllErrorsInProject(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).deleteAllErrorsInProject(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteErrorOnProject(projectId: string, errorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).deleteErrorOnProject(projectId, errorId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an Event
         * @param {string} projectId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById(projectId: string, eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).deleteEventById(projectId, eventId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Counts for an Error in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
         * @summary List the Trends for an Error
         * @param {string} projectId ID of the Project
         * @param {string} errorId ID of the error
         * @param {Filters3} [filters] Search filters to restrict the events reported in the trend
         * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
         * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketedAndUnbucketedTrendsOnError(projectId: string, errorId: string, filters?: Filters3, bucketsCount?: number, resolution?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).getBucketedAndUnbucketedTrendsOnError(projectId, errorId, filters, bucketsCount, resolution, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Counts for a Project in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
         * @summary List the Trends for a Project
         * @param {string} projectId ID of the project
         * @param {Filters4} [filters] Search filters to restrict the events reported in the trend
         * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
         * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketedAndUnbucketedTrendsOnProject(projectId: string, filters?: Filters4, bucketsCount?: number, resolution?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).getBucketedAndUnbucketedTrendsOnProject(projectId, filters, bucketsCount, resolution, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List values of a Pivot on a Project
         * @param {string} projectId
         * @param {string} eventFieldDisplayId
         * @param {Filters8} [filters]
         * @param {string} [sort]
         * @param {Date} [base]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotValuesOnAProject(projectId: string, eventFieldDisplayId: string, filters?: Filters8, sort?: string, base?: Date, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2008>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).getPivotValuesOnAProject(projectId, eventFieldDisplayId, filters, sort, base, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List values of a Pivot on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {string} eventFieldDisplayId
         * @param {Filters6} [filters]
         * @param {string} [sort]
         * @param {Date} [base]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotValuesOnAnError(projectId: string, errorId: string, eventFieldDisplayId: string, filters?: Filters6, sort?: string, base?: Date, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2008>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).getPivotValuesOnAnError(projectId, errorId, eventFieldDisplayId, filters, sort, base, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Pivots on a Project
         * @param {string} projectId
         * @param {Filters7} [filters]
         * @param {number} [summarySize]
         * @param {Array<string>} [pivots]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotsOnAProject(projectId: string, filters?: Filters7, summarySize?: number, pivots?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2007>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).getPivotsOnAProject(projectId, filters, summarySize, pivots, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of the events of an error. If you require a feed of all new events as they are reported consider setting up a webhook integration instead.
         * @summary List the Events on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters1} [filters]
         * @param {boolean} [fullReports]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsOnError(projectId: string, errorId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters1, fullReports?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2006>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).listEventsOnError(projectId, errorId, base, sort, direction, perPage, filters, fullReports, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List the Events on a Project
         * @param {string} projectId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters2} [filters]
         * @param {boolean} [fullReports]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsOnProject(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters2, fullReports?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2006>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).listEventsOnProject(projectId, base, sort, direction, perPage, filters, fullReports, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Pivots on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {Filters5} [filters]
         * @param {number} [summarySize]
         * @param {Array<string>} [pivots]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPivotsOnAnError(projectId: string, errorId: string, filters?: Filters5, summarySize?: number, pivots?: Array<string>, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2007>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).listPivotsOnAnError(projectId, errorId, filters, summarySize, pivots, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of the errors on a project. If you require a feed of all new errors as they are reported consider setting up a webhook integration instead.
         * @summary List the Errors on a Project
         * @param {string} projectId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters} [filters]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectErrors(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).listProjectErrors(projectId, base, sort, direction, perPage, filters, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an Error
         * @param {ErrorsErrorIdBody} body
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateErrorOnProject(body: ErrorsErrorIdBody, projectId: string, errorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).updateErrorOnProject(body, projectId, errorId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary View an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewErrorOnProject(projectId: string, errorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).viewErrorOnProject(projectId, errorId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Note that event objects can include custom metadata and diagnostic fields configured directly in your app or added by the notifier library. The API preserves the original casing and key format as received, so any casing, including both snake_case and camelCase, may be valid for some fields.
         * @summary View an Event
         * @param {string} projectId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewEventById(projectId: string, eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).viewEventById(projectId, eventId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary View the latest Event on an Error
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewLatestEventOnError(errorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = ErrorsApiFetchParamCreator(configuration).viewLatestEventOnError(errorId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ErrorsApi - factory interface
 * @export
 */
export const ErrorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Bulk Update Errors
         * @param {ProjectIdErrorsBody} body
         * @param {string} projectId
         * @param {Array<string>} errorIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateErrors(body: ProjectIdErrorsBody, projectId: string, errorIds: Array<string>, options?: any) {
            return ErrorsApiFp(configuration).bulkUpdateErrors(body, projectId, errorIds, options)(fetch, basePath);
        },
        /**
         * Deletes all Error and Event data in a project. Use with caution. This action cannot be reversed.
         * @summary Delete all Errors in a Project
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllErrorsInProject(projectId: string, options?: any) {
            return ErrorsApiFp(configuration).deleteAllErrorsInProject(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteErrorOnProject(projectId: string, errorId: string, options?: any) {
            return ErrorsApiFp(configuration).deleteErrorOnProject(projectId, errorId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete an Event
         * @param {string} projectId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventById(projectId: string, eventId: string, options?: any) {
            return ErrorsApiFp(configuration).deleteEventById(projectId, eventId, options)(fetch, basePath);
        },
        /**
         * Counts for an Error in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
         * @summary List the Trends for an Error
         * @param {string} projectId ID of the Project
         * @param {string} errorId ID of the error
         * @param {Filters3} [filters] Search filters to restrict the events reported in the trend
         * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
         * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketedAndUnbucketedTrendsOnError(projectId: string, errorId: string, filters?: Filters3, bucketsCount?: number, resolution?: string, options?: any) {
            return ErrorsApiFp(configuration).getBucketedAndUnbucketedTrendsOnError(projectId, errorId, filters, bucketsCount, resolution, options)(fetch, basePath);
        },
        /**
         * Counts for a Project in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
         * @summary List the Trends for a Project
         * @param {string} projectId ID of the project
         * @param {Filters4} [filters] Search filters to restrict the events reported in the trend
         * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
         * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBucketedAndUnbucketedTrendsOnProject(projectId: string, filters?: Filters4, bucketsCount?: number, resolution?: string, options?: any) {
            return ErrorsApiFp(configuration).getBucketedAndUnbucketedTrendsOnProject(projectId, filters, bucketsCount, resolution, options)(fetch, basePath);
        },
        /**
         *
         * @summary List values of a Pivot on a Project
         * @param {string} projectId
         * @param {string} eventFieldDisplayId
         * @param {Filters8} [filters]
         * @param {string} [sort]
         * @param {Date} [base]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotValuesOnAProject(projectId: string, eventFieldDisplayId: string, filters?: Filters8, sort?: string, base?: Date, perPage?: number, options?: any) {
            return ErrorsApiFp(configuration).getPivotValuesOnAProject(projectId, eventFieldDisplayId, filters, sort, base, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List values of a Pivot on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {string} eventFieldDisplayId
         * @param {Filters6} [filters]
         * @param {string} [sort]
         * @param {Date} [base]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotValuesOnAnError(projectId: string, errorId: string, eventFieldDisplayId: string, filters?: Filters6, sort?: string, base?: Date, perPage?: number, options?: any) {
            return ErrorsApiFp(configuration).getPivotValuesOnAnError(projectId, errorId, eventFieldDisplayId, filters, sort, base, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Pivots on a Project
         * @param {string} projectId
         * @param {Filters7} [filters]
         * @param {number} [summarySize]
         * @param {Array<string>} [pivots]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPivotsOnAProject(projectId: string, filters?: Filters7, summarySize?: number, pivots?: Array<string>, options?: any) {
            return ErrorsApiFp(configuration).getPivotsOnAProject(projectId, filters, summarySize, pivots, options)(fetch, basePath);
        },
        /**
         * Get a list of the events of an error. If you require a feed of all new events as they are reported consider setting up a webhook integration instead.
         * @summary List the Events on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters1} [filters]
         * @param {boolean} [fullReports]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsOnError(projectId: string, errorId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters1, fullReports?: boolean, options?: any) {
            return ErrorsApiFp(configuration).listEventsOnError(projectId, errorId, base, sort, direction, perPage, filters, fullReports, options)(fetch, basePath);
        },
        /**
         *
         * @summary List the Events on a Project
         * @param {string} projectId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters2} [filters]
         * @param {boolean} [fullReports]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEventsOnProject(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters2, fullReports?: boolean, options?: any) {
            return ErrorsApiFp(configuration).listEventsOnProject(projectId, base, sort, direction, perPage, filters, fullReports, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Pivots on an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {Filters5} [filters]
         * @param {number} [summarySize]
         * @param {Array<string>} [pivots]
         * @param {number} [perPage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPivotsOnAnError(projectId: string, errorId: string, filters?: Filters5, summarySize?: number, pivots?: Array<string>, perPage?: number, options?: any) {
            return ErrorsApiFp(configuration).listPivotsOnAnError(projectId, errorId, filters, summarySize, pivots, perPage, options)(fetch, basePath);
        },
        /**
         * Get a list of the errors on a project. If you require a feed of all new errors as they are reported consider setting up a webhook integration instead.
         * @summary List the Errors on a Project
         * @param {string} projectId
         * @param {Date} [base]
         * @param {string} [sort]
         * @param {string} [direction]
         * @param {number} [perPage]
         * @param {Filters} [filters]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectErrors(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters, options?: any) {
            return ErrorsApiFp(configuration).listProjectErrors(projectId, base, sort, direction, perPage, filters, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an Error
         * @param {ErrorsErrorIdBody} body
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateErrorOnProject(body: ErrorsErrorIdBody, projectId: string, errorId: string, options?: any) {
            return ErrorsApiFp(configuration).updateErrorOnProject(body, projectId, errorId, options)(fetch, basePath);
        },
        /**
         *
         * @summary View an Error
         * @param {string} projectId
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewErrorOnProject(projectId: string, errorId: string, options?: any) {
            return ErrorsApiFp(configuration).viewErrorOnProject(projectId, errorId, options)(fetch, basePath);
        },
        /**
         * Note that event objects can include custom metadata and diagnostic fields configured directly in your app or added by the notifier library. The API preserves the original casing and key format as received, so any casing, including both snake_case and camelCase, may be valid for some fields.
         * @summary View an Event
         * @param {string} projectId
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewEventById(projectId: string, eventId: string, options?: any) {
            return ErrorsApiFp(configuration).viewEventById(projectId, eventId, options)(fetch, basePath);
        },
        /**
         *
         * @summary View the latest Event on an Error
         * @param {string} errorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewLatestEventOnError(errorId: string, options?: any) {
            return ErrorsApiFp(configuration).viewLatestEventOnError(errorId, options)(fetch, basePath);
        },
    };
};

/**
 * ErrorsApi - object-oriented interface
 * @export
 * @class ErrorsApi
 * @extends {BaseAPI}
 */
export class ErrorsApi extends BaseAPI {
    /**
     *
     * @summary Bulk Update Errors
     * @param {ProjectIdErrorsBody} body
     * @param {string} projectId
     * @param {Array<string>} errorIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public bulkUpdateErrors(body: ProjectIdErrorsBody, projectId: string, errorIds: Array<string>, options?: any) {
        return ErrorsApiFp(this.configuration).bulkUpdateErrors(body, projectId, errorIds, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes all Error and Event data in a project. Use with caution. This action cannot be reversed.
     * @summary Delete all Errors in a Project
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public deleteAllErrorsInProject(projectId: string, options?: any) {
        return ErrorsApiFp(this.configuration).deleteAllErrorsInProject(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete an Error
     * @param {string} projectId
     * @param {string} errorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public deleteErrorOnProject(projectId: string, errorId: string, options?: any) {
        return ErrorsApiFp(this.configuration).deleteErrorOnProject(projectId, errorId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete an Event
     * @param {string} projectId
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public deleteEventById(projectId: string, eventId: string, options?: any) {
        return ErrorsApiFp(this.configuration).deleteEventById(projectId, eventId, options)(this.fetch, this.basePath);
    }

    /**
     * Counts for an Error in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
     * @summary List the Trends for an Error
     * @param {string} projectId ID of the Project
     * @param {string} errorId ID of the error
     * @param {Filters3} [filters] Search filters to restrict the events reported in the trend
     * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
     * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public getBucketedAndUnbucketedTrendsOnError(projectId: string, errorId: string, filters?: Filters3, bucketsCount?: number, resolution?: string, options?: any) {
        return ErrorsApiFp(this.configuration).getBucketedAndUnbucketedTrendsOnError(projectId, errorId, filters, bucketsCount, resolution, options)(this.fetch, this.basePath);
    }

    /**
     * Counts for a Project in a given time range, suitable for drawing histograms. Will return a maximum of 50 buckets (when using `buckets_count`) or 2000 data points (when using `resolution`).
     * @summary List the Trends for a Project
     * @param {string} projectId ID of the project
     * @param {Filters4} [filters] Search filters to restrict the events reported in the trend
     * @param {number} [bucketsCount] Number of buckets to group trend data into (max 50)
     * @param {string} [resolution] The trend data will be grouped so that each bucket spans the given time period
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public getBucketedAndUnbucketedTrendsOnProject(projectId: string, filters?: Filters4, bucketsCount?: number, resolution?: string, options?: any) {
        return ErrorsApiFp(this.configuration).getBucketedAndUnbucketedTrendsOnProject(projectId, filters, bucketsCount, resolution, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List values of a Pivot on a Project
     * @param {string} projectId
     * @param {string} eventFieldDisplayId
     * @param {Filters8} [filters]
     * @param {string} [sort]
     * @param {Date} [base]
     * @param {number} [perPage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public getPivotValuesOnAProject(projectId: string, eventFieldDisplayId: string, filters?: Filters8, sort?: string, base?: Date, perPage?: number, options?: any) {
        return ErrorsApiFp(this.configuration).getPivotValuesOnAProject(projectId, eventFieldDisplayId, filters, sort, base, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List values of a Pivot on an Error
     * @param {string} projectId
     * @param {string} errorId
     * @param {string} eventFieldDisplayId
     * @param {Filters6} [filters]
     * @param {string} [sort]
     * @param {Date} [base]
     * @param {number} [perPage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public getPivotValuesOnAnError(projectId: string, errorId: string, eventFieldDisplayId: string, filters?: Filters6, sort?: string, base?: Date, perPage?: number, options?: any) {
        return ErrorsApiFp(this.configuration).getPivotValuesOnAnError(projectId, errorId, eventFieldDisplayId, filters, sort, base, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Pivots on a Project
     * @param {string} projectId
     * @param {Filters7} [filters]
     * @param {number} [summarySize]
     * @param {Array<string>} [pivots]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public getPivotsOnAProject(projectId: string, filters?: Filters7, summarySize?: number, pivots?: Array<string>, options?: any) {
        return ErrorsApiFp(this.configuration).getPivotsOnAProject(projectId, filters, summarySize, pivots, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of the events of an error. If you require a feed of all new events as they are reported consider setting up a webhook integration instead.
     * @summary List the Events on an Error
     * @param {string} projectId
     * @param {string} errorId
     * @param {Date} [base]
     * @param {string} [sort]
     * @param {string} [direction]
     * @param {number} [perPage]
     * @param {Filters1} [filters]
     * @param {boolean} [fullReports]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public listEventsOnError(projectId: string, errorId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters1, fullReports?: boolean, options?: any) {
        return ErrorsApiFp(this.configuration).listEventsOnError(projectId, errorId, base, sort, direction, perPage, filters, fullReports, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List the Events on a Project
     * @param {string} projectId
     * @param {Date} [base]
     * @param {string} [sort]
     * @param {string} [direction]
     * @param {number} [perPage]
     * @param {Filters2} [filters]
     * @param {boolean} [fullReports]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public listEventsOnProject(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters2, fullReports?: boolean, options?: any) {
        return ErrorsApiFp(this.configuration).listEventsOnProject(projectId, base, sort, direction, perPage, filters, fullReports, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Pivots on an Error
     * @param {string} projectId
     * @param {string} errorId
     * @param {Filters5} [filters]
     * @param {number} [summarySize]
     * @param {Array<string>} [pivots]
     * @param {number} [perPage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public listPivotsOnAnError(projectId: string, errorId: string, filters?: Filters5, summarySize?: number, pivots?: Array<string>, perPage?: number, options?: any) {
        return ErrorsApiFp(this.configuration).listPivotsOnAnError(projectId, errorId, filters, summarySize, pivots, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of the errors on a project. If you require a feed of all new errors as they are reported consider setting up a webhook integration instead.
     * @summary List the Errors on a Project
     * @param {string} projectId
     * @param {Date} [base]
     * @param {string} [sort]
     * @param {string} [direction]
     * @param {number} [perPage]
     * @param {Filters} [filters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public listProjectErrors(projectId: string, base?: Date, sort?: string, direction?: string, perPage?: number, filters?: Filters, options?: any) {
        return ErrorsApiFp(this.configuration).listProjectErrors(projectId, base, sort, direction, perPage, filters, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an Error
     * @param {ErrorsErrorIdBody} body
     * @param {string} projectId
     * @param {string} errorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public updateErrorOnProject(body: ErrorsErrorIdBody, projectId: string, errorId: string, options?: any) {
        return ErrorsApiFp(this.configuration).updateErrorOnProject(body, projectId, errorId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary View an Error
     * @param {string} projectId
     * @param {string} errorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public viewErrorOnProject(projectId: string, errorId: string, options?: any) {
        return ErrorsApiFp(this.configuration).viewErrorOnProject(projectId, errorId, options)(this.fetch, this.basePath);
    }

    /**
     * Note that event objects can include custom metadata and diagnostic fields configured directly in your app or added by the notifier library. The API preserves the original casing and key format as received, so any casing, including both snake_case and camelCase, may be valid for some fields.
     * @summary View an Event
     * @param {string} projectId
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public viewEventById(projectId: string, eventId: string, options?: any) {
        return ErrorsApiFp(this.configuration).viewEventById(projectId, eventId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary View the latest Event on an Error
     * @param {string} errorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorsApi
     */
    public viewLatestEventOnError(errorId: string, options?: any) {
        return ErrorsApiFp(this.configuration).viewLatestEventOnError(errorId, options)(this.fetch, this.basePath);
    }

}
/**
 * IntegrationsApi - fetch parameter creator
 * @export
 */
export const IntegrationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test a configured integration. For issue-tracker integrations this will create a test issue. For team-notification, data-forwarding and on-call notifications it will send a test alert/message. To test an integration without saving the configuration first, use /integrations/test.
         * @summary Test a Configured Integration
         * @param {IdTestBody} body
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationTest(body: IdTestBody, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling configuredIntegrationTest.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling configuredIntegrationTest.');
            }
            const localVarPath = `/configured_integrations/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdTestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the full description of a configured integration.
         * @summary Get a Configured Integration
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrations(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling configuredIntegrations.');
            }
            const localVarPath = `/configured_integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the configuration for an integration.
         * @summary Delete a Configured Integration
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationsDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling configuredIntegrationsDelete.');
            }
            const localVarPath = `/configured_integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the configuration for an integration on a project.
         * @summary Update a Configured Integration
         * @param {ConfiguredIntegrationsIdBody} body
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationsUpdate(body: ConfiguredIntegrationsIdBody, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling configuredIntegrationsUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling configuredIntegrationsUpdate.');
            }
            const localVarPath = `/configured_integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfiguredIntegrationsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about all the integrations supported and how they can be configured. This includes details of the fields needed to set them up.
         * @summary List the supported Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(options: any = {}): FetchArgs {
            const localVarPath = `/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an integration using the configuration parameters provided without saving it as a configured integration. For `issue-tracker` integrations this will created a test issue. For `team-notification`, `data-forwarding` and `on-call` notifications it will send a test alert/message. Use the [Configured Integrations](/insight-hub/docs/data-access-api-v-2#/Integrations/post_configured_integrations__id__test) test endpoint for integrations which are already configured.
         * @summary Test an Integration
         * @param {IntegrationsTestBody} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsTest(body: IntegrationsTestBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling integrationsTest.');
            }
            const localVarPath = `/integrations/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationsTestBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the Integration Connections for an Organization
         * @param {string} organizationId ID of the organization the integration connections belongs to.
         * @param {string} [type] The external software to communicate with. Currently this can only be &#x27;jira&#x27; or nil.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationIntegrationConnections(organizationId: string, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationIntegrationConnections.');
            }
            const localVarPath = `/organizations/{organization_id}/integration_connections`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List summaries of all the configured integrations on a project. Summaries are lightweight descriptions of a configured integration. For a full description, use the Get a Configured Integration endpoint.
         * @summary List Summaries of the Configured Integrations for a Project
         * @param {string} projectId
         * @param {number} [perPage]
         * @param {number} [pageToken]
         * @param {string} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfiguredIntegrationSummaries(projectId: string, perPage?: number, pageToken?: number, category?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectConfiguredIntegrationSummaries.');
            }
            const localVarPath = `/projects/{project_id}/configured_integration_summaries`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure a new integration for a project. Only one issue-tracker-type integration is allowed on a project, unless your plan supports multiple issue trackers.
         * @summary Configure an Integration
         * @param {ProjectIdConfiguredIntegrationsBody} body
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfiguredIntegrations(body: ProjectIdConfiguredIntegrationsBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectConfiguredIntegrations.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectConfiguredIntegrations.');
            }
            const localVarPath = `/projects/{project_id}/configured_integrations`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdConfiguredIntegrationsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a condition for automatic integration behavior.
         * @summary Update a Configured Integration's Trigger Config
         * @param {TriggerConfigsTriggerConfigKeyBody} body
         * @param {string} id
         * @param {string} triggerConfigKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguredIntegrationsTriggerConfig(body: TriggerConfigsTriggerConfigKeyBody, id: string, triggerConfigKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateConfiguredIntegrationsTriggerConfig.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateConfiguredIntegrationsTriggerConfig.');
            }
            // verify required parameter 'triggerConfigKey' is not null or undefined
            if (triggerConfigKey === null || triggerConfigKey === undefined) {
                throw new RequiredError('triggerConfigKey', 'Required parameter triggerConfigKey was null or undefined when calling updateConfiguredIntegrationsTriggerConfig.');
            }
            const localVarPath = `/configured_integrations/{id}/trigger_configs/{trigger_config_key}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"trigger_config_key"}}`, encodeURIComponent(String(triggerConfigKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TriggerConfigsTriggerConfigKeyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Test a configured integration. For issue-tracker integrations this will create a test issue. For team-notification, data-forwarding and on-call notifications it will send a test alert/message. To test an integration without saving the configuration first, use /integrations/test.
         * @summary Test a Configured Integration
         * @param {IdTestBody} body
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationTest(body: IdTestBody, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).configuredIntegrationTest(body, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the full description of a configured integration.
         * @summary Get a Configured Integration
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrations(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).configuredIntegrations(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the configuration for an integration.
         * @summary Delete a Configured Integration
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationsDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).configuredIntegrationsDelete(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the configuration for an integration on a project.
         * @summary Update a Configured Integration
         * @param {ConfiguredIntegrationsIdBody} body
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationsUpdate(body: ConfiguredIntegrationsIdBody, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).configuredIntegrationsUpdate(body, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about all the integrations supported and how they can be configured. This includes details of the fields needed to set them up.
         * @summary List the supported Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2009>> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).getIntegrations(options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Test an integration using the configuration parameters provided without saving it as a configured integration. For `issue-tracker` integrations this will created a test issue. For `team-notification`, `data-forwarding` and `on-call` notifications it will send a test alert/message. Use the [Configured Integrations](/insight-hub/docs/data-access-api-v-2#/Integrations/post_configured_integrations__id__test) test endpoint for integrations which are already configured.
         * @summary Test an Integration
         * @param {IntegrationsTestBody} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsTest(body: IntegrationsTestBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).integrationsTest(body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List the Integration Connections for an Organization
         * @param {string} organizationId ID of the organization the integration connections belongs to.
         * @param {string} [type] The external software to communicate with. Currently this can only be &#x27;jira&#x27; or nil.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationIntegrationConnections(organizationId: string, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20013>> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).listOrganizationIntegrationConnections(organizationId, type, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List summaries of all the configured integrations on a project. Summaries are lightweight descriptions of a configured integration. For a full description, use the Get a Configured Integration endpoint.
         * @summary List Summaries of the Configured Integrations for a Project
         * @param {string} projectId
         * @param {number} [perPage]
         * @param {number} [pageToken]
         * @param {string} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfiguredIntegrationSummaries(projectId: string, perPage?: number, pageToken?: number, category?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20012>> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).projectConfiguredIntegrationSummaries(projectId, perPage, pageToken, category, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Configure a new integration for a project. Only one issue-tracker-type integration is allowed on a project, unless your plan supports multiple issue trackers.
         * @summary Configure an Integration
         * @param {ProjectIdConfiguredIntegrationsBody} body
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfiguredIntegrations(body: ProjectIdConfiguredIntegrationsBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).projectConfiguredIntegrations(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set a condition for automatic integration behavior.
         * @summary Update a Configured Integration's Trigger Config
         * @param {TriggerConfigsTriggerConfigKeyBody} body
         * @param {string} id
         * @param {string} triggerConfigKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguredIntegrationsTriggerConfig(body: TriggerConfigsTriggerConfigKeyBody, id: string, triggerConfigKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).updateConfiguredIntegrationsTriggerConfig(body, id, triggerConfigKey, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Test a configured integration. For issue-tracker integrations this will create a test issue. For team-notification, data-forwarding and on-call notifications it will send a test alert/message. To test an integration without saving the configuration first, use /integrations/test.
         * @summary Test a Configured Integration
         * @param {IdTestBody} body
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationTest(body: IdTestBody, id: string, options?: any) {
            return IntegrationsApiFp(configuration).configuredIntegrationTest(body, id, options)(fetch, basePath);
        },
        /**
         * Get the full description of a configured integration.
         * @summary Get a Configured Integration
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrations(id: string, options?: any) {
            return IntegrationsApiFp(configuration).configuredIntegrations(id, options)(fetch, basePath);
        },
        /**
         * Delete the configuration for an integration.
         * @summary Delete a Configured Integration
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationsDelete(id: string, options?: any) {
            return IntegrationsApiFp(configuration).configuredIntegrationsDelete(id, options)(fetch, basePath);
        },
        /**
         * Update the configuration for an integration on a project.
         * @summary Update a Configured Integration
         * @param {ConfiguredIntegrationsIdBody} body
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configuredIntegrationsUpdate(body: ConfiguredIntegrationsIdBody, id: string, options?: any) {
            return IntegrationsApiFp(configuration).configuredIntegrationsUpdate(body, id, options)(fetch, basePath);
        },
        /**
         * Get information about all the integrations supported and how they can be configured. This includes details of the fields needed to set them up.
         * @summary List the supported Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(options?: any) {
            return IntegrationsApiFp(configuration).getIntegrations(options)(fetch, basePath);
        },
        /**
         * Test an integration using the configuration parameters provided without saving it as a configured integration. For `issue-tracker` integrations this will created a test issue. For `team-notification`, `data-forwarding` and `on-call` notifications it will send a test alert/message. Use the [Configured Integrations](/insight-hub/docs/data-access-api-v-2#/Integrations/post_configured_integrations__id__test) test endpoint for integrations which are already configured.
         * @summary Test an Integration
         * @param {IntegrationsTestBody} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsTest(body: IntegrationsTestBody, options?: any) {
            return IntegrationsApiFp(configuration).integrationsTest(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary List the Integration Connections for an Organization
         * @param {string} organizationId ID of the organization the integration connections belongs to.
         * @param {string} [type] The external software to communicate with. Currently this can only be &#x27;jira&#x27; or nil.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationIntegrationConnections(organizationId: string, type?: string, options?: any) {
            return IntegrationsApiFp(configuration).listOrganizationIntegrationConnections(organizationId, type, options)(fetch, basePath);
        },
        /**
         * List summaries of all the configured integrations on a project. Summaries are lightweight descriptions of a configured integration. For a full description, use the Get a Configured Integration endpoint.
         * @summary List Summaries of the Configured Integrations for a Project
         * @param {string} projectId
         * @param {number} [perPage]
         * @param {number} [pageToken]
         * @param {string} [category]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfiguredIntegrationSummaries(projectId: string, perPage?: number, pageToken?: number, category?: string, options?: any) {
            return IntegrationsApiFp(configuration).projectConfiguredIntegrationSummaries(projectId, perPage, pageToken, category, options)(fetch, basePath);
        },
        /**
         * Configure a new integration for a project. Only one issue-tracker-type integration is allowed on a project, unless your plan supports multiple issue trackers.
         * @summary Configure an Integration
         * @param {ProjectIdConfiguredIntegrationsBody} body
         * @param {string} projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectConfiguredIntegrations(body: ProjectIdConfiguredIntegrationsBody, projectId: string, options?: any) {
            return IntegrationsApiFp(configuration).projectConfiguredIntegrations(body, projectId, options)(fetch, basePath);
        },
        /**
         * Set a condition for automatic integration behavior.
         * @summary Update a Configured Integration's Trigger Config
         * @param {TriggerConfigsTriggerConfigKeyBody} body
         * @param {string} id
         * @param {string} triggerConfigKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguredIntegrationsTriggerConfig(body: TriggerConfigsTriggerConfigKeyBody, id: string, triggerConfigKey: string, options?: any) {
            return IntegrationsApiFp(configuration).updateConfiguredIntegrationsTriggerConfig(body, id, triggerConfigKey, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Test a configured integration. For issue-tracker integrations this will create a test issue. For team-notification, data-forwarding and on-call notifications it will send a test alert/message. To test an integration without saving the configuration first, use /integrations/test.
     * @summary Test a Configured Integration
     * @param {IdTestBody} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public configuredIntegrationTest(body: IdTestBody, id: string, options?: any) {
        return IntegrationsApiFp(this.configuration).configuredIntegrationTest(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get the full description of a configured integration.
     * @summary Get a Configured Integration
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public configuredIntegrations(id: string, options?: any) {
        return IntegrationsApiFp(this.configuration).configuredIntegrations(id, options)(this.fetch, this.basePath);
    }

    /**
     * Delete the configuration for an integration.
     * @summary Delete a Configured Integration
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public configuredIntegrationsDelete(id: string, options?: any) {
        return IntegrationsApiFp(this.configuration).configuredIntegrationsDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Update the configuration for an integration on a project.
     * @summary Update a Configured Integration
     * @param {ConfiguredIntegrationsIdBody} body
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public configuredIntegrationsUpdate(body: ConfiguredIntegrationsIdBody, id: string, options?: any) {
        return IntegrationsApiFp(this.configuration).configuredIntegrationsUpdate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about all the integrations supported and how they can be configured. This includes details of the fields needed to set them up.
     * @summary List the supported Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrations(options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegrations(options)(this.fetch, this.basePath);
    }

    /**
     * Test an integration using the configuration parameters provided without saving it as a configured integration. For `issue-tracker` integrations this will created a test issue. For `team-notification`, `data-forwarding` and `on-call` notifications it will send a test alert/message. Use the [Configured Integrations](/insight-hub/docs/data-access-api-v-2#/Integrations/post_configured_integrations__id__test) test endpoint for integrations which are already configured.
     * @summary Test an Integration
     * @param {IntegrationsTestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsTest(body: IntegrationsTestBody, options?: any) {
        return IntegrationsApiFp(this.configuration).integrationsTest(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List the Integration Connections for an Organization
     * @param {string} organizationId ID of the organization the integration connections belongs to.
     * @param {string} [type] The external software to communicate with. Currently this can only be &#x27;jira&#x27; or nil.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public listOrganizationIntegrationConnections(organizationId: string, type?: string, options?: any) {
        return IntegrationsApiFp(this.configuration).listOrganizationIntegrationConnections(organizationId, type, options)(this.fetch, this.basePath);
    }

    /**
     * List summaries of all the configured integrations on a project. Summaries are lightweight descriptions of a configured integration. For a full description, use the Get a Configured Integration endpoint.
     * @summary List Summaries of the Configured Integrations for a Project
     * @param {string} projectId
     * @param {number} [perPage]
     * @param {number} [pageToken]
     * @param {string} [category]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public projectConfiguredIntegrationSummaries(projectId: string, perPage?: number, pageToken?: number, category?: string, options?: any) {
        return IntegrationsApiFp(this.configuration).projectConfiguredIntegrationSummaries(projectId, perPage, pageToken, category, options)(this.fetch, this.basePath);
    }

    /**
     * Configure a new integration for a project. Only one issue-tracker-type integration is allowed on a project, unless your plan supports multiple issue trackers.
     * @summary Configure an Integration
     * @param {ProjectIdConfiguredIntegrationsBody} body
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public projectConfiguredIntegrations(body: ProjectIdConfiguredIntegrationsBody, projectId: string, options?: any) {
        return IntegrationsApiFp(this.configuration).projectConfiguredIntegrations(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     * Set a condition for automatic integration behavior.
     * @summary Update a Configured Integration's Trigger Config
     * @param {TriggerConfigsTriggerConfigKeyBody} body
     * @param {string} id
     * @param {string} triggerConfigKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateConfiguredIntegrationsTriggerConfig(body: TriggerConfigsTriggerConfigKeyBody, id: string, triggerConfigKey: string, options?: any) {
        return IntegrationsApiFp(this.configuration).updateConfiguredIntegrationsTriggerConfig(body, id, triggerConfigKey, options)(this.fetch, this.basePath);
    }

}
/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a collaborator to a list of teams, or all a collaborator to all the teams in this organization.
         * @summary Add a collaborator to a group of Teams
         * @param {IdTeamMembershipsBody} body
         * @param {string} organizationId The ID of the organization.
         * @param {string} id The ID of the collaborator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationCollaboratorTeamMemberships(body: IdTeamMembershipsBody, organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling addOrganizationCollaboratorTeamMemberships.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling addOrganizationCollaboratorTeamMemberships.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling addOrganizationCollaboratorTeamMemberships.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}/team_memberships`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdTeamMembershipsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add Collaborators to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {IdTeamMembershipsBody1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationTeamMemberships(organizationId: string, id: string, body?: IdTeamMembershipsBody1, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling addOrganizationTeamMemberships.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling addOrganizationTeamMemberships.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/team_memberships`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdTeamMembershipsBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk invite collaborators to your organization
         * @param {CollaboratorsBulkInviteBody} body
         * @param {string} organizationId the ID of your organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkInviteOrganizationCollaborators(body: CollaboratorsBulkInviteBody, organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling bulkInviteOrganizationCollaborators.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling bulkInviteOrganizationCollaborators.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/bulk_invite`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollaboratorsBulkInviteBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a Team
         * @param {string} organizationId ID of the organization
         * @param {OrganizationIdTeamsBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationTeam(organizationId: string, body?: OrganizationIdTeamsBody, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling createOrganizationTeam.');
            }
            const localVarPath = `/organizations/{organization_id}/teams`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationIdTeamsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScimCollaborator(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling createScimCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to add a group to your BugSnag organization.  Collaborators are not added when creating a group, so these must be added using the Update Group on an Organization endpoint after a group is created.
         * @summary Create Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {V2GroupsBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScimGroup(organizationId: string, body?: V2GroupsBody, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling createScimGroup.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Groups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2GroupsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCollaborator(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteOrganizationCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOrganizationCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a collaborator from a group of teams. The request body for this operation should be documented here: The request body would have matched the TeamIDRequest schema, but DELETE operations cannot have a request body in OpenAPI3. Example: {   \"team_ids\": [\"team_id_1\", \"team_id_2\"] }
         * @summary Remove a Collaborator from a group of Teams
         * @param {string} organizationId The ID of the organization.
         * @param {string} id The ID of the collaborator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCollaboratorTeamMemberships(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteOrganizationCollaboratorTeamMemberships.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOrganizationCollaboratorTeamMemberships.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}/team_memberships`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeam(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteOrganizationTeam.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOrganizationTeam.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request body requires a CollaboratorsRequest object with the following properties: - user_ids: array of user IDs to remove from the team
         * @summary Remove Collaborators from a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeamMemberships(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteOrganizationTeamMemberships.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOrganizationTeamMemberships.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/team_memberships`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request body requires a TeamProjectAccessesDelete object with the following properties: - project_ids: array of project IDs to remove access from
         * @summary Remove Project Access from a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeamProjectAccesses(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteOrganizationTeamProjectAccesses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteOrganizationTeamProjectAccesses.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/project_accesses`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScimCollaborator(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteScimCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteScimCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Users/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id ID of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScimGroup(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling deleteScimGroup.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteScimGroup.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Groups/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Show a Collaborator on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaborator(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOrganizationCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the details of a collaborator's access to a project.
         * @summary Show a Collaborator's Access Details for a Project
         * @param {string} organizationId The ID of the organization.
         * @param {string} collaboratorId The ID of the collaborator.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjectAccessById(organizationId: string, collaboratorId: string, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationCollaboratorProjectAccessById.');
            }
            // verify required parameter 'collaboratorId' is not null or undefined
            if (collaboratorId === null || collaboratorId === undefined) {
                throw new RequiredError('collaboratorId', 'Required parameter collaboratorId was null or undefined when calling getOrganizationCollaboratorProjectAccessById.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getOrganizationCollaboratorProjectAccessById.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{collaborator_id}/project_accesses/{project_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"collaborator_id"}}`, encodeURIComponent(String(collaboratorId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the project count of a collaborator
         * @summary View the project count of a collaborator
         * @param {string} organizationId ID of the organization
         * @param {Array<string>} collaboratorIds IDs of collaborators to view the project count of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjectAccessCounts(organizationId: string, collaboratorIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationCollaboratorProjectAccessCounts.');
            }
            // verify required parameter 'collaboratorIds' is not null or undefined
            if (collaboratorIds === null || collaboratorIds === undefined) {
                throw new RequiredError('collaboratorIds', 'Required parameter collaboratorIds was null or undefined when calling getOrganizationCollaboratorProjectAccessCounts.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/project_access_counts`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (collaboratorIds) {
                localVarQueryParameter['collaborator_ids'] = collaboratorIds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View Projects a Collaborator has access to
         * @summary View Projects a Collaborator has access to
         * @param {string} organizationId the ID of the organization
         * @param {string} collaboratorId the ID of the user
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjects(organizationId: string, collaboratorId: string, q?: string, sort?: string, direction?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationCollaboratorProjects.');
            }
            // verify required parameter 'collaboratorId' is not null or undefined
            if (collaboratorId === null || collaboratorId === undefined) {
                throw new RequiredError('collaboratorId', 'Required parameter collaboratorId was null or undefined when calling getOrganizationCollaboratorProjects.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{collaborator_id}/projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"collaborator_id"}}`, encodeURIComponent(String(collaboratorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Show the details of a team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTeam(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationTeam.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getOrganizationTeam.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show a collaborator in a project. Requires requesting user to have access to the given project.
         * @summary Show a collaborator in a project.
         * @param {string} projectId the ID of the project
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectCollaborator(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectCollaborator.');
            }
            const localVarPath = `/projects/{project_id}/collaborators/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Show a Collaborator on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScimCollaborator(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getScimCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getScimCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Users/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Show Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScimGroup(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getScimGroup.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getScimGroup.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Groups/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Invite a collaborator to your organization
         * @param {OrganizationIdCollaboratorsBody} body
         * @param {string} organizationId the ID of your organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteOrganizationCollaborator(body: OrganizationIdCollaboratorsBody, organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling inviteOrganizationCollaborator.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling inviteOrganizationCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationIdCollaboratorsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all projects a collaborator has access to within an organization.
         * @summary List project accesses for a collaborator
         * @param {string} organizationId The ID of the organization
         * @param {string} collaboratorId The ID of the collaborator
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorProjectAccesses(organizationId: string, collaboratorId: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationCollaboratorProjectAccesses.');
            }
            // verify required parameter 'collaboratorId' is not null or undefined
            if (collaboratorId === null || collaboratorId === undefined) {
                throw new RequiredError('collaboratorId', 'Required parameter collaboratorId was null or undefined when calling listOrganizationCollaboratorProjectAccesses.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{collaborator_id}/project_accesses`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"collaborator_id"}}`, encodeURIComponent(String(collaboratorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Suggested Teams for a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {string} [q] A partial or full team name to filter the results by
         * @param {boolean} [includeIsMember] Request all teams in the organization, including those that the collaborator is already on. By default only teams the collaborator is not a member of will be returned
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorSuggestedTeams(organizationId: string, id: string, q?: string, includeIsMember?: boolean, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationCollaboratorSuggestedTeams.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listOrganizationCollaboratorSuggestedTeams.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}/suggested_teams`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeIsMember !== undefined) {
                localVarQueryParameter['include_is_member'] = includeIsMember;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Teams for a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {string} [q] A partial or full team name to filter the results by
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorTeams(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationCollaboratorTeams.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listOrganizationCollaboratorTeams.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}/teams`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List all collaborators that are members of your organization
         * @param {string} organizationId the ID of your organization
         * @param {number} [perPage] Number of results per page
         * @param {string} [q] Search collaborators with names or emails matching parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaborators(organizationId: string, perPage?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationCollaborators.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the spans for a trace at an organizational level. Access to this endpoint is restricted on the distributed traces view permission.
         * @summary List Spans for a Trace
         * @param {string} organizationId The ID of the Organization to which the spans belong.
         * @param {string} traceId The ID of the Trace to which the spans belong.
         * @param {string} from Beginning of window to return spans from.
         * @param {string} to End of window to return spans from.
         * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSpans(organizationId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationSpans.');
            }
            // verify required parameter 'traceId' is not null or undefined
            if (traceId === null || traceId === undefined) {
                throw new RequiredError('traceId', 'Required parameter traceId was null or undefined when calling listOrganizationSpans.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from', 'Required parameter from was null or undefined when calling listOrganizationSpans.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to', 'Required parameter to was null or undefined when calling listOrganizationSpans.');
            }
            const localVarPath = `/organizations/{organization_id}/traces/{trace_id}/spans`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"trace_id"}}`, encodeURIComponent(String(traceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (targetSpanId !== undefined) {
                localVarQueryParameter['target_span_id'] = targetSpanId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List the Collaborators in a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full user name or email to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamCollaborators(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationTeamCollaborators.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listOrganizationTeamCollaborators.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/collaborators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Project Access for a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full project name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] A token for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamProjectAccesses(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationTeamProjectAccesses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listOrganizationTeamProjectAccesses.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/project_accesses`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Suggested Collaborators to Add to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full user name or email to filter the results by.
         * @param {boolean} [includeHasAccess] Request all collaborators in the organization, including those that are not members of the team. By default only collaborators who are not members of the team will be returned.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamSuggestedCollaborators(organizationId: string, id: string, q?: string, includeHasAccess?: boolean, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationTeamSuggestedCollaborators.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listOrganizationTeamSuggestedCollaborators.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/suggested_collaborators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeHasAccess !== undefined) {
                localVarQueryParameter['include_has_access'] = includeHasAccess;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suggest a list of projects from the organization that the team could be given access to.
         * @summary Suggest Projects to Add to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {boolean} [includeHasAccess] should projects the team already has access to be included?
         * @param {string} [q] A partial or full project name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamSuggestedProjects(organizationId: string, id: string, includeHasAccess?: boolean, q?: string, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationTeamSuggestedProjects.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listOrganizationTeamSuggestedProjects.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/suggested_projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (includeHasAccess !== undefined) {
                localVarQueryParameter['include_has_access'] = includeHasAccess;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Teams from a query
         * @param {string} organizationId ID of the organization
         * @param {string} [q] A partial or full team name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] Token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeams(organizationId: string, q?: string, perPage?: number, offset?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listOrganizationTeams.');
            }
            const localVarPath = `/organizations/{organization_id}/teams`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all collaborators that have access to a project.
         * @summary List Collaborators on a Project
         * @param {string} projectId the ID of the project
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectCollaborators(projectId: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectCollaborators.');
            }
            const localVarPath = `/projects/{project_id}/collaborators`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of users for the organization.  The request may be filtered by `userName` equality by passing a filter of the form `userName eq \"james@example.com\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
         * @summary List Collaborators on an Organization
         * @param {string} organizationId ID of the organization
         * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
         * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
         * @param {string} [filter] filter the results by userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScimCollaborators(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listScimCollaborators.');
            }
            // verify required parameter 'startIndex' is not null or undefined
            if (startIndex === null || startIndex === undefined) {
                throw new RequiredError('startIndex', 'Required parameter startIndex was null or undefined when calling listScimCollaborators.');
            }
            // verify required parameter 'itemsPerPage' is not null or undefined
            if (itemsPerPage === null || itemsPerPage === undefined) {
                throw new RequiredError('itemsPerPage', 'Required parameter itemsPerPage was null or undefined when calling listScimCollaborators.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['itemsPerPage'] = itemsPerPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of groups for an organization.  The request may be filtered by `displayName` equality by passing a filter of the form `displayName eq \"Development Group\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
         * @summary List Groups on an Organization
         * @param {string} organizationId ID of the organization
         * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
         * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
         * @param {string} [filter] filter the results by userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScimGroups(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling listScimGroups.');
            }
            // verify required parameter 'startIndex' is not null or undefined
            if (startIndex === null || startIndex === undefined) {
                throw new RequiredError('startIndex', 'Required parameter startIndex was null or undefined when calling listScimGroups.');
            }
            // verify required parameter 'itemsPerPage' is not null or undefined
            if (itemsPerPage === null || itemsPerPage === undefined) {
                throw new RequiredError('itemsPerPage', 'Required parameter itemsPerPage was null or undefined when calling listScimGroups.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Groups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['itemsPerPage'] = itemsPerPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a request to asynchronously delete events for the organization. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
         * @summary Create an event deletion request
         * @param {OrganizationIdEventDataDeletionsBody} body
         * @param {string} organizationId ID of the organization to delete events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletions(body: OrganizationIdEventDataDeletionsBody, organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling organizationEventDataDeletions.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling organizationEventDataDeletions.');
            }
            const localVarPath = `/organizations/{organization_id}/event_data_deletions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationIdEventDataDeletionsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check the status of an event deletion request
         * @param {string} organizationId ID of the organization of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletionsById(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling organizationEventDataDeletionsById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling organizationEventDataDeletionsById.');
            }
            const localVarPath = `/organizations/{organization_id}/event_data_deletions/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Confirm an event deletion request
         * @param {string} organizationId ID of the organization of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletionsConfirm(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling organizationEventDataDeletionsConfirm.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling organizationEventDataDeletionsConfirm.');
            }
            const localVarPath = `/organizations/{organization_id}/event_data_deletions/{id}/confirm`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request event data for the given organization. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
         * @summary Create an event data request
         * @param {OrganizationIdEventDataRequestsBody} body
         * @param {string} organizationId ID of the organization to request events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataRequests(body: OrganizationIdEventDataRequestsBody, organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling organizationEventDataRequests.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling organizationEventDataRequests.');
            }
            const localVarPath = `/organizations/{organization_id}/event_data_requests`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationIdEventDataRequestsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check the status of an event data request
         * @param {string} organizationId ID of the organization of the event data request
         * @param {string} id ID of the event data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataRequestsById(organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling organizationEventDataRequestsById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling organizationEventDataRequestsById.');
            }
            const localVarPath = `/organizations/{organization_id}/event_data_requests/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an Organization
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdDelete(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling organizationsIdDelete.');
            }
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary View an Organization
         * @param {string} id the ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling organizationsIdGet.');
            }
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an Organization
         * @param {OrganizationsIdBody} body
         * @param {string} id the ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdPatch(body: OrganizationsIdBody, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling organizationsIdPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling organizationsIdPatch.');
            }
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Bugsnag organization and adds the current user to it as an admin. Requires user authentication as the initial user of the organization.
         * @summary Create an Organization
         * @param {OrganizationsBody} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPost(body: OrganizationsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling organizationsPost.');
            }
            const localVarPath = `/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * As with the update method above, the `active` flag for a previously added collaborator can be set to remove or re-add them to an organization.  Setting the `active` flag is the only operation we support for this method.
         * @summary Add or Remove Previously Added Collaborators
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator
         * @param {UsersIdBody1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScimCollaborator(organizationId: string, id: string, body?: UsersIdBody1, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling patchScimCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling patchScimCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Users/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersIdBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Regenerate an Organization's API key
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationApiKey(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling revokeOrganizationApiKey.');
            }
            const localVarPath = `/organizations/{id}/api_key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated. Use user-level authentication tokens instead.\\nGenerate a new data access API auth token for the organization. This token allows you to read data from and write data to Bugsnag relating to your Organization, Projects, Errors, etc. After regenerating the auth token, the prior data access API auth token will no longer be supported. Note that this key is different from the project-level notifier API key that you use to identify a project to Bugsnag when you report errors.
         * @summary Regenerate an Organization's auth token
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationAuthToken(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling revokeOrganizationAuthToken.');
            }
            const localVarPath = `/organizations/{id}/auth_token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Collaborator's permissions
         * @param {CollaboratorsIdBody} body
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCollaborator(body: CollaboratorsIdBody, organizationId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateOrganizationCollaborator.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling updateOrganizationCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOrganizationCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/collaborators/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollaboratorsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a team name
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team to be deleted
         * @param {TeamsIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationTeam(organizationId: string, id: string, body?: TeamsIdBody, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling updateOrganizationTeam.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOrganizationTeam.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TeamsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Add Project Access to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {IdProjectAccessesBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationTeamProjectAccesses(organizationId: string, id: string, body?: IdProjectAccessesBody, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling updateOrganizationTeamProjectAccesses.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateOrganizationTeamProjectAccesses.');
            }
            const localVarPath = `/organizations/{organization_id}/teams/{id}/project_accesses`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdProjectAccessesBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the basic details of a collaborator. This includes the email address and name of the collaborator.  Optionally, a collaborator can be added or removed from the organization. - If the `active` flag is set to `false` for an existing collaborator then they are removed from the organization. - If the `active` flag is set to `true` for a user who is not currently a collaborator, but for whom the ID is known, then they are added to the organization.  This approach is used by Okta and OneLogin to remove and re-add users to a Bugsnag organization without removing them entirely from their records.
         * @summary Update a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator
         * @param {UsersIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScimCollaborator(organizationId: string, id: string, body?: UsersIdBody, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling updateScimCollaborator.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateScimCollaborator.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Users/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `value` attribute can use different formatting depending on the context. When updating a groups collaborators with the `add` or `remove` operations use an array of objects, where each objects `value` is an ID for a collaborator in the org:  ``` \"value\": [   {     \"value\": \"515fb9337c1074f6fd000001\"   },   {     \"value\": \"515fb9337c1074f6fd000002\"   } ] ```  When updating group details (i.e. the display name) with the `replace` operation use an object with the `displayName` attribute:  ``` \"value\": {   \"displayName\": \"Testing Group\" } ```  For more details see the full SCIM standard as defined in [RFC7644](https://tools.ietf.org/html/rfc7644).
         * @summary Update Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id ID of the group
         * @param {GroupsIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScimGroup(organizationId: string, id: string, body?: GroupsIdBody, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling updateScimGroup.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateScimGroup.');
            }
            const localVarPath = `/organizations/{organization_id}/scim/v2/Groups/{id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Add a collaborator to a list of teams, or all a collaborator to all the teams in this organization.
         * @summary Add a collaborator to a group of Teams
         * @param {IdTeamMembershipsBody} body
         * @param {string} organizationId The ID of the organization.
         * @param {string} id The ID of the collaborator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationCollaboratorTeamMemberships(body: IdTeamMembershipsBody, organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).addOrganizationCollaboratorTeamMemberships(body, organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add Collaborators to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {IdTeamMembershipsBody1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationTeamMemberships(organizationId: string, id: string, body?: IdTeamMembershipsBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).addOrganizationTeamMemberships(organizationId, id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk invite collaborators to your organization
         * @param {CollaboratorsBulkInviteBody} body
         * @param {string} organizationId the ID of your organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkInviteOrganizationCollaborators(body: CollaboratorsBulkInviteBody, organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20015>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).bulkInviteOrganizationCollaborators(body, organizationId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a Team
         * @param {string} organizationId ID of the organization
         * @param {OrganizationIdTeamsBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationTeam(organizationId: string, body?: OrganizationIdTeamsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).createOrganizationTeam(organizationId, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScimCollaborator(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).createScimCollaborator(organizationId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint is used to add a group to your BugSnag organization.  Collaborators are not added when creating a group, so these must be added using the Update Group on an Organization endpoint after a group is created.
         * @summary Create Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {V2GroupsBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScimGroup(organizationId: string, body?: V2GroupsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).createScimGroup(organizationId, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCollaborator(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizationCollaborator(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a collaborator from a group of teams. The request body for this operation should be documented here: The request body would have matched the TeamIDRequest schema, but DELETE operations cannot have a request body in OpenAPI3. Example: {   \"team_ids\": [\"team_id_1\", \"team_id_2\"] }
         * @summary Remove a Collaborator from a group of Teams
         * @param {string} organizationId The ID of the organization.
         * @param {string} id The ID of the collaborator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCollaboratorTeamMemberships(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizationCollaboratorTeamMemberships(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeam(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizationTeam(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request body requires a CollaboratorsRequest object with the following properties: - user_ids: array of user IDs to remove from the team
         * @summary Remove Collaborators from a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeamMemberships(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizationTeamMemberships(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request body requires a TeamProjectAccessesDelete object with the following properties: - project_ids: array of project IDs to remove access from
         * @summary Remove Project Access from a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeamProjectAccesses(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20020>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteOrganizationTeamProjectAccesses(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScimCollaborator(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteScimCollaborator(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id ID of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScimGroup(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).deleteScimGroup(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Show a Collaborator on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaborator(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationCollaborator(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the details of a collaborator's access to a project.
         * @summary Show a Collaborator's Access Details for a Project
         * @param {string} organizationId The ID of the organization.
         * @param {string} collaboratorId The ID of the collaborator.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjectAccessById(organizationId: string, collaboratorId: string, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20019> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationCollaboratorProjectAccessById(organizationId, collaboratorId, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View the project count of a collaborator
         * @summary View the project count of a collaborator
         * @param {string} organizationId ID of the organization
         * @param {Array<string>} collaboratorIds IDs of collaborators to view the project count of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjectAccessCounts(organizationId: string, collaboratorIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20017>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationCollaboratorProjectAccessCounts(organizationId, collaboratorIds, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View Projects a Collaborator has access to
         * @summary View Projects a Collaborator has access to
         * @param {string} organizationId the ID of the organization
         * @param {string} collaboratorId the ID of the user
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjects(organizationId: string, collaboratorId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationCollaboratorProjects(organizationId, collaboratorId, q, sort, direction, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Show the details of a team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTeam(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationTeam(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Show a collaborator in a project. Requires requesting user to have access to the given project.
         * @summary Show a collaborator in a project.
         * @param {string} projectId the ID of the project
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectCollaborator(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getProjectCollaborator(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Show a Collaborator on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScimCollaborator(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getScimCollaborator(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Show Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScimGroup(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getScimGroup(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Invite a collaborator to your organization
         * @param {OrganizationIdCollaboratorsBody} body
         * @param {string} organizationId the ID of your organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteOrganizationCollaborator(body: OrganizationIdCollaboratorsBody, organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).inviteOrganizationCollaborator(body, organizationId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all projects a collaborator has access to within an organization.
         * @summary List project accesses for a collaborator
         * @param {string} organizationId The ID of the organization
         * @param {string} collaboratorId The ID of the collaborator
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorProjectAccesses(organizationId: string, collaboratorId: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20018>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationCollaboratorProjectAccesses(organizationId, collaboratorId, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Suggested Teams for a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {string} [q] A partial or full team name to filter the results by
         * @param {boolean} [includeIsMember] Request all teams in the organization, including those that the collaborator is already on. By default only teams the collaborator is not a member of will be returned
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorSuggestedTeams(organizationId: string, id: string, q?: string, includeIsMember?: boolean, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20022>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationCollaboratorSuggestedTeams(organizationId, id, q, includeIsMember, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Teams for a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {string} [q] A partial or full team name to filter the results by
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorTeams(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20020>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationCollaboratorTeams(organizationId, id, q, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List all collaborators that are members of your organization
         * @param {string} organizationId the ID of your organization
         * @param {number} [perPage] Number of results per page
         * @param {string} [q] Search collaborators with names or emails matching parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaborators(organizationId: string, perPage?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20015>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationCollaborators(organizationId, perPage, q, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the spans for a trace at an organizational level. Access to this endpoint is restricted on the distributed traces view permission.
         * @summary List Spans for a Trace
         * @param {string} organizationId The ID of the Organization to which the spans belong.
         * @param {string} traceId The ID of the Trace to which the spans belong.
         * @param {string} from Beginning of window to return spans from.
         * @param {string} to End of window to return spans from.
         * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSpans(organizationId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20029>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationSpans(organizationId, traceId, from, to, targetSpanId, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List the Collaborators in a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full user name or email to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamCollaborators(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20015>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationTeamCollaborators(organizationId, id, q, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Project Access for a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full project name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] A token for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamProjectAccesses(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20023>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationTeamProjectAccesses(organizationId, id, q, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Suggested Collaborators to Add to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full user name or email to filter the results by.
         * @param {boolean} [includeHasAccess] Request all collaborators in the organization, including those that are not members of the team. By default only collaborators who are not members of the team will be returned.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamSuggestedCollaborators(organizationId: string, id: string, q?: string, includeHasAccess?: boolean, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20021>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationTeamSuggestedCollaborators(organizationId, id, q, includeHasAccess, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Suggest a list of projects from the organization that the team could be given access to.
         * @summary Suggest Projects to Add to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {boolean} [includeHasAccess] should projects the team already has access to be included?
         * @param {string} [q] A partial or full project name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamSuggestedProjects(organizationId: string, id: string, includeHasAccess?: boolean, q?: string, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20024>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationTeamSuggestedProjects(organizationId, id, includeHasAccess, q, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Teams from a query
         * @param {string} organizationId ID of the organization
         * @param {string} [q] A partial or full team name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] Token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeams(organizationId: string, q?: string, perPage?: number, offset?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20020>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listOrganizationTeams(organizationId, q, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all collaborators that have access to a project.
         * @summary List Collaborators on a Project
         * @param {string} projectId the ID of the project
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectCollaborators(projectId: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20015>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listProjectCollaborators(projectId, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the list of users for the organization.  The request may be filtered by `userName` equality by passing a filter of the form `userName eq \"james@example.com\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
         * @summary List Collaborators on an Organization
         * @param {string} organizationId ID of the organization
         * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
         * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
         * @param {string} [filter] filter the results by userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScimCollaborators(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listScimCollaborators(organizationId, startIndex, itemsPerPage, filter, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the list of groups for an organization.  The request may be filtered by `displayName` equality by passing a filter of the form `displayName eq \"Development Group\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
         * @summary List Groups on an Organization
         * @param {string} organizationId ID of the organization
         * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
         * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
         * @param {string} [filter] filter the results by userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScimGroups(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listScimGroups(organizationId, startIndex, itemsPerPage, filter, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a request to asynchronously delete events for the organization. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
         * @summary Create an event deletion request
         * @param {OrganizationIdEventDataDeletionsBody} body
         * @param {string} organizationId ID of the organization to delete events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletions(body: OrganizationIdEventDataDeletionsBody, organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationEventDataDeletions(body, organizationId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check the status of an event deletion request
         * @param {string} organizationId ID of the organization of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletionsById(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationEventDataDeletionsById(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Confirm an event deletion request
         * @param {string} organizationId ID of the organization of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletionsConfirm(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationEventDataDeletionsConfirm(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request event data for the given organization. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
         * @summary Create an event data request
         * @param {OrganizationIdEventDataRequestsBody} body
         * @param {string} organizationId ID of the organization to request events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataRequests(body: OrganizationIdEventDataRequestsBody, organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2011> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationEventDataRequests(body, organizationId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check the status of an event data request
         * @param {string} organizationId ID of the organization of the event data request
         * @param {string} id ID of the event data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataRequestsById(organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2011> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationEventDataRequestsById(organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an Organization
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdDelete(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationsIdDelete(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary View an Organization
         * @param {string} id the ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationsIdGet(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an Organization
         * @param {OrganizationsIdBody} body
         * @param {string} id the ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdPatch(body: OrganizationsIdBody, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationsIdPatch(body, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new Bugsnag organization and adds the current user to it as an admin. Requires user authentication as the initial user of the organization.
         * @summary Create an Organization
         * @param {OrganizationsBody} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPost(body: OrganizationsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).organizationsPost(body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * As with the update method above, the `active` flag for a previously added collaborator can be set to remove or re-add them to an organization.  Setting the `active` flag is the only operation we support for this method.
         * @summary Add or Remove Previously Added Collaborators
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator
         * @param {UsersIdBody1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScimCollaborator(organizationId: string, id: string, body?: UsersIdBody1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).patchScimCollaborator(organizationId, id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Regenerate an Organization's API key
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationApiKey(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).revokeOrganizationApiKey(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deprecated. Use user-level authentication tokens instead.\\nGenerate a new data access API auth token for the organization. This token allows you to read data from and write data to Bugsnag relating to your Organization, Projects, Errors, etc. After regenerating the auth token, the prior data access API auth token will no longer be supported. Note that this key is different from the project-level notifier API key that you use to identify a project to Bugsnag when you report errors.
         * @summary Regenerate an Organization's auth token
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationAuthToken(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).revokeOrganizationAuthToken(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a Collaborator's permissions
         * @param {CollaboratorsIdBody} body
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCollaborator(body: CollaboratorsIdBody, organizationId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateOrganizationCollaborator(body, organizationId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a team name
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team to be deleted
         * @param {TeamsIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationTeam(organizationId: string, id: string, body?: TeamsIdBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateOrganizationTeam(organizationId, id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Add Project Access to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {IdProjectAccessesBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationTeamProjectAccesses(organizationId: string, id: string, body?: IdProjectAccessesBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20020>> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateOrganizationTeamProjectAccesses(organizationId, id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the basic details of a collaborator. This includes the email address and name of the collaborator.  Optionally, a collaborator can be added or removed from the organization. - If the `active` flag is set to `false` for an existing collaborator then they are removed from the organization. - If the `active` flag is set to `true` for a user who is not currently a collaborator, but for whom the ID is known, then they are added to the organization.  This approach is used by Okta and OneLogin to remove and re-add users to a Bugsnag organization without removing them entirely from their records.
         * @summary Update a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator
         * @param {UsersIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScimCollaborator(organizationId: string, id: string, body?: UsersIdBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateScimCollaborator(organizationId, id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The `value` attribute can use different formatting depending on the context. When updating a groups collaborators with the `add` or `remove` operations use an array of objects, where each objects `value` is an ID for a collaborator in the org:  ``` \"value\": [   {     \"value\": \"515fb9337c1074f6fd000001\"   },   {     \"value\": \"515fb9337c1074f6fd000002\"   } ] ```  When updating group details (i.e. the display name) with the `replace` operation use an object with the `displayName` attribute:  ``` \"value\": {   \"displayName\": \"Testing Group\" } ```  For more details see the full SCIM standard as defined in [RFC7644](https://tools.ietf.org/html/rfc7644).
         * @summary Update Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id ID of the group
         * @param {GroupsIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScimGroup(organizationId: string, id: string, body?: GroupsIdBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateScimGroup(organizationId, id, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add a collaborator to a list of teams, or all a collaborator to all the teams in this organization.
         * @summary Add a collaborator to a group of Teams
         * @param {IdTeamMembershipsBody} body
         * @param {string} organizationId The ID of the organization.
         * @param {string} id The ID of the collaborator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationCollaboratorTeamMemberships(body: IdTeamMembershipsBody, organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).addOrganizationCollaboratorTeamMemberships(body, organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add Collaborators to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {IdTeamMembershipsBody1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationTeamMemberships(organizationId: string, id: string, body?: IdTeamMembershipsBody1, options?: any) {
            return OrganizationsApiFp(configuration).addOrganizationTeamMemberships(organizationId, id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Bulk invite collaborators to your organization
         * @param {CollaboratorsBulkInviteBody} body
         * @param {string} organizationId the ID of your organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkInviteOrganizationCollaborators(body: CollaboratorsBulkInviteBody, organizationId: string, options?: any) {
            return OrganizationsApiFp(configuration).bulkInviteOrganizationCollaborators(body, organizationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a Team
         * @param {string} organizationId ID of the organization
         * @param {OrganizationIdTeamsBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationTeam(organizationId: string, body?: OrganizationIdTeamsBody, options?: any) {
            return OrganizationsApiFp(configuration).createOrganizationTeam(organizationId, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScimCollaborator(organizationId: string, options?: any) {
            return OrganizationsApiFp(configuration).createScimCollaborator(organizationId, options)(fetch, basePath);
        },
        /**
         * This endpoint is used to add a group to your BugSnag organization.  Collaborators are not added when creating a group, so these must be added using the Update Group on an Organization endpoint after a group is created.
         * @summary Create Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {V2GroupsBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScimGroup(organizationId: string, body?: V2GroupsBody, options?: any) {
            return OrganizationsApiFp(configuration).createScimGroup(organizationId, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCollaborator(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizationCollaborator(organizationId, id, options)(fetch, basePath);
        },
        /**
         * Remove a collaborator from a group of teams. The request body for this operation should be documented here: The request body would have matched the TeamIDRequest schema, but DELETE operations cannot have a request body in OpenAPI3. Example: {   \"team_ids\": [\"team_id_1\", \"team_id_2\"] }
         * @summary Remove a Collaborator from a group of Teams
         * @param {string} organizationId The ID of the organization.
         * @param {string} id The ID of the collaborator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationCollaboratorTeamMemberships(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizationCollaboratorTeamMemberships(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeam(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizationTeam(organizationId, id, options)(fetch, basePath);
        },
        /**
         * Request body requires a CollaboratorsRequest object with the following properties: - user_ids: array of user IDs to remove from the team
         * @summary Remove Collaborators from a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeamMemberships(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizationTeamMemberships(organizationId, id, options)(fetch, basePath);
        },
        /**
         * Request body requires a TeamProjectAccessesDelete object with the following properties: - project_ids: array of project IDs to remove access from
         * @summary Remove Project Access from a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationTeamProjectAccesses(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteOrganizationTeamProjectAccesses(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScimCollaborator(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteScimCollaborator(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id ID of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScimGroup(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).deleteScimGroup(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Show a Collaborator on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaborator(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationCollaborator(organizationId, id, options)(fetch, basePath);
        },
        /**
         * Return the details of a collaborator's access to a project.
         * @summary Show a Collaborator's Access Details for a Project
         * @param {string} organizationId The ID of the organization.
         * @param {string} collaboratorId The ID of the collaborator.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjectAccessById(organizationId: string, collaboratorId: string, projectId: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationCollaboratorProjectAccessById(organizationId, collaboratorId, projectId, options)(fetch, basePath);
        },
        /**
         * View the project count of a collaborator
         * @summary View the project count of a collaborator
         * @param {string} organizationId ID of the organization
         * @param {Array<string>} collaboratorIds IDs of collaborators to view the project count of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjectAccessCounts(organizationId: string, collaboratorIds: Array<string>, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationCollaboratorProjectAccessCounts(organizationId, collaboratorIds, options)(fetch, basePath);
        },
        /**
         * View Projects a Collaborator has access to
         * @summary View Projects a Collaborator has access to
         * @param {string} organizationId the ID of the organization
         * @param {string} collaboratorId the ID of the user
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCollaboratorProjects(organizationId: string, collaboratorId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationCollaboratorProjects(organizationId, collaboratorId, q, sort, direction, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary Show the details of a team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTeam(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationTeam(organizationId, id, options)(fetch, basePath);
        },
        /**
         * Show a collaborator in a project. Requires requesting user to have access to the given project.
         * @summary Show a collaborator in a project.
         * @param {string} projectId the ID of the project
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectCollaborator(projectId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).getProjectCollaborator(projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Show a Collaborator on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScimCollaborator(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).getScimCollaborator(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Show Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScimGroup(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).getScimGroup(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Invite a collaborator to your organization
         * @param {OrganizationIdCollaboratorsBody} body
         * @param {string} organizationId the ID of your organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteOrganizationCollaborator(body: OrganizationIdCollaboratorsBody, organizationId: string, options?: any) {
            return OrganizationsApiFp(configuration).inviteOrganizationCollaborator(body, organizationId, options)(fetch, basePath);
        },
        /**
         * List all projects a collaborator has access to within an organization.
         * @summary List project accesses for a collaborator
         * @param {string} organizationId The ID of the organization
         * @param {string} collaboratorId The ID of the collaborator
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorProjectAccesses(organizationId: string, collaboratorId: string, perPage?: number, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationCollaboratorProjectAccesses(organizationId, collaboratorId, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Suggested Teams for a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {string} [q] A partial or full team name to filter the results by
         * @param {boolean} [includeIsMember] Request all teams in the organization, including those that the collaborator is already on. By default only teams the collaborator is not a member of will be returned
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorSuggestedTeams(organizationId: string, id: string, q?: string, includeIsMember?: boolean, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationCollaboratorSuggestedTeams(organizationId, id, q, includeIsMember, perPage, offset, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Teams for a Collaborator
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the collaborator
         * @param {string} [q] A partial or full team name to filter the results by
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaboratorTeams(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationCollaboratorTeams(organizationId, id, q, perPage, offset, options)(fetch, basePath);
        },
        /**
         *
         * @summary List all collaborators that are members of your organization
         * @param {string} organizationId the ID of your organization
         * @param {number} [perPage] Number of results per page
         * @param {string} [q] Search collaborators with names or emails matching parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationCollaborators(organizationId: string, perPage?: number, q?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationCollaborators(organizationId, perPage, q, options)(fetch, basePath);
        },
        /**
         * Returns the spans for a trace at an organizational level. Access to this endpoint is restricted on the distributed traces view permission.
         * @summary List Spans for a Trace
         * @param {string} organizationId The ID of the Organization to which the spans belong.
         * @param {string} traceId The ID of the Trace to which the spans belong.
         * @param {string} from Beginning of window to return spans from.
         * @param {string} to End of window to return spans from.
         * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSpans(organizationId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationSpans(organizationId, traceId, from, to, targetSpanId, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List the Collaborators in a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full user name or email to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamCollaborators(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationTeamCollaborators(organizationId, id, q, perPage, offset, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Project Access for a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full project name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] A token for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamProjectAccesses(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationTeamProjectAccesses(organizationId, id, q, perPage, offset, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Suggested Collaborators to Add to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {string} [q] A partial or full user name or email to filter the results by.
         * @param {boolean} [includeHasAccess] Request all collaborators in the organization, including those that are not members of the team. By default only collaborators who are not members of the team will be returned.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamSuggestedCollaborators(organizationId: string, id: string, q?: string, includeHasAccess?: boolean, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationTeamSuggestedCollaborators(organizationId, id, q, includeHasAccess, perPage, offset, options)(fetch, basePath);
        },
        /**
         * Suggest a list of projects from the organization that the team could be given access to.
         * @summary Suggest Projects to Add to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {boolean} [includeHasAccess] should projects the team already has access to be included?
         * @param {string} [q] A partial or full project name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeamSuggestedProjects(organizationId: string, id: string, includeHasAccess?: boolean, q?: string, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationTeamSuggestedProjects(organizationId, id, includeHasAccess, q, perPage, offset, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Teams from a query
         * @param {string} organizationId ID of the organization
         * @param {string} [q] A partial or full team name to filter the results by.
         * @param {number} [perPage]
         * @param {string} [offset] Token to retrieve next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTeams(organizationId: string, q?: string, perPage?: number, offset?: string, options?: any) {
            return OrganizationsApiFp(configuration).listOrganizationTeams(organizationId, q, perPage, offset, options)(fetch, basePath);
        },
        /**
         * List all collaborators that have access to a project.
         * @summary List Collaborators on a Project
         * @param {string} projectId the ID of the project
         * @param {number} [perPage] Number of results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectCollaborators(projectId: string, perPage?: number, options?: any) {
            return OrganizationsApiFp(configuration).listProjectCollaborators(projectId, perPage, options)(fetch, basePath);
        },
        /**
         * Return the list of users for the organization.  The request may be filtered by `userName` equality by passing a filter of the form `userName eq \"james@example.com\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
         * @summary List Collaborators on an Organization
         * @param {string} organizationId ID of the organization
         * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
         * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
         * @param {string} [filter] filter the results by userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScimCollaborators(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options?: any) {
            return OrganizationsApiFp(configuration).listScimCollaborators(organizationId, startIndex, itemsPerPage, filter, options)(fetch, basePath);
        },
        /**
         * Return the list of groups for an organization.  The request may be filtered by `displayName` equality by passing a filter of the form `displayName eq \"Development Group\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
         * @summary List Groups on an Organization
         * @param {string} organizationId ID of the organization
         * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
         * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
         * @param {string} [filter] filter the results by userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listScimGroups(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options?: any) {
            return OrganizationsApiFp(configuration).listScimGroups(organizationId, startIndex, itemsPerPage, filter, options)(fetch, basePath);
        },
        /**
         * Creates a request to asynchronously delete events for the organization. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
         * @summary Create an event deletion request
         * @param {OrganizationIdEventDataDeletionsBody} body
         * @param {string} organizationId ID of the organization to delete events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletions(body: OrganizationIdEventDataDeletionsBody, organizationId: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationEventDataDeletions(body, organizationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the status of an event deletion request
         * @param {string} organizationId ID of the organization of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletionsById(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationEventDataDeletionsById(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm an event deletion request
         * @param {string} organizationId ID of the organization of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataDeletionsConfirm(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationEventDataDeletionsConfirm(organizationId, id, options)(fetch, basePath);
        },
        /**
         * Request event data for the given organization. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
         * @summary Create an event data request
         * @param {OrganizationIdEventDataRequestsBody} body
         * @param {string} organizationId ID of the organization to request events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataRequests(body: OrganizationIdEventDataRequestsBody, organizationId: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationEventDataRequests(body, organizationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the status of an event data request
         * @param {string} organizationId ID of the organization of the event data request
         * @param {string} id ID of the event data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationEventDataRequestsById(organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationEventDataRequestsById(organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete an Organization
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdDelete(id: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationsIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary View an Organization
         * @param {string} id the ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdGet(id: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationsIdGet(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an Organization
         * @param {OrganizationsIdBody} body
         * @param {string} id the ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsIdPatch(body: OrganizationsIdBody, id: string, options?: any) {
            return OrganizationsApiFp(configuration).organizationsIdPatch(body, id, options)(fetch, basePath);
        },
        /**
         * Creates a new Bugsnag organization and adds the current user to it as an admin. Requires user authentication as the initial user of the organization.
         * @summary Create an Organization
         * @param {OrganizationsBody} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPost(body: OrganizationsBody, options?: any) {
            return OrganizationsApiFp(configuration).organizationsPost(body, options)(fetch, basePath);
        },
        /**
         * As with the update method above, the `active` flag for a previously added collaborator can be set to remove or re-add them to an organization.  Setting the `active` flag is the only operation we support for this method.
         * @summary Add or Remove Previously Added Collaborators
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator
         * @param {UsersIdBody1} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScimCollaborator(organizationId: string, id: string, body?: UsersIdBody1, options?: any) {
            return OrganizationsApiFp(configuration).patchScimCollaborator(organizationId, id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Regenerate an Organization's API key
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationApiKey(id: string, options?: any) {
            return OrganizationsApiFp(configuration).revokeOrganizationApiKey(id, options)(fetch, basePath);
        },
        /**
         * Deprecated. Use user-level authentication tokens instead.\\nGenerate a new data access API auth token for the organization. This token allows you to read data from and write data to Bugsnag relating to your Organization, Projects, Errors, etc. After regenerating the auth token, the prior data access API auth token will no longer be supported. Note that this key is different from the project-level notifier API key that you use to identify a project to Bugsnag when you report errors.
         * @summary Regenerate an Organization's auth token
         * @param {string} id ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOrganizationAuthToken(id: string, options?: any) {
            return OrganizationsApiFp(configuration).revokeOrganizationAuthToken(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a Collaborator's permissions
         * @param {CollaboratorsIdBody} body
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationCollaborator(body: CollaboratorsIdBody, organizationId: string, id: string, options?: any) {
            return OrganizationsApiFp(configuration).updateOrganizationCollaborator(body, organizationId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a team name
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team to be deleted
         * @param {TeamsIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationTeam(organizationId: string, id: string, body?: TeamsIdBody, options?: any) {
            return OrganizationsApiFp(configuration).updateOrganizationTeam(organizationId, id, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add Project Access to a Team
         * @param {string} organizationId ID of the organization
         * @param {string} id the ID of the team
         * @param {IdProjectAccessesBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationTeamProjectAccesses(organizationId: string, id: string, body?: IdProjectAccessesBody, options?: any) {
            return OrganizationsApiFp(configuration).updateOrganizationTeamProjectAccesses(organizationId, id, body, options)(fetch, basePath);
        },
        /**
         * Update the basic details of a collaborator. This includes the email address and name of the collaborator.  Optionally, a collaborator can be added or removed from the organization. - If the `active` flag is set to `false` for an existing collaborator then they are removed from the organization. - If the `active` flag is set to `true` for a user who is not currently a collaborator, but for whom the ID is known, then they are added to the organization.  This approach is used by Okta and OneLogin to remove and re-add users to a Bugsnag organization without removing them entirely from their records.
         * @summary Update a Collaborator
         * @param {string} organizationId the ID of your organization
         * @param {string} id the ID of the collaborator
         * @param {UsersIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScimCollaborator(organizationId: string, id: string, body?: UsersIdBody, options?: any) {
            return OrganizationsApiFp(configuration).updateScimCollaborator(organizationId, id, body, options)(fetch, basePath);
        },
        /**
         * The `value` attribute can use different formatting depending on the context. When updating a groups collaborators with the `add` or `remove` operations use an array of objects, where each objects `value` is an ID for a collaborator in the org:  ``` \"value\": [   {     \"value\": \"515fb9337c1074f6fd000001\"   },   {     \"value\": \"515fb9337c1074f6fd000002\"   } ] ```  When updating group details (i.e. the display name) with the `replace` operation use an object with the `displayName` attribute:  ``` \"value\": {   \"displayName\": \"Testing Group\" } ```  For more details see the full SCIM standard as defined in [RFC7644](https://tools.ietf.org/html/rfc7644).
         * @summary Update Group on an Organization
         * @param {string} organizationId ID of the organization
         * @param {string} id ID of the group
         * @param {GroupsIdBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScimGroup(organizationId: string, id: string, body?: GroupsIdBody, options?: any) {
            return OrganizationsApiFp(configuration).updateScimGroup(organizationId, id, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Add a collaborator to a list of teams, or all a collaborator to all the teams in this organization.
     * @summary Add a collaborator to a group of Teams
     * @param {IdTeamMembershipsBody} body
     * @param {string} organizationId The ID of the organization.
     * @param {string} id The ID of the collaborator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationCollaboratorTeamMemberships(body: IdTeamMembershipsBody, organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrganizationCollaboratorTeamMemberships(body, organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Add Collaborators to a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {IdTeamMembershipsBody1} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationTeamMemberships(organizationId: string, id: string, body?: IdTeamMembershipsBody1, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrganizationTeamMemberships(organizationId, id, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Bulk invite collaborators to your organization
     * @param {CollaboratorsBulkInviteBody} body
     * @param {string} organizationId the ID of your organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public bulkInviteOrganizationCollaborators(body: CollaboratorsBulkInviteBody, organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).bulkInviteOrganizationCollaborators(body, organizationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a Team
     * @param {string} organizationId ID of the organization
     * @param {OrganizationIdTeamsBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganizationTeam(organizationId: string, body?: OrganizationIdTeamsBody, options?: any) {
        return OrganizationsApiFp(this.configuration).createOrganizationTeam(organizationId, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a Collaborator
     * @param {string} organizationId ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createScimCollaborator(organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).createScimCollaborator(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint is used to add a group to your BugSnag organization.  Collaborators are not added when creating a group, so these must be added using the Update Group on an Organization endpoint after a group is created.
     * @summary Create Group on an Organization
     * @param {string} organizationId ID of the organization
     * @param {V2GroupsBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createScimGroup(organizationId: string, body?: V2GroupsBody, options?: any) {
        return OrganizationsApiFp(this.configuration).createScimGroup(organizationId, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a Collaborator
     * @param {string} organizationId the ID of your organization
     * @param {string} id the ID of the collaborator to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationCollaborator(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationCollaborator(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a collaborator from a group of teams. The request body for this operation should be documented here: The request body would have matched the TeamIDRequest schema, but DELETE operations cannot have a request body in OpenAPI3. Example: {   \"team_ids\": [\"team_id_1\", \"team_id_2\"] }
     * @summary Remove a Collaborator from a group of Teams
     * @param {string} organizationId The ID of the organization.
     * @param {string} id The ID of the collaborator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationCollaboratorTeamMemberships(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationCollaboratorTeamMemberships(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationTeam(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationTeam(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Request body requires a CollaboratorsRequest object with the following properties: - user_ids: array of user IDs to remove from the team
     * @summary Remove Collaborators from a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationTeamMemberships(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationTeamMemberships(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Request body requires a TeamProjectAccessesDelete object with the following properties: - project_ids: array of project IDs to remove access from
     * @summary Remove Project Access from a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationTeamProjectAccesses(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationTeamProjectAccesses(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Remove a Collaborator
     * @param {string} organizationId the ID of your organization
     * @param {string} id the ID of the collaborator to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteScimCollaborator(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteScimCollaborator(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete Group on an Organization
     * @param {string} organizationId ID of the organization
     * @param {string} id ID of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteScimGroup(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).deleteScimGroup(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Show a Collaborator on an Organization
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationCollaborator(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationCollaborator(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Return the details of a collaborator's access to a project.
     * @summary Show a Collaborator's Access Details for a Project
     * @param {string} organizationId The ID of the organization.
     * @param {string} collaboratorId The ID of the collaborator.
     * @param {string} projectId The ID of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationCollaboratorProjectAccessById(organizationId: string, collaboratorId: string, projectId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationCollaboratorProjectAccessById(organizationId, collaboratorId, projectId, options)(this.fetch, this.basePath);
    }

    /**
     * View the project count of a collaborator
     * @summary View the project count of a collaborator
     * @param {string} organizationId ID of the organization
     * @param {Array<string>} collaboratorIds IDs of collaborators to view the project count of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationCollaboratorProjectAccessCounts(organizationId: string, collaboratorIds: Array<string>, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationCollaboratorProjectAccessCounts(organizationId, collaboratorIds, options)(this.fetch, this.basePath);
    }

    /**
     * View Projects a Collaborator has access to
     * @summary View Projects a Collaborator has access to
     * @param {string} organizationId the ID of the organization
     * @param {string} collaboratorId the ID of the user
     * @param {string} [q] Search projects with names matching parameter
     * @param {string} [sort] Which field to sort the results by
     * @param {string} [direction] Which direction to sort the results by
     * @param {number} [perPage] How many results to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationCollaboratorProjects(organizationId: string, collaboratorId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationCollaboratorProjects(organizationId, collaboratorId, q, sort, direction, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Show the details of a team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationTeam(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationTeam(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Show a collaborator in a project. Requires requesting user to have access to the given project.
     * @summary Show a collaborator in a project.
     * @param {string} projectId the ID of the project
     * @param {string} id the ID of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getProjectCollaborator(projectId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getProjectCollaborator(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Show a Collaborator on an Organization
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the collaborator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getScimCollaborator(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getScimCollaborator(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Show Group on an Organization
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the Group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getScimGroup(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getScimGroup(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Invite a collaborator to your organization
     * @param {OrganizationIdCollaboratorsBody} body
     * @param {string} organizationId the ID of your organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public inviteOrganizationCollaborator(body: OrganizationIdCollaboratorsBody, organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).inviteOrganizationCollaborator(body, organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * List all projects a collaborator has access to within an organization.
     * @summary List project accesses for a collaborator
     * @param {string} organizationId The ID of the organization
     * @param {string} collaboratorId The ID of the collaborator
     * @param {number} [perPage] Number of results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationCollaboratorProjectAccesses(organizationId: string, collaboratorId: string, perPage?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationCollaboratorProjectAccesses(organizationId, collaboratorId, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Suggested Teams for a Collaborator
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the collaborator
     * @param {string} [q] A partial or full team name to filter the results by
     * @param {boolean} [includeIsMember] Request all teams in the organization, including those that the collaborator is already on. By default only teams the collaborator is not a member of will be returned
     * @param {number} [perPage]
     * @param {string} [offset] token to retrieve next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationCollaboratorSuggestedTeams(organizationId: string, id: string, q?: string, includeIsMember?: boolean, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationCollaboratorSuggestedTeams(organizationId, id, q, includeIsMember, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Teams for a Collaborator
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the collaborator
     * @param {string} [q] A partial or full team name to filter the results by
     * @param {number} [perPage]
     * @param {string} [offset] token to retrieve next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationCollaboratorTeams(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationCollaboratorTeams(organizationId, id, q, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List all collaborators that are members of your organization
     * @param {string} organizationId the ID of your organization
     * @param {number} [perPage] Number of results per page
     * @param {string} [q] Search collaborators with names or emails matching parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationCollaborators(organizationId: string, perPage?: number, q?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationCollaborators(organizationId, perPage, q, options)(this.fetch, this.basePath);
    }

    /**
     * Returns the spans for a trace at an organizational level. Access to this endpoint is restricted on the distributed traces view permission.
     * @summary List Spans for a Trace
     * @param {string} organizationId The ID of the Organization to which the spans belong.
     * @param {string} traceId The ID of the Trace to which the spans belong.
     * @param {string} from Beginning of window to return spans from.
     * @param {string} to End of window to return spans from.
     * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
     * @param {number} [perPage] The number of results to return per page. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationSpans(organizationId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationSpans(organizationId, traceId, from, to, targetSpanId, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List the Collaborators in a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {string} [q] A partial or full user name or email to filter the results by.
     * @param {number} [perPage]
     * @param {string} [offset] token to retrieve next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationTeamCollaborators(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationTeamCollaborators(organizationId, id, q, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Project Access for a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {string} [q] A partial or full project name to filter the results by.
     * @param {number} [perPage]
     * @param {string} [offset] A token for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationTeamProjectAccesses(organizationId: string, id: string, q?: string, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationTeamProjectAccesses(organizationId, id, q, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Suggested Collaborators to Add to a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {string} [q] A partial or full user name or email to filter the results by.
     * @param {boolean} [includeHasAccess] Request all collaborators in the organization, including those that are not members of the team. By default only collaborators who are not members of the team will be returned.
     * @param {number} [perPage]
     * @param {string} [offset] token to retrieve next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationTeamSuggestedCollaborators(organizationId: string, id: string, q?: string, includeHasAccess?: boolean, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationTeamSuggestedCollaborators(organizationId, id, q, includeHasAccess, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Suggest a list of projects from the organization that the team could be given access to.
     * @summary Suggest Projects to Add to a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {boolean} [includeHasAccess] should projects the team already has access to be included?
     * @param {string} [q] A partial or full project name to filter the results by.
     * @param {number} [perPage]
     * @param {string} [offset] token to retrieve next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationTeamSuggestedProjects(organizationId: string, id: string, includeHasAccess?: boolean, q?: string, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationTeamSuggestedProjects(organizationId, id, includeHasAccess, q, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Teams from a query
     * @param {string} organizationId ID of the organization
     * @param {string} [q] A partial or full team name to filter the results by.
     * @param {number} [perPage]
     * @param {string} [offset] Token to retrieve next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationTeams(organizationId: string, q?: string, perPage?: number, offset?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listOrganizationTeams(organizationId, q, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     * List all collaborators that have access to a project.
     * @summary List Collaborators on a Project
     * @param {string} projectId the ID of the project
     * @param {number} [perPage] Number of results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listProjectCollaborators(projectId: string, perPage?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).listProjectCollaborators(projectId, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Return the list of users for the organization.  The request may be filtered by `userName` equality by passing a filter of the form `userName eq \"james@example.com\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
     * @summary List Collaborators on an Organization
     * @param {string} organizationId ID of the organization
     * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
     * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
     * @param {string} [filter] filter the results by userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listScimCollaborators(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listScimCollaborators(organizationId, startIndex, itemsPerPage, filter, options)(this.fetch, this.basePath);
    }

    /**
     * Return the list of groups for an organization.  The request may be filtered by `displayName` equality by passing a filter of the form `displayName eq \"Development Group\"`. No other filtering is supported.  Results will be paginated. Further pages may be requested by setting `startIndex` and `itemsPerPage`.
     * @summary List Groups on an Organization
     * @param {string} organizationId ID of the organization
     * @param {number} startIndex the pagination offset, 1-indexed, defaults to 1
     * @param {number} itemsPerPage the number of results returned in this response, defaults to 30, maximum of 100
     * @param {string} [filter] filter the results by userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listScimGroups(organizationId: string, startIndex: number, itemsPerPage: number, filter?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).listScimGroups(organizationId, startIndex, itemsPerPage, filter, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a request to asynchronously delete events for the organization. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
     * @summary Create an event deletion request
     * @param {OrganizationIdEventDataDeletionsBody} body
     * @param {string} organizationId ID of the organization to delete events from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationEventDataDeletions(body: OrganizationIdEventDataDeletionsBody, organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationEventDataDeletions(body, organizationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check the status of an event deletion request
     * @param {string} organizationId ID of the organization of the deletion request
     * @param {string} id ID of the deletion request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationEventDataDeletionsById(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationEventDataDeletionsById(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Confirm an event deletion request
     * @param {string} organizationId ID of the organization of the deletion request
     * @param {string} id ID of the deletion request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationEventDataDeletionsConfirm(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationEventDataDeletionsConfirm(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Request event data for the given organization. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
     * @summary Create an event data request
     * @param {OrganizationIdEventDataRequestsBody} body
     * @param {string} organizationId ID of the organization to request events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationEventDataRequests(body: OrganizationIdEventDataRequestsBody, organizationId: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationEventDataRequests(body, organizationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check the status of an event data request
     * @param {string} organizationId ID of the organization of the event data request
     * @param {string} id ID of the event data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationEventDataRequestsById(organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationEventDataRequestsById(organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete an Organization
     * @param {string} id ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsIdDelete(id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary View an Organization
     * @param {string} id the ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsIdGet(id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an Organization
     * @param {OrganizationsIdBody} body
     * @param {string} id the ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsIdPatch(body: OrganizationsIdBody, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsIdPatch(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new Bugsnag organization and adds the current user to it as an admin. Requires user authentication as the initial user of the organization.
     * @summary Create an Organization
     * @param {OrganizationsBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsPost(body: OrganizationsBody, options?: any) {
        return OrganizationsApiFp(this.configuration).organizationsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * As with the update method above, the `active` flag for a previously added collaborator can be set to remove or re-add them to an organization.  Setting the `active` flag is the only operation we support for this method.
     * @summary Add or Remove Previously Added Collaborators
     * @param {string} organizationId the ID of your organization
     * @param {string} id the ID of the collaborator
     * @param {UsersIdBody1} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public patchScimCollaborator(organizationId: string, id: string, body?: UsersIdBody1, options?: any) {
        return OrganizationsApiFp(this.configuration).patchScimCollaborator(organizationId, id, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Regenerate an Organization's API key
     * @param {string} id ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public revokeOrganizationApiKey(id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).revokeOrganizationApiKey(id, options)(this.fetch, this.basePath);
    }

    /**
     * Deprecated. Use user-level authentication tokens instead.\\nGenerate a new data access API auth token for the organization. This token allows you to read data from and write data to Bugsnag relating to your Organization, Projects, Errors, etc. After regenerating the auth token, the prior data access API auth token will no longer be supported. Note that this key is different from the project-level notifier API key that you use to identify a project to Bugsnag when you report errors.
     * @summary Regenerate an Organization's auth token
     * @param {string} id ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public revokeOrganizationAuthToken(id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).revokeOrganizationAuthToken(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a Collaborator's permissions
     * @param {CollaboratorsIdBody} body
     * @param {string} organizationId the ID of your organization
     * @param {string} id the ID of the collaborator to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationCollaborator(body: CollaboratorsIdBody, organizationId: string, id: string, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationCollaborator(body, organizationId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a team name
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team to be deleted
     * @param {TeamsIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationTeam(organizationId: string, id: string, body?: TeamsIdBody, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationTeam(organizationId, id, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Add Project Access to a Team
     * @param {string} organizationId ID of the organization
     * @param {string} id the ID of the team
     * @param {IdProjectAccessesBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganizationTeamProjectAccesses(organizationId: string, id: string, body?: IdProjectAccessesBody, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganizationTeamProjectAccesses(organizationId, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update the basic details of a collaborator. This includes the email address and name of the collaborator.  Optionally, a collaborator can be added or removed from the organization. - If the `active` flag is set to `false` for an existing collaborator then they are removed from the organization. - If the `active` flag is set to `true` for a user who is not currently a collaborator, but for whom the ID is known, then they are added to the organization.  This approach is used by Okta and OneLogin to remove and re-add users to a Bugsnag organization without removing them entirely from their records.
     * @summary Update a Collaborator
     * @param {string} organizationId the ID of your organization
     * @param {string} id the ID of the collaborator
     * @param {UsersIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateScimCollaborator(organizationId: string, id: string, body?: UsersIdBody, options?: any) {
        return OrganizationsApiFp(this.configuration).updateScimCollaborator(organizationId, id, body, options)(this.fetch, this.basePath);
    }

    /**
     * The `value` attribute can use different formatting depending on the context. When updating a groups collaborators with the `add` or `remove` operations use an array of objects, where each objects `value` is an ID for a collaborator in the org:  ``` \"value\": [   {     \"value\": \"515fb9337c1074f6fd000001\"   },   {     \"value\": \"515fb9337c1074f6fd000002\"   } ] ```  When updating group details (i.e. the display name) with the `replace` operation use an object with the `displayName` attribute:  ``` \"value\": {   \"displayName\": \"Testing Group\" } ```  For more details see the full SCIM standard as defined in [RFC7644](https://tools.ietf.org/html/rfc7644).
     * @summary Update Group on an Organization
     * @param {string} organizationId ID of the organization
     * @param {string} id ID of the group
     * @param {GroupsIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateScimGroup(organizationId: string, id: string, body?: GroupsIdBody, options?: any) {
        return OrganizationsApiFp(this.configuration).updateScimGroup(organizationId, id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
export const ProjectsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Confirm an event deletion request
         * @param {string} projectId ID of the project of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmProjectEventDataDeletion(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling confirmProjectEventDataDeletion.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling confirmProjectEventDataDeletion.');
            }
            const localVarPath = `/projects/{project_id}/event_data_deletions/{id}/confirm`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a Project in an Organization
         * @param {OrganizationIdProjectsBody} body
         * @param {string} organizationId ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationProject(body: OrganizationIdProjectsBody, organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createOrganizationProject.');
            }
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling createOrganizationProject.');
            }
            const localVarPath = `/organizations/{organization_id}/projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationIdProjectsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a request to asynchronously delete events for the project. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
         * @summary Create an event deletion request
         * @param {ProjectIdEventDataDeletionsBody} body
         * @param {string} projectId ID of the project to delete events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventDataDeletion(body: ProjectIdEventDataDeletionsBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createProjectEventDataDeletion.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling createProjectEventDataDeletion.');
            }
            const localVarPath = `/projects/{project_id}/event_data_deletions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdEventDataDeletionsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request event data for the given project. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
         * @summary Create an event data request
         * @param {ProjectIdEventDataRequestsBody} body
         * @param {string} projectId ID of the project to request events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventDataRequest(body: ProjectIdEventDataRequestsBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createProjectEventDataRequest.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling createProjectEventDataRequest.');
            }
            const localVarPath = `/projects/{project_id}/event_data_requests`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdEventDataRequestsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a custom Event Field
         * @param {ProjectIdEventFieldsBody} body
         * @param {string} projectId ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventField(body: ProjectIdEventFieldsBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createProjectEventField.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling createProjectEventField.');
            }
            const localVarPath = `/projects/{project_id}/event_fields`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdEventFieldsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Star a Feature Flag
         * @param {ProjectIdStarredFeatureFlagsBody} body
         * @param {string} projectId ID of the Project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserStarredFeatureFlag(body: ProjectIdStarredFeatureFlagsBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createUserStarredFeatureFlag.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling createUserStarredFeatureFlag.');
            }
            const localVarPath = `/user/projects/{project_id}/starred_feature_flags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdStarredFeatureFlagsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Project
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a custom Event Field
         * @param {string} projectId ID of the Project
         * @param {string} displayId human friendly ID for the EventField
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEventFieldByDisplayId(projectId: string, displayId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteProjectEventFieldByDisplayId.');
            }
            // verify required parameter 'displayId' is not null or undefined
            if (displayId === null || displayId === undefined) {
                throw new RequiredError('displayId', 'Required parameter displayId was null or undefined when calling deleteProjectEventFieldByDisplayId.');
            }
            const localVarPath = `/projects/{project_id}/event_fields/{display_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"display_id"}}`, encodeURIComponent(String(displayId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a Feature Flag
         * @param {string} projectId ID of the Project.
         * @param {string} id ID of the Feature Flag to unstar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectFeatureFlag(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteProjectFeatureFlag.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteProjectFeatureFlag.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Unstar a Feature Flag
         * @param {string} projectId ID of the Project.
         * @param {string} id ID of the Feature Flag to unstar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProjectStarredFeatureFlag(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteUserProjectStarredFeatureFlag.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteUserProjectStarredFeatureFlag.');
            }
            const localVarPath = `/user/projects/{project_id}/starred_feature_flags/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of projects for the given organization.
         * @summary List an Organization's Projects
         * @param {string} organizationId the ID of the organization
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId', 'Required parameter organizationId was null or undefined when calling getOrganizationProjects.');
            }
            const localVarPath = `/organizations/{organization_id}/projects`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary View a Project
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProject.');
            }
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check the status of an event deletion request
         * @param {string} projectId ID of the project of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEventDataDeletionById(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectEventDataDeletionById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectEventDataDeletionById.');
            }
            const localVarPath = `/projects/{project_id}/event_data_deletions/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check the status of an event data request
         * @param {string} projectId ID of the project of the event data request
         * @param {string} id ID of the event data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEventDataRequestById(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectEventDataRequestById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectEventDataRequestById.');
            }
            const localVarPath = `/projects/{project_id}/event_data_requests/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Feature Flag
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for the Feature Flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlag(id: string, projectId: string, releaseStageName: string, includeVariantSummary?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectFeatureFlag.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectFeatureFlag.');
            }
            // verify required parameter 'releaseStageName' is not null or undefined
            if (releaseStageName === null || releaseStageName === undefined) {
                throw new RequiredError('releaseStageName', 'Required parameter releaseStageName was null or undefined when calling getProjectFeatureFlag.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            if (includeVariantSummary !== undefined) {
                localVarQueryParameter['include_variant_summary'] = includeVariantSummary;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Feature Flag's Error Overview
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagErrorOverview(id: string, projectId: string, releaseStageName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectFeatureFlagErrorOverview.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectFeatureFlagErrorOverview.');
            }
            // verify required parameter 'releaseStageName' is not null or undefined
            if (releaseStageName === null || releaseStageName === undefined) {
                throw new RequiredError('releaseStageName', 'Required parameter releaseStageName was null or undefined when calling getProjectFeatureFlagErrorOverview.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags/{id}/error_overview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Variants on a Feature Flag by ID
         * @param {string} id ID of the feature flag.
         * @param {string} projectId ID of the project.
         * @param {string} [releaseStageName] Release stage name to get the variants for.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariants(id: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectFeatureFlagVariants.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectFeatureFlagVariants.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags/{id}/variants`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Variants on a Feature Flag by name
         * @param {string} name Name of the feature flag, case-sensitive and with no substring matching.
         * @param {string} projectId ID of the project.
         * @param {string} [releaseStageName] Release stage name to get the variants for.
         * @param {string} [q] Search for feature flag variants with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariantsByName(name: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling getProjectFeatureFlagVariantsByName.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectFeatureFlagVariantsByName.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags/by_name/{name}/variants`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Feature Flag Variant's Error Overview
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {Array<string>} variantIds IDs for the FeatureFlag variants.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariantsErrorOverview(id: string, projectId: string, variantIds: Array<string>, releaseStageName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectFeatureFlagVariantsErrorOverview.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectFeatureFlagVariantsErrorOverview.');
            }
            // verify required parameter 'variantIds' is not null or undefined
            if (variantIds === null || variantIds === undefined) {
                throw new RequiredError('variantIds', 'Required parameter variantIds was null or undefined when calling getProjectFeatureFlagVariantsErrorOverview.');
            }
            // verify required parameter 'releaseStageName' is not null or undefined
            if (releaseStageName === null || releaseStageName === undefined) {
                throw new RequiredError('releaseStageName', 'Required parameter releaseStageName was null or undefined when calling getProjectFeatureFlagVariantsErrorOverview.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags/{id}/variants/error_overview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (variantIds) {
                localVarQueryParameter['variant_ids'] = variantIds;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List a Project's Network Grouping Ruleset
         * @param {string} projectId The ID of the Project to retrieve the endpoints for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNetworkGroupingRuleset(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectNetworkGroupingRuleset.');
            }
            const localVarPath = `/projects/{project_id}/network_endpoint_grouping`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Show a Page Load Span Group by ID
         * @param {string} projectId The ID of the Project to which the Page Load Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Page Load Span Group.
         * @param {Array<Filters16>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPageLoadSpanGroupById(projectId: string, id: string, filters?: Array<Filters16>, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectPageLoadSpanGroupById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectPageLoadSpanGroupById.');
            }
            const localVarPath = `/projects/{project_id}/page_load_span_groups/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary View a Release
         * @param {string} projectId ID of the Project
         * @param {string} releaseId ID of release to view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseById(projectId: string, releaseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectReleaseById.');
            }
            // verify required parameter 'releaseId' is not null or undefined
            if (releaseId === null || releaseId === undefined) {
                throw new RequiredError('releaseId', 'Required parameter releaseId was null or undefined when calling getProjectReleaseById.');
            }
            const localVarPath = `/projects/{project_id}/releases/{release_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"release_id"}}`, encodeURIComponent(String(releaseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there are no spans in the requested group, it will show a span group with an empty `statistics` attribute.
         * @summary Show a Span Group
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters10>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroup(projectId: string, id: string, filters?: Array<Filters10>, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectSpanGroup.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectSpanGroup.');
            }
            const localVarPath = `/projects/{project_id}/span_groups/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Span Group's distribution
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters13>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroupDistribution(projectId: string, id: string, filters?: Array<Filters13>, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectSpanGroupDistribution.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectSpanGroupDistribution.');
            }
            const localVarPath = `/projects/{project_id}/span_groups/{id}/distribution`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a Span Group's timeline
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters12>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroupTimeline(projectId: string, id: string, filters?: Array<Filters12>, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectSpanGroupTimeline.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getProjectSpanGroupTimeline.');
            }
            const localVarPath = `/projects/{project_id}/span_groups/{id}/timeline`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request the trend of unhandled session information (grouped by UTC day) in the last 30 days for the project's primary release stage.
         * @summary View the stability trend for a project
         * @param {string} projectId ID of the project to retrieve stability information for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectStabilityTrend(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getProjectStabilityTrend.');
            }
            const localVarPath = `/projects/{project_id}/stability_trend`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a Release Group
         * @param {string} id ID of release group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseGroup(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getReleaseGroup.');
            }
            const localVarPath = `/release_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Spans for a Span Group
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} category The name of the Span Group Category.
         * @param {string} name The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) name of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpansByCategoryAndName(projectId: string, category: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling getSpansByCategoryAndName.');
            }
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new RequiredError('category', 'Required parameter category was null or undefined when calling getSpansByCategoryAndName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling getSpansByCategoryAndName.');
            }
            const localVarPath = `/projects/{project_id}/span_group_categories/{category}/span_groups/{name}/spans`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"category"}}`, encodeURIComponent(String(category)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Event fields are the fields on event resources that can be used for filtering. This includes built-in fields and any custom filters. The event fields supported vary by project type.
         * @summary List the Event Fields for a Project
         * @param {string} projectId ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEventFields(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectEventFields.');
            }
            const localVarPath = `/projects/{project_id}/event_fields`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Feature Flag Summaries for a Project
         * @param {string} projectId ID of the Project.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatureFlagSummaries(projectId: string, q?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectFeatureFlagSummaries.');
            }
            const localVarPath = `/projects/{project_id}/feature_flag_summaries`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Feature Flags on a Project
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {boolean} [starredAtTop] Whether to return starred Feature Flags at the top of the Feature Flags list.
         * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for each Feature Flag.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {string} [firstSeen] Filter to Feature Flags that were first seen in the release stage within the specified time frame.
         * @param {boolean} [includeInactive] Whether to include inactive Feature Flags.
         * @param {string} [sort] Which field to sort on.
         * @param {string} [direction] Which direction to sort the results by.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatureFlags(projectId: string, releaseStageName: string, starredAtTop?: boolean, includeVariantSummary?: boolean, q?: string, firstSeen?: string, includeInactive?: boolean, sort?: string, direction?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectFeatureFlags.');
            }
            // verify required parameter 'releaseStageName' is not null or undefined
            if (releaseStageName === null || releaseStageName === undefined) {
                throw new RequiredError('releaseStageName', 'Required parameter releaseStageName was null or undefined when calling listProjectFeatureFlags.');
            }
            const localVarPath = `/projects/{project_id}/feature_flags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            if (starredAtTop !== undefined) {
                localVarQueryParameter['starred_at_top'] = starredAtTop;
            }

            if (includeVariantSummary !== undefined) {
                localVarQueryParameter['include_variant_summary'] = includeVariantSummary;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (firstSeen !== undefined) {
                localVarQueryParameter['first_seen'] = firstSeen;
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = includeInactive;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Page Load Span Groups
         * @param {string} projectId The ID of the Project to which the Page Load Span Groups belong.
         * @param {string} [sort] The field to sort the page load span groups by
         * @param {string} [direction] The direction to sort the page load span groups by
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters15>} [filters] The current filters that are being applied.
         * @param {boolean} [starredOnly] Whether to only return Page Load Span Groups the requesting user has starred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectPageLoadSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters15>, starredOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectPageLoadSpanGroups.');
            }
            const localVarPath = `/projects/{project_id}/page_load_span_groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (starredOnly !== undefined) {
                localVarQueryParameter['starred_only'] = starredOnly;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Release Groups on a Project
         * @param {string} projectId ID of the project
         * @param {string} releaseStageName name of release stage to list release groups for
         * @param {boolean} [topOnly] return only the top release groups (default false)
         * @param {boolean} [visibleOnly] return only visible release groups (default false)
         * @param {number} [perPage] how many results to return per page
         * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectReleaseGroups(projectId: string, releaseStageName: string, topOnly?: boolean, visibleOnly?: boolean, perPage?: number, pageToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectReleaseGroups.');
            }
            // verify required parameter 'releaseStageName' is not null or undefined
            if (releaseStageName === null || releaseStageName === undefined) {
                throw new RequiredError('releaseStageName', 'Required parameter releaseStageName was null or undefined when calling listProjectReleaseGroups.');
            }
            const localVarPath = `/projects/{project_id}/release_groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStageName !== undefined) {
                localVarQueryParameter['release_stage_name'] = releaseStageName;
            }

            if (topOnly !== undefined) {
                localVarQueryParameter['top_only'] = topOnly;
            }

            if (visibleOnly !== undefined) {
                localVarQueryParameter['visible_only'] = visibleOnly;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A release models a particular application version running in a particular release stage. In the case of mobile projects, a release is also associated with a version code or bundle version. To learn more, see the following resources on the [releases dashboard](https://docs.bugsnag.com/product/releases/releases-dashboard) and [build tool integrations](https://docs.bugsnag.com/build-integrations/).
         * @summary List Releases on a Project
         * @param {string} projectId ID of the Project
         * @param {string} [releaseStage] release stage to filter by
         * @param {string} [base] date and time (in ISO 8601 format) to search for releases before
         * @param {string} [sort] How to sort the results
         * @param {number} [offset] The pagination offset
         * @param {number} [perPage] How many results (between 1 and 10) to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectReleases(projectId: string, releaseStage?: string, base?: string, sort?: string, offset?: number, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectReleases.');
            }
            const localVarPath = `/projects/{project_id}/releases`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (releaseStage !== undefined) {
                localVarQueryParameter['release_stage'] = releaseStage;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Performance Targets for a Span Group by ID
         * @param {string} projectId The ID of the Project to which the span group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroupPerformanceTargets(projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectSpanGroupPerformanceTargets.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listProjectSpanGroupPerformanceTargets.');
            }
            const localVarPath = `/projects/{project_id}/span_groups/{id}/performance_targets`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Span Group Summaries for a Project
         * @param {string} projectId The ID of the Project to which the Span Groups belong.
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters11>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroupSummaries(projectId: string, perPage?: number, offset?: number, filters?: Array<Filters11>, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectSpanGroupSummaries.');
            }
            const localVarPath = `/projects/{project_id}/span_group_summaries`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there are no Span Groups, it returns an empty array.
         * @summary List Span Groups on a Project
         * @param {string} projectId The ID of the Project to which the Span Groups belong.
         * @param {string} [sort] The field to sort the span groups by
         * @param {string} [direction] The direction to sort the span groups by
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters9>} [filters] The current filters that are being applied.
         * @param {boolean} [starredOnly] Whether to only return Span Groups the requesting user has starred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters9>, starredOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectSpanGroups.');
            }
            const localVarPath = `/projects/{project_id}/span_groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (starredOnly !== undefined) {
                localVarQueryParameter['starred_only'] = starredOnly;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the names and properties of the requesting user's starred Span Groups for a project and optionally performance categories.
         * @summary List the starred Span Group descriptions
         * @param {string} projectId The ID of the project to which the Span Groups belong.
         * @param {Array<string>} [categories] The performance categories of the Span Groups.
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectStarredSpanGroups(projectId: string, categories?: Array<string>, perPage?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectStarredSpanGroups.');
            }
            const localVarPath = `/projects/{project_id}/starred_span_groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace fields are the fields used for filtering spans that are aggregated in span groups on a project. They include a name identifier and filter options for each field. See [Filtering](#introduction/filtering/trace-fields-and-performance-filtering) for more information.
         * @summary List the Trace Fields on a project
         * @param {string} projectId The ID of the Project to which the Trace Field belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectTraceFields(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listProjectTraceFields.');
            }
            const localVarPath = `/projects/{project_id}/trace_fields`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Releases on a Release Group
         * @param {string} releaseGroupId ID of release group to list releases for
         * @param {number} [perPage] how many results to return per page
         * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReleaseGroupReleases(releaseGroupId: string, perPage?: number, pageToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'releaseGroupId' is not null or undefined
            if (releaseGroupId === null || releaseGroupId === undefined) {
                throw new RequiredError('releaseGroupId', 'Required parameter releaseGroupId was null or undefined when calling listReleaseGroupReleases.');
            }
            const localVarPath = `/release_groups/{release_group_id}/releases`
                .replace(`{${"release_group_id"}}`, encodeURIComponent(String(releaseGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Spans for a Span Group by ID
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters14>} [filters] The current filters that are being applied.
         * @param {string} [sort] The field to sort the results by.
         * @param {string} [direction] The direction to sort the results by.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpansBySpanGroupId(projectId: string, id: string, filters?: Array<Filters14>, sort?: string, direction?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listSpansBySpanGroupId.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling listSpansBySpanGroupId.');
            }
            const localVarPath = `/projects/{project_id}/span_groups/{id}/spans`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List Spans for a Trace
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} traceId The ID of the Trace to which the spans belong.
         * @param {string} from Beginning of window to return spans from.
         * @param {string} to End of window to return spans from.
         * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpansByTraceId(projectId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling listSpansByTraceId.');
            }
            // verify required parameter 'traceId' is not null or undefined
            if (traceId === null || traceId === undefined) {
                throw new RequiredError('traceId', 'Required parameter traceId was null or undefined when calling listSpansByTraceId.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from', 'Required parameter from was null or undefined when calling listSpansByTraceId.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to', 'Required parameter to was null or undefined when calling listSpansByTraceId.');
            }
            const localVarPath = `/projects/{project_id}/traces/{trace_id}/spans`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"trace_id"}}`, encodeURIComponent(String(traceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (targetSpanId !== undefined) {
                localVarQueryParameter['target_span_id'] = targetSpanId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a new notifier API key for a project. This API key is used to configure the [notifier library](https://docs.bugsnag.com/platforms/) being used to report errors in the project. After regenerating a Project's notifier API key, your platform-specific notifier will need its configuration updated to use the new key. The previous key will not be supported. Note that a Project's notifier API key is different from both the Organization-level and User-level Data Access API auth tokens.
         * @summary Regenerate a Project's notifier API key
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateProjectApiKey(projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling regenerateProjectApiKey.');
            }
            const localVarPath = `/projects/{project_id}/api_key`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces all the ErrorAssignmentRules on the project with the rules supplied rules. If no rules are supplied, all rules on the project are deleted.
         * @summary Replace the ErrorAssignmentRules on a project
         * @param {ProjectIdErrorAssignmentRulesBody} body
         * @param {string} projectId The ID of the Project to which the ErrorAssignmentRule belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceProjectErrorAssignmentRules(body: ProjectIdErrorAssignmentRulesBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling replaceProjectErrorAssignmentRules.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling replaceProjectErrorAssignmentRules.');
            }
            const localVarPath = `/projects/{project_id}/error_assignment_rules`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdErrorAssignmentRulesBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Project
         * @param {ProjectsProjectIdBody} body
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(body: ProjectsProjectIdBody, projectId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateProject.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling updateProject.');
            }
            const localVarPath = `/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectsProjectIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a custom Event Field
         * @param {EventFieldsDisplayIdBody} body
         * @param {string} projectId ID of the Project
         * @param {string} displayId human friendly ID for the EventField
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectEventFieldByDisplayId(body: EventFieldsDisplayIdBody, projectId: string, displayId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateProjectEventFieldByDisplayId.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling updateProjectEventFieldByDisplayId.');
            }
            // verify required parameter 'displayId' is not null or undefined
            if (displayId === null || displayId === undefined) {
                throw new RequiredError('displayId', 'Required parameter displayId was null or undefined when calling updateProjectEventFieldByDisplayId.');
            }
            const localVarPath = `/projects/{project_id}/event_fields/{display_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"display_id"}}`, encodeURIComponent(String(displayId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventFieldsDisplayIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Project's Network Grouping Ruleset
         * @param {string} projectId The ID of the Project to retrieve the endpoints for
         * @param {ProjectIdNetworkEndpointGroupingBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNetworkGroupingRuleset(projectId: string, body?: ProjectIdNetworkEndpointGroupingBody, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling updateProjectNetworkGroupingRuleset.');
            }
            const localVarPath = `/projects/{project_id}/network_endpoint_grouping`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectIdNetworkEndpointGroupingBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Span Group
         * @param {SpanGroupsIdBody} body
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSpanGroup(body: SpanGroupsIdBody, projectId: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateProjectSpanGroup.');
            }
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling updateProjectSpanGroup.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateProjectSpanGroup.');
            }
            const localVarPath = `/projects/{project_id}/span_groups/{id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpanGroupsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a Release Group
         * @param {ReleaseGroupsIdBody} body
         * @param {string} id ID of release group to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReleaseGroup(body: ReleaseGroupsIdBody, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateReleaseGroup.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateReleaseGroup.');
            }
            const localVarPath = `/release_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReleaseGroupsIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Confirm an event deletion request
         * @param {string} projectId ID of the project of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmProjectEventDataDeletion(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).confirmProjectEventDataDeletion(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a Project in an Organization
         * @param {OrganizationIdProjectsBody} body
         * @param {string} organizationId ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationProject(body: OrganizationIdProjectsBody, organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createOrganizationProject(body, organizationId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a request to asynchronously delete events for the project. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
         * @summary Create an event deletion request
         * @param {ProjectIdEventDataDeletionsBody} body
         * @param {string} projectId ID of the project to delete events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventDataDeletion(body: ProjectIdEventDataDeletionsBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProjectEventDataDeletion(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request event data for the given project. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
         * @summary Create an event data request
         * @param {ProjectIdEventDataRequestsBody} body
         * @param {string} projectId ID of the project to request events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventDataRequest(body: ProjectIdEventDataRequestsBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2011> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProjectEventDataRequest(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a custom Event Field
         * @param {ProjectIdEventFieldsBody} body
         * @param {string} projectId ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventField(body: ProjectIdEventFieldsBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2013> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProjectEventField(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Star a Feature Flag
         * @param {ProjectIdStarredFeatureFlagsBody} body
         * @param {string} projectId ID of the Project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserStarredFeatureFlag(body: ProjectIdStarredFeatureFlagsBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createUserStarredFeatureFlag(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a Project
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProject(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a custom Event Field
         * @param {string} projectId ID of the Project
         * @param {string} displayId human friendly ID for the EventField
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEventFieldByDisplayId(projectId: string, displayId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProjectEventFieldByDisplayId(projectId, displayId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a Feature Flag
         * @param {string} projectId ID of the Project.
         * @param {string} id ID of the Feature Flag to unstar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectFeatureFlag(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProjectFeatureFlag(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Unstar a Feature Flag
         * @param {string} projectId ID of the Project.
         * @param {string} id ID of the Feature Flag to unstar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProjectStarredFeatureFlag(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteUserProjectStarredFeatureFlag(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a list of projects for the given organization.
         * @summary List an Organization's Projects
         * @param {string} organizationId the ID of the organization
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getOrganizationProjects(organizationId, q, sort, direction, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary View a Project
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProject(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check the status of an event deletion request
         * @param {string} projectId ID of the project of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEventDataDeletionById(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2012> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectEventDataDeletionById(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check the status of an event data request
         * @param {string} projectId ID of the project of the event data request
         * @param {string} id ID of the event data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEventDataRequestById(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2011> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectEventDataRequestById(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Feature Flag
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for the Feature Flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlag(id: string, projectId: string, releaseStageName: string, includeVariantSummary?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20038> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectFeatureFlag(id, projectId, releaseStageName, includeVariantSummary, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Feature Flag's Error Overview
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagErrorOverview(id: string, projectId: string, releaseStageName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20039> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectFeatureFlagErrorOverview(id, projectId, releaseStageName, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Variants on a Feature Flag by ID
         * @param {string} id ID of the feature flag.
         * @param {string} projectId ID of the project.
         * @param {string} [releaseStageName] Release stage name to get the variants for.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariants(id: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20041>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectFeatureFlagVariants(id, projectId, releaseStageName, q, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Variants on a Feature Flag by name
         * @param {string} name Name of the feature flag, case-sensitive and with no substring matching.
         * @param {string} projectId ID of the project.
         * @param {string} [releaseStageName] Release stage name to get the variants for.
         * @param {string} [q] Search for feature flag variants with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariantsByName(name: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20041>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectFeatureFlagVariantsByName(name, projectId, releaseStageName, q, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Feature Flag Variant's Error Overview
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {Array<string>} variantIds IDs for the FeatureFlag variants.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariantsErrorOverview(id: string, projectId: string, variantIds: Array<string>, releaseStageName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20040>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectFeatureFlagVariantsErrorOverview(id, projectId, variantIds, releaseStageName, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List a Project's Network Grouping Ruleset
         * @param {string} projectId The ID of the Project to retrieve the endpoints for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNetworkGroupingRuleset(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectNetworkGroupingRuleset(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Show a Page Load Span Group by ID
         * @param {string} projectId The ID of the Project to which the Page Load Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Page Load Span Group.
         * @param {Array<Filters16>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPageLoadSpanGroupById(projectId: string, id: string, filters?: Array<Filters16>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20050> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectPageLoadSpanGroupById(projectId, id, filters, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary View a Release
         * @param {string} projectId ID of the Project
         * @param {string} releaseId ID of release to view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseById(projectId: string, releaseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20034> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectReleaseById(projectId, releaseId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If there are no spans in the requested group, it will show a span group with an empty `statistics` attribute.
         * @summary Show a Span Group
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters10>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroup(projectId: string, id: string, filters?: Array<Filters10>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectSpanGroup(projectId, id, filters, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Span Group's distribution
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters13>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroupDistribution(projectId: string, id: string, filters?: Array<Filters13>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20046>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectSpanGroupDistribution(projectId, id, filters, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a Span Group's timeline
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters12>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroupTimeline(projectId: string, id: string, filters?: Array<Filters12>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20045>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectSpanGroupTimeline(projectId, id, filters, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request the trend of unhandled session information (grouped by UTC day) in the last 30 days for the project's primary release stage.
         * @summary View the stability trend for a project
         * @param {string} projectId ID of the project to retrieve stability information for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectStabilityTrend(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20035> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getProjectStabilityTrend(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve a Release Group
         * @param {string} id ID of release group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseGroup(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getReleaseGroup(id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get Spans for a Span Group
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} category The name of the Span Group Category.
         * @param {string} name The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) name of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpansByCategoryAndName(projectId: string, category: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).getSpansByCategoryAndName(projectId, category, name, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Event fields are the fields on event resources that can be used for filtering. This includes built-in fields and any custom filters. The event fields supported vary by project type.
         * @summary List the Event Fields for a Project
         * @param {string} projectId ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEventFields(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20030>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectEventFields(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Feature Flag Summaries for a Project
         * @param {string} projectId ID of the Project.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatureFlagSummaries(projectId: string, q?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20037>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectFeatureFlagSummaries(projectId, q, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Feature Flags on a Project
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {boolean} [starredAtTop] Whether to return starred Feature Flags at the top of the Feature Flags list.
         * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for each Feature Flag.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {string} [firstSeen] Filter to Feature Flags that were first seen in the release stage within the specified time frame.
         * @param {boolean} [includeInactive] Whether to include inactive Feature Flags.
         * @param {string} [sort] Which field to sort on.
         * @param {string} [direction] Which direction to sort the results by.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatureFlags(projectId: string, releaseStageName: string, starredAtTop?: boolean, includeVariantSummary?: boolean, q?: string, firstSeen?: string, includeInactive?: boolean, sort?: string, direction?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20036>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectFeatureFlags(projectId, releaseStageName, starredAtTop, includeVariantSummary, q, firstSeen, includeInactive, sort, direction, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Page Load Span Groups
         * @param {string} projectId The ID of the Project to which the Page Load Span Groups belong.
         * @param {string} [sort] The field to sort the page load span groups by
         * @param {string} [direction] The direction to sort the page load span groups by
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters15>} [filters] The current filters that are being applied.
         * @param {boolean} [starredOnly] Whether to only return Page Load Span Groups the requesting user has starred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectPageLoadSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters15>, starredOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20049>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectPageLoadSpanGroups(projectId, sort, direction, perPage, offset, filters, starredOnly, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Release Groups on a Project
         * @param {string} projectId ID of the project
         * @param {string} releaseStageName name of release stage to list release groups for
         * @param {boolean} [topOnly] return only the top release groups (default false)
         * @param {boolean} [visibleOnly] return only visible release groups (default false)
         * @param {number} [perPage] how many results to return per page
         * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectReleaseGroups(projectId: string, releaseStageName: string, topOnly?: boolean, visibleOnly?: boolean, perPage?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20031>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectReleaseGroups(projectId, releaseStageName, topOnly, visibleOnly, perPage, pageToken, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A release models a particular application version running in a particular release stage. In the case of mobile projects, a release is also associated with a version code or bundle version. To learn more, see the following resources on the [releases dashboard](https://docs.bugsnag.com/product/releases/releases-dashboard) and [build tool integrations](https://docs.bugsnag.com/build-integrations/).
         * @summary List Releases on a Project
         * @param {string} projectId ID of the Project
         * @param {string} [releaseStage] release stage to filter by
         * @param {string} [base] date and time (in ISO 8601 format) to search for releases before
         * @param {string} [sort] How to sort the results
         * @param {number} [offset] The pagination offset
         * @param {number} [perPage] How many results (between 1 and 10) to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectReleases(projectId: string, releaseStage?: string, base?: string, sort?: string, offset?: number, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20033>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectReleases(projectId, releaseStage, base, sort, offset, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Performance Targets for a Span Group by ID
         * @param {string} projectId The ID of the Project to which the span group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroupPerformanceTargets(projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20048>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectSpanGroupPerformanceTargets(projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Span Group Summaries for a Project
         * @param {string} projectId The ID of the Project to which the Span Groups belong.
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters11>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroupSummaries(projectId: string, perPage?: number, offset?: number, filters?: Array<Filters11>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20044>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectSpanGroupSummaries(projectId, perPage, offset, filters, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If there are no Span Groups, it returns an empty array.
         * @summary List Span Groups on a Project
         * @param {string} projectId The ID of the Project to which the Span Groups belong.
         * @param {string} [sort] The field to sort the span groups by
         * @param {string} [direction] The direction to sort the span groups by
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters9>} [filters] The current filters that are being applied.
         * @param {boolean} [starredOnly] Whether to only return Span Groups the requesting user has starred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters9>, starredOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20042>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectSpanGroups(projectId, sort, direction, perPage, offset, filters, starredOnly, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the names and properties of the requesting user's starred Span Groups for a project and optionally performance categories.
         * @summary List the starred Span Group descriptions
         * @param {string} projectId The ID of the project to which the Span Groups belong.
         * @param {Array<string>} [categories] The performance categories of the Span Groups.
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectStarredSpanGroups(projectId: string, categories?: Array<string>, perPage?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20047>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectStarredSpanGroups(projectId, categories, perPage, offset, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Trace fields are the fields used for filtering spans that are aggregated in span groups on a project. They include a name identifier and filter options for each field. See [Filtering](#introduction/filtering/trace-fields-and-performance-filtering) for more information.
         * @summary List the Trace Fields on a project
         * @param {string} projectId The ID of the Project to which the Trace Field belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectTraceFields(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20051>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectTraceFields(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Releases on a Release Group
         * @param {string} releaseGroupId ID of release group to list releases for
         * @param {number} [perPage] how many results to return per page
         * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReleaseGroupReleases(releaseGroupId: string, perPage?: number, pageToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20033>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listReleaseGroupReleases(releaseGroupId, perPage, pageToken, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Spans for a Span Group by ID
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters14>} [filters] The current filters that are being applied.
         * @param {string} [sort] The field to sort the results by.
         * @param {string} [direction] The direction to sort the results by.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpansBySpanGroupId(projectId: string, id: string, filters?: Array<Filters14>, sort?: string, direction?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20029>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listSpansBySpanGroupId(projectId, id, filters, sort, direction, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List Spans for a Trace
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} traceId The ID of the Trace to which the spans belong.
         * @param {string} from Beginning of window to return spans from.
         * @param {string} to End of window to return spans from.
         * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpansByTraceId(projectId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20029>> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listSpansByTraceId(projectId, traceId, from, to, targetSpanId, perPage, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate a new notifier API key for a project. This API key is used to configure the [notifier library](https://docs.bugsnag.com/platforms/) being used to report errors in the project. After regenerating a Project's notifier API key, your platform-specific notifier will need its configuration updated to use the new key. The previous key will not be supported. Note that a Project's notifier API key is different from both the Organization-level and User-level Data Access API auth tokens.
         * @summary Regenerate a Project's notifier API key
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateProjectApiKey(projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).regenerateProjectApiKey(projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Replaces all the ErrorAssignmentRules on the project with the rules supplied rules. If no rules are supplied, all rules on the project are deleted.
         * @summary Replace the ErrorAssignmentRules on a project
         * @param {ProjectIdErrorAssignmentRulesBody} body
         * @param {string} projectId The ID of the Project to which the ErrorAssignmentRule belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceProjectErrorAssignmentRules(body: ProjectIdErrorAssignmentRulesBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).replaceProjectErrorAssignmentRules(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a Project
         * @param {ProjectsProjectIdBody} body
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(body: ProjectsProjectIdBody, projectId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).updateProject(body, projectId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a custom Event Field
         * @param {EventFieldsDisplayIdBody} body
         * @param {string} projectId ID of the Project
         * @param {string} displayId human friendly ID for the EventField
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectEventFieldByDisplayId(body: EventFieldsDisplayIdBody, projectId: string, displayId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2013> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).updateProjectEventFieldByDisplayId(body, projectId, displayId, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a Project's Network Grouping Ruleset
         * @param {string} projectId The ID of the Project to retrieve the endpoints for
         * @param {ProjectIdNetworkEndpointGroupingBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNetworkGroupingRuleset(projectId: string, body?: ProjectIdNetworkEndpointGroupingBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).updateProjectNetworkGroupingRuleset(projectId, body, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update Span Group
         * @param {SpanGroupsIdBody} body
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSpanGroup(body: SpanGroupsIdBody, projectId: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).updateProjectSpanGroup(body, projectId, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a Release Group
         * @param {ReleaseGroupsIdBody} body
         * @param {string} id ID of release group to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReleaseGroup(body: ReleaseGroupsIdBody, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).updateReleaseGroup(body, id, options);
            return (fetch: FetchAPI = globalThis.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Confirm an event deletion request
         * @param {string} projectId ID of the project of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmProjectEventDataDeletion(projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).confirmProjectEventDataDeletion(projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a Project in an Organization
         * @param {OrganizationIdProjectsBody} body
         * @param {string} organizationId ID of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationProject(body: OrganizationIdProjectsBody, organizationId: string, options?: any) {
            return ProjectsApiFp(configuration).createOrganizationProject(body, organizationId, options)(fetch, basePath);
        },
        /**
         * Creates a request to asynchronously delete events for the project. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
         * @summary Create an event deletion request
         * @param {ProjectIdEventDataDeletionsBody} body
         * @param {string} projectId ID of the project to delete events from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventDataDeletion(body: ProjectIdEventDataDeletionsBody, projectId: string, options?: any) {
            return ProjectsApiFp(configuration).createProjectEventDataDeletion(body, projectId, options)(fetch, basePath);
        },
        /**
         * Request event data for the given project. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
         * @summary Create an event data request
         * @param {ProjectIdEventDataRequestsBody} body
         * @param {string} projectId ID of the project to request events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventDataRequest(body: ProjectIdEventDataRequestsBody, projectId: string, options?: any) {
            return ProjectsApiFp(configuration).createProjectEventDataRequest(body, projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a custom Event Field
         * @param {ProjectIdEventFieldsBody} body
         * @param {string} projectId ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectEventField(body: ProjectIdEventFieldsBody, projectId: string, options?: any) {
            return ProjectsApiFp(configuration).createProjectEventField(body, projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Star a Feature Flag
         * @param {ProjectIdStarredFeatureFlagsBody} body
         * @param {string} projectId ID of the Project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserStarredFeatureFlag(body: ProjectIdStarredFeatureFlagsBody, projectId: string, options?: any) {
            return ProjectsApiFp(configuration).createUserStarredFeatureFlag(body, projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a Project
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).deleteProject(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a custom Event Field
         * @param {string} projectId ID of the Project
         * @param {string} displayId human friendly ID for the EventField
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectEventFieldByDisplayId(projectId: string, displayId: string, options?: any) {
            return ProjectsApiFp(configuration).deleteProjectEventFieldByDisplayId(projectId, displayId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a Feature Flag
         * @param {string} projectId ID of the Project.
         * @param {string} id ID of the Feature Flag to unstar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectFeatureFlag(projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).deleteProjectFeatureFlag(projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Unstar a Feature Flag
         * @param {string} projectId ID of the Project.
         * @param {string} id ID of the Feature Flag to unstar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserProjectStarredFeatureFlag(projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).deleteUserProjectStarredFeatureFlag(projectId, id, options)(fetch, basePath);
        },
        /**
         * Returns a list of projects for the given organization.
         * @summary List an Organization's Projects
         * @param {string} organizationId the ID of the organization
         * @param {string} [q] Search projects with names matching parameter
         * @param {string} [sort] Which field to sort the results by
         * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
         * @param {number} [perPage] How many results to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).getOrganizationProjects(organizationId, q, sort, direction, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary View a Project
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).getProject(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the status of an event deletion request
         * @param {string} projectId ID of the project of the deletion request
         * @param {string} id ID of the deletion request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEventDataDeletionById(projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectEventDataDeletionById(projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the status of an event data request
         * @param {string} projectId ID of the project of the event data request
         * @param {string} id ID of the event data request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectEventDataRequestById(projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectEventDataRequestById(projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Feature Flag
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for the Feature Flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlag(id: string, projectId: string, releaseStageName: string, includeVariantSummary?: boolean, options?: any) {
            return ProjectsApiFp(configuration).getProjectFeatureFlag(id, projectId, releaseStageName, includeVariantSummary, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Feature Flag's Error Overview
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagErrorOverview(id: string, projectId: string, releaseStageName: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectFeatureFlagErrorOverview(id, projectId, releaseStageName, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Variants on a Feature Flag by ID
         * @param {string} id ID of the feature flag.
         * @param {string} projectId ID of the project.
         * @param {string} [releaseStageName] Release stage name to get the variants for.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariants(id: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).getProjectFeatureFlagVariants(id, projectId, releaseStageName, q, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Variants on a Feature Flag by name
         * @param {string} name Name of the feature flag, case-sensitive and with no substring matching.
         * @param {string} projectId ID of the project.
         * @param {string} [releaseStageName] Release stage name to get the variants for.
         * @param {string} [q] Search for feature flag variants with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariantsByName(name: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).getProjectFeatureFlagVariantsByName(name, projectId, releaseStageName, q, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Feature Flag Variant's Error Overview
         * @param {string} id ID of the FeatureFlag.
         * @param {string} projectId ID of the Project.
         * @param {Array<string>} variantIds IDs for the FeatureFlag variants.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectFeatureFlagVariantsErrorOverview(id: string, projectId: string, variantIds: Array<string>, releaseStageName: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectFeatureFlagVariantsErrorOverview(id, projectId, variantIds, releaseStageName, options)(fetch, basePath);
        },
        /**
         *
         * @summary List a Project's Network Grouping Ruleset
         * @param {string} projectId The ID of the Project to retrieve the endpoints for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectNetworkGroupingRuleset(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectNetworkGroupingRuleset(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Show a Page Load Span Group by ID
         * @param {string} projectId The ID of the Project to which the Page Load Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Page Load Span Group.
         * @param {Array<Filters16>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectPageLoadSpanGroupById(projectId: string, id: string, filters?: Array<Filters16>, options?: any) {
            return ProjectsApiFp(configuration).getProjectPageLoadSpanGroupById(projectId, id, filters, options)(fetch, basePath);
        },
        /**
         *
         * @summary View a Release
         * @param {string} projectId ID of the Project
         * @param {string} releaseId ID of release to view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectReleaseById(projectId: string, releaseId: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectReleaseById(projectId, releaseId, options)(fetch, basePath);
        },
        /**
         * If there are no spans in the requested group, it will show a span group with an empty `statistics` attribute.
         * @summary Show a Span Group
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters10>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroup(projectId: string, id: string, filters?: Array<Filters10>, options?: any) {
            return ProjectsApiFp(configuration).getProjectSpanGroup(projectId, id, filters, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Span Group's distribution
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters13>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroupDistribution(projectId: string, id: string, filters?: Array<Filters13>, options?: any) {
            return ProjectsApiFp(configuration).getProjectSpanGroupDistribution(projectId, id, filters, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a Span Group's timeline
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters12>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSpanGroupTimeline(projectId: string, id: string, filters?: Array<Filters12>, options?: any) {
            return ProjectsApiFp(configuration).getProjectSpanGroupTimeline(projectId, id, filters, options)(fetch, basePath);
        },
        /**
         * Request the trend of unhandled session information (grouped by UTC day) in the last 30 days for the project's primary release stage.
         * @summary View the stability trend for a project
         * @param {string} projectId ID of the project to retrieve stability information for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectStabilityTrend(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).getProjectStabilityTrend(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve a Release Group
         * @param {string} id ID of release group to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReleaseGroup(id: string, options?: any) {
            return ProjectsApiFp(configuration).getReleaseGroup(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get Spans for a Span Group
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} category The name of the Span Group Category.
         * @param {string} name The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) name of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpansByCategoryAndName(projectId: string, category: string, name: string, options?: any) {
            return ProjectsApiFp(configuration).getSpansByCategoryAndName(projectId, category, name, options)(fetch, basePath);
        },
        /**
         * Event fields are the fields on event resources that can be used for filtering. This includes built-in fields and any custom filters. The event fields supported vary by project type.
         * @summary List the Event Fields for a Project
         * @param {string} projectId ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectEventFields(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).listProjectEventFields(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Feature Flag Summaries for a Project
         * @param {string} projectId ID of the Project.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatureFlagSummaries(projectId: string, q?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).listProjectFeatureFlagSummaries(projectId, q, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Feature Flags on a Project
         * @param {string} projectId ID of the Project.
         * @param {string} releaseStageName Release stage name to get the feature flags for.
         * @param {boolean} [starredAtTop] Whether to return starred Feature Flags at the top of the Feature Flags list.
         * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for each Feature Flag.
         * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
         * @param {string} [firstSeen] Filter to Feature Flags that were first seen in the release stage within the specified time frame.
         * @param {boolean} [includeInactive] Whether to include inactive Feature Flags.
         * @param {string} [sort] Which field to sort on.
         * @param {string} [direction] Which direction to sort the results by.
         * @param {number} [perPage] How many results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectFeatureFlags(projectId: string, releaseStageName: string, starredAtTop?: boolean, includeVariantSummary?: boolean, q?: string, firstSeen?: string, includeInactive?: boolean, sort?: string, direction?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).listProjectFeatureFlags(projectId, releaseStageName, starredAtTop, includeVariantSummary, q, firstSeen, includeInactive, sort, direction, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Page Load Span Groups
         * @param {string} projectId The ID of the Project to which the Page Load Span Groups belong.
         * @param {string} [sort] The field to sort the page load span groups by
         * @param {string} [direction] The direction to sort the page load span groups by
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters15>} [filters] The current filters that are being applied.
         * @param {boolean} [starredOnly] Whether to only return Page Load Span Groups the requesting user has starred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectPageLoadSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters15>, starredOnly?: boolean, options?: any) {
            return ProjectsApiFp(configuration).listProjectPageLoadSpanGroups(projectId, sort, direction, perPage, offset, filters, starredOnly, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Release Groups on a Project
         * @param {string} projectId ID of the project
         * @param {string} releaseStageName name of release stage to list release groups for
         * @param {boolean} [topOnly] return only the top release groups (default false)
         * @param {boolean} [visibleOnly] return only visible release groups (default false)
         * @param {number} [perPage] how many results to return per page
         * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectReleaseGroups(projectId: string, releaseStageName: string, topOnly?: boolean, visibleOnly?: boolean, perPage?: number, pageToken?: string, options?: any) {
            return ProjectsApiFp(configuration).listProjectReleaseGroups(projectId, releaseStageName, topOnly, visibleOnly, perPage, pageToken, options)(fetch, basePath);
        },
        /**
         * A release models a particular application version running in a particular release stage. In the case of mobile projects, a release is also associated with a version code or bundle version. To learn more, see the following resources on the [releases dashboard](https://docs.bugsnag.com/product/releases/releases-dashboard) and [build tool integrations](https://docs.bugsnag.com/build-integrations/).
         * @summary List Releases on a Project
         * @param {string} projectId ID of the Project
         * @param {string} [releaseStage] release stage to filter by
         * @param {string} [base] date and time (in ISO 8601 format) to search for releases before
         * @param {string} [sort] How to sort the results
         * @param {number} [offset] The pagination offset
         * @param {number} [perPage] How many results (between 1 and 10) to return per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectReleases(projectId: string, releaseStage?: string, base?: string, sort?: string, offset?: number, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).listProjectReleases(projectId, releaseStage, base, sort, offset, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Performance Targets for a Span Group by ID
         * @param {string} projectId The ID of the Project to which the span group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroupPerformanceTargets(projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).listProjectSpanGroupPerformanceTargets(projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Span Group Summaries for a Project
         * @param {string} projectId The ID of the Project to which the Span Groups belong.
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters11>} [filters] The current filters that are being applied.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroupSummaries(projectId: string, perPage?: number, offset?: number, filters?: Array<Filters11>, options?: any) {
            return ProjectsApiFp(configuration).listProjectSpanGroupSummaries(projectId, perPage, offset, filters, options)(fetch, basePath);
        },
        /**
         * If there are no Span Groups, it returns an empty array.
         * @summary List Span Groups on a Project
         * @param {string} projectId The ID of the Project to which the Span Groups belong.
         * @param {string} [sort] The field to sort the span groups by
         * @param {string} [direction] The direction to sort the span groups by
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {Array<Filters9>} [filters] The current filters that are being applied.
         * @param {boolean} [starredOnly] Whether to only return Span Groups the requesting user has starred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters9>, starredOnly?: boolean, options?: any) {
            return ProjectsApiFp(configuration).listProjectSpanGroups(projectId, sort, direction, perPage, offset, filters, starredOnly, options)(fetch, basePath);
        },
        /**
         * List the names and properties of the requesting user's starred Span Groups for a project and optionally performance categories.
         * @summary List the starred Span Group descriptions
         * @param {string} projectId The ID of the project to which the Span Groups belong.
         * @param {Array<string>} [categories] The performance categories of the Span Groups.
         * @param {number} [perPage] the number of results per page
         * @param {number} [offset] the offset for the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectStarredSpanGroups(projectId: string, categories?: Array<string>, perPage?: number, offset?: number, options?: any) {
            return ProjectsApiFp(configuration).listProjectStarredSpanGroups(projectId, categories, perPage, offset, options)(fetch, basePath);
        },
        /**
         * Trace fields are the fields used for filtering spans that are aggregated in span groups on a project. They include a name identifier and filter options for each field. See [Filtering](#introduction/filtering/trace-fields-and-performance-filtering) for more information.
         * @summary List the Trace Fields on a project
         * @param {string} projectId The ID of the Project to which the Trace Field belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectTraceFields(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).listProjectTraceFields(projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Releases on a Release Group
         * @param {string} releaseGroupId ID of release group to list releases for
         * @param {number} [perPage] how many results to return per page
         * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReleaseGroupReleases(releaseGroupId: string, perPage?: number, pageToken?: string, options?: any) {
            return ProjectsApiFp(configuration).listReleaseGroupReleases(releaseGroupId, perPage, pageToken, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Spans for a Span Group by ID
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {Array<Filters14>} [filters] The current filters that are being applied.
         * @param {string} [sort] The field to sort the results by.
         * @param {string} [direction] The direction to sort the results by.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpansBySpanGroupId(projectId: string, id: string, filters?: Array<Filters14>, sort?: string, direction?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).listSpansBySpanGroupId(projectId, id, filters, sort, direction, perPage, options)(fetch, basePath);
        },
        /**
         *
         * @summary List Spans for a Trace
         * @param {string} projectId The ID of the Project to which the spans belong.
         * @param {string} traceId The ID of the Trace to which the spans belong.
         * @param {string} from Beginning of window to return spans from.
         * @param {string} to End of window to return spans from.
         * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
         * @param {number} [perPage] The number of results to return per page. Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpansByTraceId(projectId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options?: any) {
            return ProjectsApiFp(configuration).listSpansByTraceId(projectId, traceId, from, to, targetSpanId, perPage, options)(fetch, basePath);
        },
        /**
         * Generate a new notifier API key for a project. This API key is used to configure the [notifier library](https://docs.bugsnag.com/platforms/) being used to report errors in the project. After regenerating a Project's notifier API key, your platform-specific notifier will need its configuration updated to use the new key. The previous key will not be supported. Note that a Project's notifier API key is different from both the Organization-level and User-level Data Access API auth tokens.
         * @summary Regenerate a Project's notifier API key
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateProjectApiKey(projectId: string, options?: any) {
            return ProjectsApiFp(configuration).regenerateProjectApiKey(projectId, options)(fetch, basePath);
        },
        /**
         * Replaces all the ErrorAssignmentRules on the project with the rules supplied rules. If no rules are supplied, all rules on the project are deleted.
         * @summary Replace the ErrorAssignmentRules on a project
         * @param {ProjectIdErrorAssignmentRulesBody} body
         * @param {string} projectId The ID of the Project to which the ErrorAssignmentRule belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceProjectErrorAssignmentRules(body: ProjectIdErrorAssignmentRulesBody, projectId: string, options?: any) {
            return ProjectsApiFp(configuration).replaceProjectErrorAssignmentRules(body, projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a Project
         * @param {ProjectsProjectIdBody} body
         * @param {string} projectId ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(body: ProjectsProjectIdBody, projectId: string, options?: any) {
            return ProjectsApiFp(configuration).updateProject(body, projectId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a custom Event Field
         * @param {EventFieldsDisplayIdBody} body
         * @param {string} projectId ID of the Project
         * @param {string} displayId human friendly ID for the EventField
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectEventFieldByDisplayId(body: EventFieldsDisplayIdBody, projectId: string, displayId: string, options?: any) {
            return ProjectsApiFp(configuration).updateProjectEventFieldByDisplayId(body, projectId, displayId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a Project's Network Grouping Ruleset
         * @param {string} projectId The ID of the Project to retrieve the endpoints for
         * @param {ProjectIdNetworkEndpointGroupingBody} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNetworkGroupingRuleset(projectId: string, body?: ProjectIdNetworkEndpointGroupingBody, options?: any) {
            return ProjectsApiFp(configuration).updateProjectNetworkGroupingRuleset(projectId, body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update Span Group
         * @param {SpanGroupsIdBody} body
         * @param {string} projectId The ID of the Project to which the Span Group belongs.
         * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSpanGroup(body: SpanGroupsIdBody, projectId: string, id: string, options?: any) {
            return ProjectsApiFp(configuration).updateProjectSpanGroup(body, projectId, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a Release Group
         * @param {ReleaseGroupsIdBody} body
         * @param {string} id ID of release group to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReleaseGroup(body: ReleaseGroupsIdBody, id: string, options?: any) {
            return ProjectsApiFp(configuration).updateReleaseGroup(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     *
     * @summary Confirm an event deletion request
     * @param {string} projectId ID of the project of the deletion request
     * @param {string} id ID of the deletion request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public confirmProjectEventDataDeletion(projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).confirmProjectEventDataDeletion(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a Project in an Organization
     * @param {OrganizationIdProjectsBody} body
     * @param {string} organizationId ID of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createOrganizationProject(body: OrganizationIdProjectsBody, organizationId: string, options?: any) {
        return ProjectsApiFp(this.configuration).createOrganizationProject(body, organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a request to asynchronously delete events for the project. Note that filters such as `user.email` and `user.name` use substring matching, so using the `user.id` filter will be more appropriate for deleting events for 1 specific user.
     * @summary Create an event deletion request
     * @param {ProjectIdEventDataDeletionsBody} body
     * @param {string} projectId ID of the project to delete events from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectEventDataDeletion(body: ProjectIdEventDataDeletionsBody, projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).createProjectEventDataDeletion(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     * Request event data for the given project. This request will start an asynchronous job to collate all event data present at the time of the request and return a URL where you can download the data when the job is complete. These endpoints are intended for bulk download of events. If you want to query events, use the Events APIs instead. User data will not be included in the bulk download unless the request's `report_type` attribute is set to `gdpr`. With the `report_type` set to `gdpr` Bugsnag will only return user-related metadata.
     * @summary Create an event data request
     * @param {ProjectIdEventDataRequestsBody} body
     * @param {string} projectId ID of the project to request events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectEventDataRequest(body: ProjectIdEventDataRequestsBody, projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).createProjectEventDataRequest(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a custom Event Field
     * @param {ProjectIdEventFieldsBody} body
     * @param {string} projectId ID of the Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createProjectEventField(body: ProjectIdEventFieldsBody, projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).createProjectEventField(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Star a Feature Flag
     * @param {ProjectIdStarredFeatureFlagsBody} body
     * @param {string} projectId ID of the Project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public createUserStarredFeatureFlag(body: ProjectIdStarredFeatureFlagsBody, projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).createUserStarredFeatureFlag(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a Project
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a custom Event Field
     * @param {string} projectId ID of the Project
     * @param {string} displayId human friendly ID for the EventField
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectEventFieldByDisplayId(projectId: string, displayId: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProjectEventFieldByDisplayId(projectId, displayId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete a Feature Flag
     * @param {string} projectId ID of the Project.
     * @param {string} id ID of the Feature Flag to unstar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProjectFeatureFlag(projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProjectFeatureFlag(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Unstar a Feature Flag
     * @param {string} projectId ID of the Project.
     * @param {string} id ID of the Feature Flag to unstar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteUserProjectStarredFeatureFlag(projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteUserProjectStarredFeatureFlag(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a list of projects for the given organization.
     * @summary List an Organization's Projects
     * @param {string} organizationId the ID of the organization
     * @param {string} [q] Search projects with names matching parameter
     * @param {string} [sort] Which field to sort the results by
     * @param {string} [direction] Which direction to sort the results by. Defaults to &#x60;desc&#x60; for all sorts except &#x60;favorite&#x60;. Defaults to &#x60;asc&#x60; if sorting by &#x60;favorite&#x60; (cannot sort &#x60;favorite&#x60;s &#x60;desc&#x60;).
     * @param {number} [perPage] How many results to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getOrganizationProjects(organizationId: string, q?: string, sort?: string, direction?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).getOrganizationProjects(organizationId, q, sort, direction, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary View a Project
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check the status of an event deletion request
     * @param {string} projectId ID of the project of the deletion request
     * @param {string} id ID of the deletion request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectEventDataDeletionById(projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectEventDataDeletionById(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check the status of an event data request
     * @param {string} projectId ID of the project of the event data request
     * @param {string} id ID of the event data request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectEventDataRequestById(projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectEventDataRequestById(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a Feature Flag
     * @param {string} id ID of the FeatureFlag.
     * @param {string} projectId ID of the Project.
     * @param {string} releaseStageName Release stage name to get the feature flags for.
     * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for the Feature Flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectFeatureFlag(id: string, projectId: string, releaseStageName: string, includeVariantSummary?: boolean, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectFeatureFlag(id, projectId, releaseStageName, includeVariantSummary, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a Feature Flag's Error Overview
     * @param {string} id ID of the FeatureFlag.
     * @param {string} projectId ID of the Project.
     * @param {string} releaseStageName Release stage name to get the feature flags for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectFeatureFlagErrorOverview(id: string, projectId: string, releaseStageName: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectFeatureFlagErrorOverview(id, projectId, releaseStageName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Variants on a Feature Flag by ID
     * @param {string} id ID of the feature flag.
     * @param {string} projectId ID of the project.
     * @param {string} [releaseStageName] Release stage name to get the variants for.
     * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
     * @param {number} [perPage] How many results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectFeatureFlagVariants(id: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectFeatureFlagVariants(id, projectId, releaseStageName, q, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Variants on a Feature Flag by name
     * @param {string} name Name of the feature flag, case-sensitive and with no substring matching.
     * @param {string} projectId ID of the project.
     * @param {string} [releaseStageName] Release stage name to get the variants for.
     * @param {string} [q] Search for feature flag variants with a name matching this query parameter. Supports case-insensitive substring matching.
     * @param {number} [perPage] How many results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectFeatureFlagVariantsByName(name: string, projectId: string, releaseStageName?: string, q?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectFeatureFlagVariantsByName(name, projectId, releaseStageName, q, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a Feature Flag Variant's Error Overview
     * @param {string} id ID of the FeatureFlag.
     * @param {string} projectId ID of the Project.
     * @param {Array<string>} variantIds IDs for the FeatureFlag variants.
     * @param {string} releaseStageName Release stage name to get the feature flags for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectFeatureFlagVariantsErrorOverview(id: string, projectId: string, variantIds: Array<string>, releaseStageName: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectFeatureFlagVariantsErrorOverview(id, projectId, variantIds, releaseStageName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List a Project's Network Grouping Ruleset
     * @param {string} projectId The ID of the Project to retrieve the endpoints for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectNetworkGroupingRuleset(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectNetworkGroupingRuleset(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Show a Page Load Span Group by ID
     * @param {string} projectId The ID of the Project to which the Page Load Span Group belongs.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Page Load Span Group.
     * @param {Array<Filters16>} [filters] The current filters that are being applied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectPageLoadSpanGroupById(projectId: string, id: string, filters?: Array<Filters16>, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectPageLoadSpanGroupById(projectId, id, filters, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary View a Release
     * @param {string} projectId ID of the Project
     * @param {string} releaseId ID of release to view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectReleaseById(projectId: string, releaseId: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectReleaseById(projectId, releaseId, options)(this.fetch, this.basePath);
    }

    /**
     * If there are no spans in the requested group, it will show a span group with an empty `statistics` attribute.
     * @summary Show a Span Group
     * @param {string} projectId The ID of the Project to which the Span Group belongs.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
     * @param {Array<Filters10>} [filters] The current filters that are being applied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectSpanGroup(projectId: string, id: string, filters?: Array<Filters10>, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectSpanGroup(projectId, id, filters, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a Span Group's distribution
     * @param {string} projectId The ID of the Project to which the Span Group belongs.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
     * @param {Array<Filters13>} [filters] The current filters that are being applied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectSpanGroupDistribution(projectId: string, id: string, filters?: Array<Filters13>, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectSpanGroupDistribution(projectId, id, filters, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a Span Group's timeline
     * @param {string} projectId The ID of the Project to which the Span Group belongs.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
     * @param {Array<Filters12>} [filters] The current filters that are being applied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectSpanGroupTimeline(projectId: string, id: string, filters?: Array<Filters12>, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectSpanGroupTimeline(projectId, id, filters, options)(this.fetch, this.basePath);
    }

    /**
     * Request the trend of unhandled session information (grouped by UTC day) in the last 30 days for the project's primary release stage.
     * @summary View the stability trend for a project
     * @param {string} projectId ID of the project to retrieve stability information for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjectStabilityTrend(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProjectStabilityTrend(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Retrieve a Release Group
     * @param {string} id ID of release group to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getReleaseGroup(id: string, options?: any) {
        return ProjectsApiFp(this.configuration).getReleaseGroup(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get Spans for a Span Group
     * @param {string} projectId The ID of the Project to which the spans belong.
     * @param {string} category The name of the Span Group Category.
     * @param {string} name The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) name of the Span Group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getSpansByCategoryAndName(projectId: string, category: string, name: string, options?: any) {
        return ProjectsApiFp(this.configuration).getSpansByCategoryAndName(projectId, category, name, options)(this.fetch, this.basePath);
    }

    /**
     * Event fields are the fields on event resources that can be used for filtering. This includes built-in fields and any custom filters. The event fields supported vary by project type.
     * @summary List the Event Fields for a Project
     * @param {string} projectId ID of the Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectEventFields(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectEventFields(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Feature Flag Summaries for a Project
     * @param {string} projectId ID of the Project.
     * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
     * @param {number} [perPage] How many results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectFeatureFlagSummaries(projectId: string, q?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectFeatureFlagSummaries(projectId, q, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Feature Flags on a Project
     * @param {string} projectId ID of the Project.
     * @param {string} releaseStageName Release stage name to get the feature flags for.
     * @param {boolean} [starredAtTop] Whether to return starred Feature Flags at the top of the Feature Flags list.
     * @param {boolean} [includeVariantSummary] Whether to include a summary of the Variants for each Feature Flag.
     * @param {string} [q] Search for feature flags with a name matching this query parameter. Supports case-insensitive substring matching.
     * @param {string} [firstSeen] Filter to Feature Flags that were first seen in the release stage within the specified time frame.
     * @param {boolean} [includeInactive] Whether to include inactive Feature Flags.
     * @param {string} [sort] Which field to sort on.
     * @param {string} [direction] Which direction to sort the results by.
     * @param {number} [perPage] How many results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectFeatureFlags(projectId: string, releaseStageName: string, starredAtTop?: boolean, includeVariantSummary?: boolean, q?: string, firstSeen?: string, includeInactive?: boolean, sort?: string, direction?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectFeatureFlags(projectId, releaseStageName, starredAtTop, includeVariantSummary, q, firstSeen, includeInactive, sort, direction, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Page Load Span Groups
     * @param {string} projectId The ID of the Project to which the Page Load Span Groups belong.
     * @param {string} [sort] The field to sort the page load span groups by
     * @param {string} [direction] The direction to sort the page load span groups by
     * @param {number} [perPage] the number of results per page
     * @param {number} [offset] the offset for the next page of results
     * @param {Array<Filters15>} [filters] The current filters that are being applied.
     * @param {boolean} [starredOnly] Whether to only return Page Load Span Groups the requesting user has starred.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectPageLoadSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters15>, starredOnly?: boolean, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectPageLoadSpanGroups(projectId, sort, direction, perPage, offset, filters, starredOnly, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Release Groups on a Project
     * @param {string} projectId ID of the project
     * @param {string} releaseStageName name of release stage to list release groups for
     * @param {boolean} [topOnly] return only the top release groups (default false)
     * @param {boolean} [visibleOnly] return only visible release groups (default false)
     * @param {number} [perPage] how many results to return per page
     * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectReleaseGroups(projectId: string, releaseStageName: string, topOnly?: boolean, visibleOnly?: boolean, perPage?: number, pageToken?: string, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectReleaseGroups(projectId, releaseStageName, topOnly, visibleOnly, perPage, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     * A release models a particular application version running in a particular release stage. In the case of mobile projects, a release is also associated with a version code or bundle version. To learn more, see the following resources on the [releases dashboard](https://docs.bugsnag.com/product/releases/releases-dashboard) and [build tool integrations](https://docs.bugsnag.com/build-integrations/).
     * @summary List Releases on a Project
     * @param {string} projectId ID of the Project
     * @param {string} [releaseStage] release stage to filter by
     * @param {string} [base] date and time (in ISO 8601 format) to search for releases before
     * @param {string} [sort] How to sort the results
     * @param {number} [offset] The pagination offset
     * @param {number} [perPage] How many results (between 1 and 10) to return per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectReleases(projectId: string, releaseStage?: string, base?: string, sort?: string, offset?: number, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectReleases(projectId, releaseStage, base, sort, offset, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Performance Targets for a Span Group by ID
     * @param {string} projectId The ID of the Project to which the span group belongs.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectSpanGroupPerformanceTargets(projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectSpanGroupPerformanceTargets(projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Span Group Summaries for a Project
     * @param {string} projectId The ID of the Project to which the Span Groups belong.
     * @param {number} [perPage] the number of results per page
     * @param {number} [offset] the offset for the next page of results
     * @param {Array<Filters11>} [filters] The current filters that are being applied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectSpanGroupSummaries(projectId: string, perPage?: number, offset?: number, filters?: Array<Filters11>, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectSpanGroupSummaries(projectId, perPage, offset, filters, options)(this.fetch, this.basePath);
    }

    /**
     * If there are no Span Groups, it returns an empty array.
     * @summary List Span Groups on a Project
     * @param {string} projectId The ID of the Project to which the Span Groups belong.
     * @param {string} [sort] The field to sort the span groups by
     * @param {string} [direction] The direction to sort the span groups by
     * @param {number} [perPage] the number of results per page
     * @param {number} [offset] the offset for the next page of results
     * @param {Array<Filters9>} [filters] The current filters that are being applied.
     * @param {boolean} [starredOnly] Whether to only return Span Groups the requesting user has starred.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectSpanGroups(projectId: string, sort?: string, direction?: string, perPage?: number, offset?: number, filters?: Array<Filters9>, starredOnly?: boolean, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectSpanGroups(projectId, sort, direction, perPage, offset, filters, starredOnly, options)(this.fetch, this.basePath);
    }

    /**
     * List the names and properties of the requesting user's starred Span Groups for a project and optionally performance categories.
     * @summary List the starred Span Group descriptions
     * @param {string} projectId The ID of the project to which the Span Groups belong.
     * @param {Array<string>} [categories] The performance categories of the Span Groups.
     * @param {number} [perPage] the number of results per page
     * @param {number} [offset] the offset for the next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectStarredSpanGroups(projectId: string, categories?: Array<string>, perPage?: number, offset?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectStarredSpanGroups(projectId, categories, perPage, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Trace fields are the fields used for filtering spans that are aggregated in span groups on a project. They include a name identifier and filter options for each field. See [Filtering](#introduction/filtering/trace-fields-and-performance-filtering) for more information.
     * @summary List the Trace Fields on a project
     * @param {string} projectId The ID of the Project to which the Trace Field belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listProjectTraceFields(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).listProjectTraceFields(projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Releases on a Release Group
     * @param {string} releaseGroupId ID of release group to list releases for
     * @param {number} [perPage] how many results to return per page
     * @param {string} [pageToken] value from the next relation in the Link response header to obtain the next page of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listReleaseGroupReleases(releaseGroupId: string, perPage?: number, pageToken?: string, options?: any) {
        return ProjectsApiFp(this.configuration).listReleaseGroupReleases(releaseGroupId, perPage, pageToken, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Spans for a Span Group by ID
     * @param {string} projectId The ID of the Project to which the spans belong.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
     * @param {Array<Filters14>} [filters] The current filters that are being applied.
     * @param {string} [sort] The field to sort the results by.
     * @param {string} [direction] The direction to sort the results by.
     * @param {number} [perPage] The number of results to return per page. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listSpansBySpanGroupId(projectId: string, id: string, filters?: Array<Filters14>, sort?: string, direction?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listSpansBySpanGroupId(projectId, id, filters, sort, direction, perPage, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary List Spans for a Trace
     * @param {string} projectId The ID of the Project to which the spans belong.
     * @param {string} traceId The ID of the Trace to which the spans belong.
     * @param {string} from Beginning of window to return spans from.
     * @param {string} to End of window to return spans from.
     * @param {string} [targetSpanId] The ID of a Span within the Trace to focus on. If provided the target Span and its direct children will be returned ahead of other Spans in the Trace.
     * @param {number} [perPage] The number of results to return per page. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public listSpansByTraceId(projectId: string, traceId: string, from: string, to: string, targetSpanId?: string, perPage?: number, options?: any) {
        return ProjectsApiFp(this.configuration).listSpansByTraceId(projectId, traceId, from, to, targetSpanId, perPage, options)(this.fetch, this.basePath);
    }

    /**
     * Generate a new notifier API key for a project. This API key is used to configure the [notifier library](https://docs.bugsnag.com/platforms/) being used to report errors in the project. After regenerating a Project's notifier API key, your platform-specific notifier will need its configuration updated to use the new key. The previous key will not be supported. Note that a Project's notifier API key is different from both the Organization-level and User-level Data Access API auth tokens.
     * @summary Regenerate a Project's notifier API key
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public regenerateProjectApiKey(projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).regenerateProjectApiKey(projectId, options)(this.fetch, this.basePath);
    }

    /**
     * Replaces all the ErrorAssignmentRules on the project with the rules supplied rules. If no rules are supplied, all rules on the project are deleted.
     * @summary Replace the ErrorAssignmentRules on a project
     * @param {ProjectIdErrorAssignmentRulesBody} body
     * @param {string} projectId The ID of the Project to which the ErrorAssignmentRule belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public replaceProjectErrorAssignmentRules(body: ProjectIdErrorAssignmentRulesBody, projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).replaceProjectErrorAssignmentRules(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a Project
     * @param {ProjectsProjectIdBody} body
     * @param {string} projectId ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProject(body: ProjectsProjectIdBody, projectId: string, options?: any) {
        return ProjectsApiFp(this.configuration).updateProject(body, projectId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a custom Event Field
     * @param {EventFieldsDisplayIdBody} body
     * @param {string} projectId ID of the Project
     * @param {string} displayId human friendly ID for the EventField
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectEventFieldByDisplayId(body: EventFieldsDisplayIdBody, projectId: string, displayId: string, options?: any) {
        return ProjectsApiFp(this.configuration).updateProjectEventFieldByDisplayId(body, projectId, displayId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a Project's Network Grouping Ruleset
     * @param {string} projectId The ID of the Project to retrieve the endpoints for
     * @param {ProjectIdNetworkEndpointGroupingBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectNetworkGroupingRuleset(projectId: string, body?: ProjectIdNetworkEndpointGroupingBody, options?: any) {
        return ProjectsApiFp(this.configuration).updateProjectNetworkGroupingRuleset(projectId, body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update Span Group
     * @param {SpanGroupsIdBody} body
     * @param {string} projectId The ID of the Project to which the Span Group belongs.
     * @param {string} id The [URL-encoded](https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding) ID of the Span Group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateProjectSpanGroup(body: SpanGroupsIdBody, projectId: string, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).updateProjectSpanGroup(body, projectId, id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update a Release Group
     * @param {ReleaseGroupsIdBody} body
     * @param {string} id ID of release group to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public updateReleaseGroup(body: ReleaseGroupsIdBody, id: string, options?: any) {
        return ProjectsApiFp(this.configuration).updateReleaseGroup(body, id, options)(this.fetch, this.basePath);
    }

}
